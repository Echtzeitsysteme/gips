grammar org.emoflon.gips.gipsl.Gipsl with org.emoflon.ibex.gt.editor.GT

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.emoflon.org/ibex/gt/editor/GT" as GT

generate gipsl "http://www.emoflon.org/gips/gipsl/Gipsl"

// TODO: Do not use abbreviations within names

@Override 
EditorGTFile: {EditorGTFile}
	package = Package
	(imports+=EditorImport)*
	(importedPattern+=ImportedPattern)*
	config = GipsConfig
  	(patterns+=EditorPattern |
  	conditions+=EditorCondition |
  	mappings += GipsMapping |
  	constraints += GipsConstraint |
  	objectives += GipsObjective)*
  	(globalObjective = GipsGlobalObjective)?	
;

Package: 
	'package' name=GipsStringLiteral
;

ImportedPattern : 
	'from' file = GipsStringLiteral 'import' pattern = [GT::EditorPattern|ID]
;

GipsConfig : {GipsConfig}
	'config' '{'
	'solver' ':=' solver=SolverType '[' ('home' ':=' home=GipsStringLiteral ',' 'license' ':=' license=GipsStringLiteral)? ']' ';'
	('launchConfig' ':=' enableLaunchConfig = GipsBoolean '[' 'main' ':=' mainLoc=GipsStringLiteral ']' ';')?
	('timeLimit' ':=' enableLimit = GipsBoolean '[' 'value' ':=' timeLimit=GipsDouble ']' ';')?
	('randomSeed' ':=' enableSeed = GipsBoolean '[' 'value' ':=' rndSeed=GipsInteger ']' ';')?
	('presolve' ':=' enablePresolve = GipsBoolean ';')?
	('debugOutput' ':=' enableDebugOutput = GipsBoolean ';')?
	('tolerance' ':=' enableTolerance = GipsBoolean '[' 'value' ':=' tolerance=GipsDouble ']' ';')?
	('lpOutput' ':=' enableLpOutput = GipsBoolean '[' 'path' ':=' path=GipsStringLiteral ']' ';')?
	'}'
;

enum SolverType:
	GUROBI='GUROBI' | GLPK='GLPK' | CPLEX='CPLEX'
;

GipsMapping :
	'mapping' name=ID 'with' pattern=[GT::EditorPattern|ID] ('{'
		(variables += GipsMappingVariable)+
	'}')?';'
;

GipsMappingVariable :
	'var' name=ID ':' type=[ecore::EDataType] (bound ?= 'bind' parameter=[GT::EditorParameter])?
;

// TODO: Change '->' to 'with'
// TODO: Remove global as context. Global constraints should be defined implicitly by omitting the context.
// TODO: Remove implicit multiplication of mapping variable if one is missing. Remove validator checking for this case.
GipsConstraint : 
	'constraint' '->' context=(GipsGlobalContext | GipsMappingContext | GipsTypeContext | GipsPatternContext) '{'
		expr = GipsBool
	'}'
;

// TODO: Change '->' to 'with'
// TODO: Remove implicit multiplication of mapping variable if one is missing. Remove validator checking for this case.
GipsObjective : 
	'objective' name=ID '->' context=(GipsMappingContext | GipsTypeContext | GipsPatternContext) '{'
		expr = GipsArithmeticExpr
	'}'
;

// TODO: Remove me!
GipsGlobalContext: {GlobalContext}
	'global'
;

GipsMappingContext:
	'mapping' '::' mapping = [GipsMapping|ID]
;

// TODO: Change to 'type'
GipsTypeContext:
	'class' '::' type = [ecore::EClassifier]
;

GipsPatternContext:
	'pattern' '::' pattern = [GT::EditorPattern|ID]
;

GipsObjectiveExpression:
	objective=[GipsObjective|ID]
;

// TODO: Change 'objectiveGoal' to 'goal' and 'GipsOjectiveGoal' to 'OptimizationGoal' 
GipsGlobalObjective :
	'global' 'objective' ':' objectiveGoal = GipsObjectiveGoal ('{'
		expr = GipsArithmeticExpr
	'}')?
;

// TODO: Change 'GipsOjectiveGoal' to 'OptimizationGoal' 
enum GipsObjectiveGoal:
	MIN = 'min' | MAX = 'max'
;

// TODO: Delete
GipsBool:
	expr=GipsBoolExpr
;

// TODO: Rename to GipsBooleanExpression
GipsBoolExpr:
	GipsImplicationBoolExpr
;

// TODO: Rename to GipsBooleanImplication
// TODO: Rename GipsImplicationBoolExpr.left to GipsBooleanImplication.left
GipsImplicationBoolExpr returns GipsBoolExpr:
	GipsOrBoolExpr({GipsImplicationBoolExpr.left = current} operator=GipsImplOperator right=GipsOrBoolExpr)*
;

// TODO: Rename to GipsBooleanDisjunction
// TODO: Rename GipsOrBoolExpr.left to GipsBooleanDisjunction.left
GipsOrBoolExpr returns GipsBoolExpr:
	GipsAndBoolExpr({GipsOrBoolExpr.left = current} operator=GipsOrOperator right=GipsAndBoolExpr)*
;

// TODO: Rename to GipsBooleanConjunction
// TODO: Rename GipsBooleanDisjunction.left to GipsBooleanConjunction.left
GipsAndBoolExpr returns GipsBoolExpr:
	GipsNotBoolExpr({GipsAndBoolExpr.left = current} operator=GipsAndOperator right=GipsNotBoolExpr)*
;

// TODO: Rename to GipsBooleanNegation
GipsNotBoolExpr returns GipsBoolExpr: {GipsNotBoolExpr}
	'!' operand=GipsBracketBoolExpr | GipsBracketBoolExpr
;

// TODO: Rename to GipsBooleanBracket
GipsBracketBoolExpr returns GipsBoolExpr: {GipsBracketBoolExpr}
	'[' operand=GipsBoolExpr ']'  | GipsBooleanLiteral | GipsRelExpr
;

enum GipsImplOperator:
  IMPLICATION='=>' |
  EQUIVALENCE='<=>'
;

enum GipsOrOperator:
  OR='|' |
  XOR='^'
;

enum GipsAndOperator:
  AND='&'
;

GipsBooleanLiteral:
	literal = GipsBoolean
;

GipsRelExpr:
	left=GipsArithmeticExpr (operator=GipsRelOperator right=GipsArithmeticExpr)?
;

enum GipsRelOperator:
  GREATER='>' |
  GREATER_OR_EQUAL='>=' |
  EQUAL='==' |
  UNEQUAL='!=' |
  SMALLER_OR_EQUAL='<=' |
  SMALLER='<'
;

//TODO: Change to ValueExpression
GipsAttributeExpr:
	// value = (					// Add
	GipsMappingAttributeExpr | 		// Keep, rename
	GipsTypeAttributeExpr | 		// Keep, rename
	GipsPatternAttributeExpr | 		// Keep, rename
	GipsContextExpr | 				// Keep, rename
	GipsLambdaAttributeExpression | // Keep, rename
	GipsLambdaSelfExpression		// Delete
	//) 							// Add
	// (setExperession = SetExpression)? // Add
;

//TODO: Change to GipsMappingExpression
//TODO: Remove '-> expr'
GipsMappingAttributeExpr returns GipsAttributeExpr: {GipsMappingAttributeExpr}
	'mappings' '.' mapping=[GipsMapping|ID] '->' expr = GipsStreamExpr
;

//TODO: Change to GipsTypeExpression and 'classes' to 'types'.
//TODO: Remove '-> expr'
GipsTypeAttributeExpr returns GipsAttributeExpr: {GipsTypeAttributeExpr}
	'classes' '.' type=[ecore::EClass] '->' expr = GipsStreamExpr
;

//TODO: Change to GipsPatternExpression
//TODO: Remove '-> expr'
GipsPatternAttributeExpr returns GipsAttributeExpr: {GipsPatternAttributeExpr}
	'patterns' '.' pattern=[GT::EditorPattern|ID] '->' expr = GipsStreamExpr
;

//TODO: Change to GipsSetElementExpression
//TODO: Remove var and prepend 'element'
//TODO: Make dot-Operation optional
//TODO: Nested streams are now possible but should be forbidden in the validator.
GipsLambdaAttributeExpression returns GipsAttributeExpr: {GipsLambdaAttributeExpression}
	var=[GipsLambdaExpression|ID] '.' 				// See comment above
	(expr = GipsNodeAttributeExpr | 				// Rename: GipsNodeExpression
		expr = GipsVariableOperationExpression | 	// Rename: GipsVariableExpression
		expr = GipsFeatureExpr | 					// Rename: GipsAttributeExpression
		expr = GipsMappingVariableReference			// Delete
	) // ('->' stream = GipsStreamExpr)?			// Delete -> No nested streams for now!
;

//TODO: Can be removed, if Xtext doesn't complain.
GipsLambdaSelfExpression returns GipsAttributeExpr: {GipsLambdaSelfExpression}
	var=[GipsLambdaExpression|ID] '()'
;

//TODO: Change to GipsLocalContextExpression and rename 'self' to 'context'
//TODO: Remove '-> expr'
GipsContextExpr returns GipsAttributeExpr: {GipsContextExpr}
	'self' ('.' typeCast=GipsTypeCast)? ('.' (expr = GipsNodeAttributeExpr | expr = GipsVariableOperationExpression | expr = GipsFeatureExpr | expr = GipsMappingVariableReference) ('->' stream = GipsStreamExpr)?)?
;

// TODO: Change to GipsVariableExpression and remove isMapped
// TODO: Remove () from 'value()'
GipsVariableOperationExpression returns GipsVariableOperationExpression: 
	// '.'
	{GipsMappingValue} 'value()' |
	// 'variables' '.' variable = [GipsMappingVariable|ID]
	{GipsMappingCheckValue} 'isMapped' '(' (count=GipsContextExpr)? ')' // Remove
;

// TODO: Remove
GipsMappingVariableReference:
	'variables().' var=[GipsMappingVariable|ID]
;

GipsTypeCast:
	'toType(' type=[ecore::EClass] ')'
;

// TODO: Change to GipsNodeExpression
// TODO: Remove () from 'nodes()'
GipsNodeAttributeExpr: {GipsNodeAttributeExpr}
	'nodes().' node=[GT::EditorNode|ID] ('.' typeCast=GipsTypeCast)? 
	('.' expr = GipsFeatureExpr)?	// Remove
	// ('.' attributeExpression = GipsAttributeExpression)
;

// TODO: Change to GipsAttributeExpression
GipsFeatureExpr:
	GipsFeatureNavigation
;

// TODO: Change to GipsAttributeNavigation
GipsFeatureNavigation returns GipsFeatureExpr:
	GipsFeatureLit ({GipsFeatureNavigation.left=current} '.' right=GipsFeatureNavigation)?
;

// TODO: Change to GipsAttributeLiteral
GipsFeatureLit returns GipsFeatureExpr: {GipsFeatureLit}
	feature = [ecore::EStructuralFeature] ('.' typeCast=GipsTypeCast)?
;

GipsArithmeticExpr:
	GipsSumArithmeticExpr
;

GipsSumArithmeticExpr returns GipsArithmeticExpr:
	GipsProductArithmeticExpr({GipsSumArithmeticExpr.left = current} operator=GipsSumOperator right=GipsProductArithmeticExpr)*
;

GipsProductArithmeticExpr returns GipsArithmeticExpr:
	GipsExpArithmeticExpr({GipsProductArithmeticExpr.left = current} operator=GipsProductOperator right=GipsExpArithmeticExpr)*
;

GipsExpArithmeticExpr returns GipsArithmeticExpr:
	GipsUnaryArithmeticExpr({GipsExpArithmeticExpr.left = current} operator=GipsExpOperator right=GipsUnaryArithmeticExpr)*
;

GipsUnaryArithmeticExpr returns GipsArithmeticExpr: {GipsUnaryArithmeticExpr}
	operator=GipsArithmeticUnaryOperator '(' operand=GipsBracketExpr ')' | GipsBracketExpr
;

GipsBracketExpr returns GipsArithmeticExpr: {GipsBracketExpr}
	'(' operand=GipsArithmeticExpr ')' | GipsExpressionOperand
;

GipsExpressionOperand:
	GipsAttributeExpr | GipsObjectiveExpression | GipsArithmeticLiteral | GipsConstant
;

GipsArithmeticLiteral:
	value = (GipsDoubleLiteral | GipsIntegerLiteral)
;

GipsConstant:
	value = GipsConstantLiteral
;

enum GipsConstantLiteral:
	PI = 'pi' |
	E = 'e' |
	NULL = 'null'
;

enum GipsProductOperator:
	MULT='*' |
 	DIV='/'
;

enum GipsExpOperator:
 	POW='pow'	|
 	LOG='log'
;

enum GipsSumOperator:
	PLUS='+' 	|
	MINUS='-' 	
;

enum GipsArithmeticUnaryOperator:
	NEG='-'		|
	ABS='abs'	|
	SQRT='sqrt' |
	sin='sin'	|
	cos='cos'
;

// TODO: Change to GipsSetExpression
GipsStreamExpr:
	// '->'
	// ( operation = GipsFilterOperation
	//	rhs = GipsSetExpression |
	// operation = GipsSumOperation)
	GipsStreamNavigation		// Remove
;

// TODO: Add
/*	GipsFilterOperation:
 * 	'filter' '(' expression=GipsBooleanExpression ')'
 *  ;
 * 
 */
 
 // TODO: Add
 /*	GipsSumOperation:
  * 'sum' '(' expression = GipsArithmeticExpression ')'
  * ;
  * 
  */

// TODO: Remove
GipsStreamNavigation returns GipsStreamExpr:
	GipsStreamLit({GipsStreamNavigation.left=current}'->' right=GipsStreamNavigation)?
;

// TODO: Remove
GipsStreamLit returns GipsStreamExpr:
	{GipsSelect} 'typesOf' '(' type=[ecore::EClassifier] ')' |
	{GipsStreamSet} operator=GipsStreamSetOperator lambda = GipsLambdaExpression |
	{GipsStreamArithmetic} operator=GipsStreamArithmeticOperator lambda = GipsLambdaExpression |
	{GipsContains} 'contains' '(' expr = GipsContextExpr ')' |
	{GipsStreamBoolExpr} operator=GipsStreamNoArgOperator
;

// TODO: Remove
GipsLambdaExpression:
	'(' name=ID '|' expr=GipsBoolExpr ')'
;

// TODO: Remove
enum GipsStreamSetOperator:
	FILTER='filter'
;

// TODO: Remove
enum GipsStreamArithmeticOperator:
	SUM = 'sum'
;

// TODO: Remove
enum GipsStreamNoArgOperator:
	NOT_EMPTY = 'notEmpty()' |
	COUNT = 'count()'
;

GipsDoubleLiteral:
	GipsDouble
;

GipsIntegerLiteral:
	GipsInteger
;

GipsDouble returns ecore::EDouble:
	('-')?INT '.' INT
;

GipsInteger returns ecore::EInt:
	(('-')? INT)
;

@Override
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9')*
;

GipsBoolean returns ecore::EBoolean:
	TRUE | FALSE
;

terminal TRUE returns ecore::EBoolean:
	'true'
;

terminal FALSE returns ecore::EBoolean:
	'false'
;

GipsStringLiteral:
	STRING
;

@Override
terminal STRING returns ecore::EString:
	'"' ( '""' | !('"') )* '"'
;