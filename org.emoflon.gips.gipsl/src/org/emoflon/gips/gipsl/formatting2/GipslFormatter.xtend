/*
 * generated by Xtext 2.37.0
 */
package org.emoflon.gips.gipsl.formatting2

import static org.emoflon.gips.gipsl.gipsl.GipslPackage.Literals.*

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.emoflon.gips.gipsl.gipsl.EditorGTFile
import org.emoflon.gips.gipsl.gipsl.GipsMapping
import org.emoflon.gips.gipsl.services.GipslGrammarAccess
import org.emoflon.ibex.gt.editor.formatting2.GTFormatter
import org.emoflon.gips.gipsl.gipsl.GipsConstant
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.emoflon.gips.gipsl.gipsl.ImportedPattern
import org.emoflon.ibex.gt.editor.gT.EditorCondition
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction
import org.emoflon.gips.gipsl.gipsl.GipsObjective
import org.emoflon.gips.gipsl.gipsl.GipsConstraint
import org.emoflon.gips.gipsl.gipsl.GipsConfig
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable
import org.emoflon.gips.gipsl.gipsl.GipsBooleanImplication
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticSum
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticProduct
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticExponential
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticUnary
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticBracket
import org.emoflon.gips.gipsl.gipsl.GipsConstantReference
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticOperand
import org.emoflon.gips.gipsl.gipsl.GipsBooleanDisjunction
import org.emoflon.gips.gipsl.gipsl.GipsBooleanConjunction
import org.emoflon.gips.gipsl.gipsl.GipsBooleanNegation
import org.emoflon.gips.gipsl.gipsl.GipsBooleanBracket
import org.emoflon.gips.gipsl.gipsl.GipsRelationalExpression
import org.emoflon.gips.gipsl.gipsl.GipsLocalContextExpression
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression
import org.emoflon.gips.gipsl.gipsl.GipsSetElementExpression
import org.emoflon.gips.gipsl.gipsl.GipsNodeExpression
import org.emoflon.gips.gipsl.gipsl.GipsVariableReferenceExpression
import org.emoflon.gips.gipsl.gipsl.GipsAttributeExpression
import org.emoflon.gips.gipsl.gipsl.GipsSetExpression
import org.emoflon.gips.gipsl.gipsl.GipsFilterOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeSelect
import org.emoflon.gips.gipsl.gipsl.GipsSortOperation
import org.emoflon.gips.gipsl.gipsl.GipsSortPredicate
import org.emoflon.gips.gipsl.gipsl.GipsSimpleAlgorithm
import org.emoflon.gips.gipsl.gipsl.GipsConcatenationOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression
import org.emoflon.gips.gipsl.gipsl.GipsTransformOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeQuery
import org.emoflon.gips.gipsl.gipsl.GipsElementQuery
import org.emoflon.gips.gipsl.gipsl.GipsSimpleQuery
import org.emoflon.gips.gipsl.gipsl.GipsSimpleSelect
import org.emoflon.gips.gipsl.gipsl.GipsSumOperation
import org.eclipse.xtext.Keyword
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.emoflon.ibex.gt.editor.gT.GTPackage
import org.eclipse.xtext.formatting2.FormatterPreferenceKeys
import org.eclipse.xtext.formatting2.regionaccess.ITextSegment
import org.eclipse.xtext.formatting2.IFormatter2
import java.util.LinkedList
import java.util.Collections
import org.eclipse.xtext.formatting2.regionaccess.IComment
import org.eclipse.xtext.formatting2.ITextReplacer
import org.eclipse.xtext.AbstractRule
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder

import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionFinder
import org.eclipse.xtext.formatting2.regionaccess.internal.SemanticRegionNullFinder
import org.eclipse.xtext.formatting2.regionaccess.internal.SemanticRegionInIterableFinder
import org.eclipse.xtext.formatting2.regionaccess.internal.SemanticRegionIterable
import org.eclipse.xtext.formatting2.internal.SinglelineDocCommentReplacer
import org.eclipse.xtext.grammaranalysis.impl.GrammarElementTitleSwitch
import org.eclipse.xtext.formatting2.internal.MultilineCommentReplacer
import org.eclipse.xtext.formatting2.internal.SinglelineCodeCommentReplacer
import org.eclipse.xtext.formatting2.internal.WhitespaceReplacer
import org.eclipse.xtext.formatting2.IHiddenRegionFormatting

class GipslFormatter extends GTFormatter implements IFormatter2 {

	@Inject extension GipslGrammarAccess

	def dispatch void format(EditorGTFile editorGTFile, extension IFormattableDocument document) {
		editorGTFile.prepend[setNewLines(0, 0, 1); noSpace]

		// _format(editorGTFile as org.emoflon.ibex.gt.editor.gT.EditorGTFile, document);
		// because EditorGTFile extends EditorGTFile, we need to call explicitly the method on EditorGTFile 
		// (if we want the gt formatting on the whole file)
		editorGTFile.package.format

		formatList(editorGTFile.imports, document, 1, 1, -1)

		formatList(editorGTFile.importedPattern, document, 2, 1, -1)

		editorGTFile.config.prepend[newLines = 2]
		editorGTFile.config.format

		// At this point, everything can be declared in any order. 
		// Each element needs to be checked on a case-by-case basis.
		// To make this work, each element can only modify the hidden region 'in front' of itself; 
		// otherwise, a ConflictingRegionsException might be triggered.
		for (editorPattern : editorGTFile.patterns)
			editorPattern.format.prepend[newLines = 2]

		for (editorCondition : editorGTFile.conditions)
			editorCondition.format.prepend[newLines = 2]

		for (gipsMapping : editorGTFile.mappings)
			gipsMapping.format.prepend[newLines = 2]

		for (gipsConstraint : editorGTFile.constraints)
			gipsConstraint.format.prepend[newLines = 2]

		for (gipsConstant : editorGTFile.constants)
			gipsConstant.format.prepend[newLines = 2]

		for (gipsLinearFunction : editorGTFile.functions)
			gipsLinearFunction.format.prepend[newLines = 2]

		editorGTFile.objective.format.prepend[newLines = 2]

		editorGTFile.append[newLine]
	}

	def dispatch void format(org.emoflon.gips.gipsl.gipsl.Package gipsPackage,
		extension IFormattableDocument document) {
		gipsPackage.regionFor.keyword(packageAccess.packageKeyword_0).append[oneSpace]
	}

	def dispatch void format(ImportedPattern importedPattern, extension IFormattableDocument document) {
		importedPattern.regionFor.keyword(importedPatternAccess.fromKeyword_0).append[oneSpace]
		importedPattern.regionFor.keyword(importedPatternAccess.importKeyword_2).prepend[oneSpace].append[oneSpace]
	}

	def dispatch void format(GipsConfig gipsConfig, extension IFormattableDocument document) {
		gipsConfig.regionFor.keyword(gipsConfigAccess.configKeyword_1).append[oneSpace]
		gipsConfig.regionFor.keyword(gipsConfigAccess.leftCurlyBracketKeyword_2).append[noSpace; newLine]

		val body = gipsConfig.regionFor.keywordPairs(gipsConfigAccess.leftCurlyBracketKeyword_2,
			gipsConfigAccess.rightCurlyBracketKeyword_16)
		if(body.size > 0)
			body.get(0).interior[indent]

		gipsConfig.regionFor.keywords(":=").forEach[surround[oneSpace]]

		gipsConfig.regionFor.keyword(gipsConfigAccess.rightCurlyBracketKeyword_16).prepend[newLine]

		val details = gipsConfig.regionFor.keywordPairs("[", "]")
		for (detail : details) {
			val separators = detail.regionFor.keywords(",")

			val start = detail.key.previousHiddenRegion.offset
			val length = detail.value.endOffset - start

			document.formatConditionally(
				start,
				length,
				[ doc |
					val extension subdoc = doc.requireFitsInLine

					detail.key.prepend[oneSpace].append[noSpace]
					detail.value.prepend[noSpace]

					for (separator : separators)
						separator.prepend[noSpace].append[oneSpace]
				],
				[ extension subdoc |
					detail.key.prepend[oneSpace].append[newLine]
					detail.value.prepend[newLine]
					detail.interior([indent])

					for (separator : separators)
						separator.prepend[noSpace].append[newLine]
				]
			)
		}

		gipsConfig.regionFor.keywords(";").forEach[prepend[noSpace].append[newLine]]
	}

	def dispatch void format(GipsMapping gipsMapping, extension IFormattableDocument document) {
		gipsMapping.regionFor.keyword(gipsMappingAccess.mappingKeyword_0).append[oneSpace]
		gipsMapping.regionFor.keyword(gipsMappingAccess.toKeyword_2).surround[oneSpace]

//		val moreThanOneVariable = gipsMapping.variables.length > 1
//		if(moreThanOneVariable) {
		gipsMapping.regionFor.keyword(gipsMappingAccess.leftCurlyBracketKeyword_4_0).prepend[oneSpace]

		val body = gipsMapping.regionFor.keywordPairs(gipsMappingAccess.leftCurlyBracketKeyword_4_0,
			gipsMappingAccess.rightCurlyBracketKeyword_4_2)
		if(body.length > 0)
			body.get(0).interior[indent]

		for (gipsMappingVariable : gipsMapping.variables)
			gipsMappingVariable.format.surround[newLine]

		gipsMapping.regionFor.keyword(gipsMappingAccess.rightCurlyBracketKeyword_4_2).prepend[noSpace]
//		} else {
//			gipsMapping.regionFor.keyword(gipsMappingAccess.leftCurlyBracketKeyword_4_0).surround[oneSpace]
//			for (gipsMappingVariable : gipsMapping.variables)
//				gipsMappingVariable.format.append[oneSpace]
//		}
		gipsMapping.regionFor.keyword(gipsMappingAccess.semicolonKeyword_5).prepend[noSpace]
	}

	def dispatch void format(GipsMappingVariable gipsMappingVariable, extension IFormattableDocument document) {
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.varKeyword_0).append[oneSpace]
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.colonKeyword_2).surround[oneSpace]
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.boundBindKeyword_4_0_0).surround[oneSpace]
		gipsMappingVariable.formatChilds(document)
	}

	def dispatch void format(GipsConstant gipsConstant, extension IFormattableDocument document) {
		gipsConstant.regionFor.keyword(gipsConstantAccess.letKeyword_0).append[oneSpace]
		gipsConstant.regionFor.keyword(gipsConstantAccess.colonEqualsSignKeyword_2).surround[oneSpace]
		gipsConstant.regionFor.keyword(gipsConstantAccess.semicolonKeyword_4).prepend[noSpace]
		gipsConstant.formatChilds(document)
	}

	def dispatch void format(GipsConstantReference gipsConstantReference, extension IFormattableDocument document) {
		gipsConstantReference.regionFor.keyword(gipsConstantReferenceAccess.fullStopKeyword_1).surround[noSpace]
		gipsConstantReference.formatChilds(document)
	}

	def dispatch void format(GipsConstraint gipsConstraint, extension IFormattableDocument document) {
		gipsConstraint.regionFor.keyword(gipsConstraintAccess.isLocalWithKeyword_1_0_0).surround[oneSpace]
		gipsConstraint.regionFor.keyword(gipsConstraintAccess.leftCurlyBracketKeyword_2).prepend[oneSpace]

		val body = gipsConstraint.regionFor.keywordPairs(gipsConstraintAccess.leftCurlyBracketKeyword_2,
			gipsConstraintAccess.rightCurlyBracketKeyword_5)
		if(body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsConstraint.constants)
			gipsConstant.format.surround[newLine]

		gipsConstraint.expression.format.surround[newLine]
	}

	def dispatch void format(GipsLinearFunction gipsLinearFunction, extension IFormattableDocument document) {
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.functionKeyword_0).append[oneSpace]
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.withKeyword_2).surround[oneSpace]
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.leftCurlyBracketKeyword_4).prepend[oneSpace]

		val body = gipsLinearFunction.regionFor.keywordPairs(gipsLinearFunctionAccess.leftCurlyBracketKeyword_4,
			gipsLinearFunctionAccess.rightCurlyBracketKeyword_7)
		if(body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsLinearFunction.constants)
			gipsConstant.format.surround[newLine]

		gipsLinearFunction.expression.format.surround[newLine]
	}

	// handled by GipsArithmeticOperand
//	def dispatch void format(GipsLinearFunctionReference gipsLinearFunctionReference, extension IFormattableDocument document) {}
//
	def dispatch void format(GipsObjective gipsObjective, extension IFormattableDocument document) {
		gipsObjective.regionFor.keyword(gipsObjectiveAccess.colonKeyword_1).surround[oneSpace]
		gipsObjective.regionFor.keyword(gipsObjectiveAccess.leftCurlyBracketKeyword_3).prepend[oneSpace]

		val body = gipsObjective.regionFor.keywordPairs(gipsObjectiveAccess.leftCurlyBracketKeyword_3,
			gipsObjectiveAccess.rightCurlyBracketKeyword_6)
		if(body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsObjective.constants)
			gipsConstant.format.surround[newLine]

		gipsObjective.expression.format.surround[newLine]
	}

//	 def dispatch void format(GipsBooleanExpression gipsBooleanExpression, extension IFormattableDocument document) {}
//	
	def dispatch void format(GipsBooleanImplication expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_BOOLEAN_IMPLICATION__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsBooleanDisjunction expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_BOOLEAN_DISJUNCTION__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsBooleanConjunction expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_BOOLEAN_CONJUNCTION__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsBooleanNegation expr, extension IFormattableDocument document) {
		// no space between '!' and operand
		expr.operand.format.prepend[noSpace; noAutowrap]
	}

	def dispatch void format(GipsBooleanBracket expr, extension IFormattableDocument document) {
		expr.operand.format

		val isMultiLine = expr.operand.previousHiddenRegion.isMultiline
		if(isMultiLine) {
			expr.interior[indent]
			expr.operand.surround[newLine]
		} else {
			expr.operand.interior[indent]
			expr.operand.surround[noSpace]
		}
	}

	def dispatch void format(GipsRelationalExpression expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_RELATIONAL_EXPRESSION__OPERATOR, document)
		expr.formatChilds(document)
	}

//	def dispatch void format(GipsArithmeticExpression gipsArithmeticExpression, extension IFormattableDocument document) {}
//
	def dispatch void format(GipsArithmeticSum expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_ARITHMETIC_SUM__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticProduct expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_ARITHMETIC_PRODUCT__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticExponential expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_ARITHMETIC_EXPONENTIAL__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticUnary expr, extension IFormattableDocument document) {
		expr.regionFor.feature(GIPS_ARITHMETIC_UNARY__OPERATOR).append[noSpace; noAutowrap]
		expr.operand.format.surround[noSpace]
	}

	def dispatch void format(GipsArithmeticBracket expr, extension IFormattableDocument document) {
		expr.operand.format

		val isMultiLine = expr.operand.previousHiddenRegion.isMultiline
		if(isMultiLine) {
			expr.interior[indent]
			expr.operand.surround[newLine]
		} else {
			expr.operand.interior[indent]
			expr.operand.surround[noSpace]
		}
	}

	def dispatch void format(GipsArithmeticOperand gipsArithmeticOperand, extension IFormattableDocument document) {
		// deals with all subclasses of GipsArithmeticOperand
		gipsArithmeticOperand.regionFor.keyword(".").surround[noSpace]
		gipsArithmeticOperand.formatChilds(document)
	}

//	def dispatch void format(GipsValueExpression gipsValueExpression, extension IFormattableDocument document) {}
//
	def dispatch void format(GipsMappingExpression expr, extension IFormattableDocument document) {
		expr.regionFor.keyword(gipsMappingExpressionAccess.fullStopKeyword_2).surround[noSpace]
		expr.formatChilds(document)
	}

	def dispatch void format(GipsTypeExpression expr, extension IFormattableDocument document) {
		expr.regionFor.keyword(gipsTypeExpressionAccess.fullStopKeyword_2).surround[noSpace]
		expr.formatChilds(document)
	}

	def dispatch void format(GipsPatternExpression expr, extension IFormattableDocument document) {
		expr.regionFor.keyword(gipsPatternExpressionAccess.fullStopKeyword_2).surround[noSpace]
		expr.formatChilds(document)
	}

	def dispatch void format(GipsRuleExpression expr, extension IFormattableDocument document) {
		expr.regionFor.keyword(gipsRuleExpressionAccess.fullStopKeyword_2).surround[noSpace]
		expr.formatChilds(document)
	}

	def dispatch void format(GipsLocalContextExpression expr, extension IFormattableDocument document) {
		expr.expression.format.prepend[noSpace]
	}

	def dispatch void format(GipsSetElementExpression expr, extension IFormattableDocument document) {
		expr.expression.format.prepend[noSpace]
	}

	def dispatch void format(GipsVariableReferenceExpression expr, extension IFormattableDocument document) {
		// remove all spaces between keywords
		expr.regionFor.keyword(gipsVariableReferenceExpressionAccess.fullStopKeyword_0).append[noSpace]
		expr.regionFor.keyword(gipsVariableReferenceExpressionAccess.fullStopKeyword_1_1_1).surround[noSpace]
		expr.variable.format
	}

	def dispatch void format(GipsNodeExpression expr, extension IFormattableDocument document) {
		// remove all spaces between keywords
		expr.regionFor.keyword(gipsNodeExpressionAccess.fullStopKeyword_1).append[noSpace]
		expr.regionFor.keyword(gipsNodeExpressionAccess.nodesKeyword_2).append[noSpace]
		expr.regionFor.keyword(gipsNodeExpressionAccess.fullStopKeyword_3).append[noSpace]
		expr.attributeExpression.format
	}

	def dispatch void format(GipsAttributeExpression expr, extension IFormattableDocument document) {
		expr.attribute.format.prepend[noSpace]
		expr.right.format.prepend[noSpace] // attribute chaining, remove space before next '.'
	}

	def dispatch void format(GipsSetExpression expr, extension IFormattableDocument document) {
		val arrowOperator = expr.regionFor.keyword(gipsSetExpressionAccess.hyphenMinusGreaterThanSignKeyword_1)
		if(arrowOperator.nextHiddenRegion.isMultiline) {
			arrowOperator.append[newLine]
			document.set(arrowOperator.nextHiddenRegion, expr.nextHiddenRegion, [indent]);
		} else {
			arrowOperator.append[noSpace]
		}

		expr.operation.format
		expr.right.format.prepend[noSpace] // arrow chaining, remove space before '->'
	}

//	 def dispatch void format(GipsSetOperation gipsSetOperation, extension IFormattableDocument document){}
//	
	def dispatch void format(GipsFilterOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsFilterOperationAccess.filterKeyword_0, operation.expression)
	}

//	 def dispatch void format(GipsSelectOperation gipsSelectOperation, extension IFormattableDocument document){}
//	
	def dispatch void format(GipsTypeSelect operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsTypeSelectAccess.selectTypeKeyword_0, operation.type)
	}

//	 def dispatch void format(GipsAlgorithmOperation gipsAlgorithmOperation, extension IFormattableDocument document){}
//	
	def dispatch void format(GipsSortOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsSortOperationAccess.sortKeyword_0, operation.predicate)
	}

	def dispatch void format(GipsSortPredicate predicate, extension IFormattableDocument document) {
		predicate.e1.format.prepend[noSpace]
		predicate.regionFor.feature(GIPS_SORT_PREDICATE__RELATION).surround[oneSpace]
		predicate.e2.format.prepend[noSpace]
	}

	def dispatch void format(GipsSimpleAlgorithm operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, GIPS_SIMPLE_ALGORITHM__OPERATOR)
	}

	def dispatch void format(GipsConcatenationOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, GIPS_CONCATENATION_OPERATION__OPERATOR, operation.value)
	}

	def dispatch void format(GipsTransformOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsTransformOperationAccess.transformKeyword_0, operation.expression)
	}

//	def dispatch void format(GipsReduceOperation gipsReduceOperation, extension IFormattableDocument document) {}
//
	def dispatch void format(GipsSumOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsSumOperationAccess.sumKeyword_0, operation.expression)
	}

	def dispatch void format(GipsSimpleSelect operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, GIPS_SIMPLE_SELECT__OPERATOR)
	}

//	def dispatch void format(GipsQueryOperation gipsQueryOperation, extension IFormattableDocument document) {}
//
	def dispatch void format(GipsTypeQuery operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsTypeQueryAccess.containsTypeKeyword_0, operation.type)
	}

	def dispatch void format(GipsElementQuery operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsElementQueryAccess.containsElementKeyword_0, operation.element)
	}

	def dispatch void format(GipsSimpleQuery operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, GIPS_SIMPLE_QUERY__OPERATOR)
	}

	// Helper
	protected def EObject formatMethodCall(EObject owner, extension IFormattableDocument document,
		EStructuralFeature methodName, EObject... parameters) {
		val mId = owner.regionFor.feature(methodName)
		return owner.formatMethodCall(document, mId, parameters);
	}

	protected def EObject formatMethodCall(EObject owner, extension IFormattableDocument document, Keyword methodName,
		EObject... parameters) {
		val mId = owner.regionFor.keyword(methodName)
		return owner.formatMethodCall(document, mId, parameters);
	}

	protected def EObject formatMethodCall(EObject owner, extension IFormattableDocument document,
		ISemanticRegion methodName, EObject... parameters) {
		methodName.append[noSpace]

		val open = owner.regionFor.keyword("(")
		val close = owner.regionFor.keyword(")")

		if(open === null || close === null)
			return owner;

		if(parameters === null || parameters.length === 0) {
			open.append[noSpace]
			return owner
		}

		if(open.nextHiddenRegion.multiline) {
			open.append[newLine]
			for (parameter : parameters)
				parameter.format.immediatelyFollowing.keyword(",").prepend[noSpace].append[newLine]
			parameters.lastOrNull.append[newLine]
			interior(open, close, [indent])
			return owner
		}

		open.append[noSpace]
		for (parameter : parameters)
			parameter.format.immediatelyFollowing.keyword(",").prepend[noSpace].append[oneSpace]
		parameters.lastOrNull.append[noSpace]
		return owner
	}

	protected def ISemanticRegion formatOperatorOrRelation(EObject owner, EStructuralFeature opFeature,
		extension IFormattableDocument document) {
		val operatorRegion = owner.regionFor.feature(opFeature);

		if(!operatorRegion.previousHiddenRegion.isMultiline)
			operatorRegion.prepend[oneSpace]
		else
			operatorRegion.prepend[newLine]

		if(!operatorRegion.nextHiddenRegion.isMultiline)
			operatorRegion.append[oneSpace]
		else
			operatorRegion.append[newLine]

		return operatorRegion
	}

	protected static def EObject groupElementWithPrevElement(EObject element, extension IFormattableDocument document,
		int newLinesOnMatch, int newLinesOnMiss, Class<?>... groupies) {
		if(groupies === null || groupies.length === 0)
			return element

		if(element.previousSibling.instanceOf(groupies))
			element.prepend[newLines = newLinesOnMatch]
		else
			element.prepend[newLines = newLinesOnMiss]

		return element
	}

	/**
	 * Stolen from {@link GTFormatter#formatList}
	 * 
	 * @param newLinesBeforeFirst lines before the first item, does nothing for values smaller 0
	 * @param newLinesBetweenItems lines inbetween items, does nothing for values smaller 0
	 * @param newLinesAfterLastItem lines afther the last item, does nothing for values smaller 0
	 */
	protected static def void formatList(List<? extends EObject> items, extension IFormattableDocument document,
		int newLinesBeforeFirst, int newLinesBetweenItems, int newLinesAfterLastItem) {

		if(items.size() == 0)
			return;

		if(newLinesBeforeFirst >= 0)
			items.get(0).prepend[newLines = newLinesBeforeFirst]

		for (var index = 0; index < items.size(); index++)
			items.get(index).format

		if(newLinesBetweenItems >= 0)
			for (var index = 0; index < items.size() - 1; index++)
				items.get(index).append[newLines = newLinesBetweenItems]

		if(newLinesAfterLastItem >= 0)
			items.get(items.size() - 1).append[newLines = newLinesAfterLastItem]
	}

	protected static def formatChilds(EObject parent, extension IFormattableDocument document) {
		parent.eContents.forEach[it.format]
	}

	protected static def EObject getPreviousSibling(EObject element) {
		if(element === null)
			return null;

		val elementTextNode = NodeModelUtils.findActualNodeFor(element)
		val previousTextNode = elementTextNode.previousSibling
		if(previousTextNode === null)
			return null;

		return NodeModelUtils.findActualSemanticObjectFor(previousTextNode)
	}

	protected static def EObject getNextSibling(EObject element) {
		if(element === null)
			return null;

		val elementTextNode = NodeModelUtils.findActualNodeFor(element)
		val previousTextNode = elementTextNode.nextSibling
		if(previousTextNode === null)
			return null;

		return NodeModelUtils.findActualSemanticObjectFor(previousTextNode)
	}

	protected static def boolean instanceOf(EObject element, Class<?>... types) {
		if(element === null)
			return false

		if(types === null || types.length === 0)
			return true

		for (Class<?> type : types) {
			if(type.isInstance(element))
				return true;
		}

		return false
	}

	protected def int getMaxLineWidth() {
		this.request.preferences.getPreference(FormatterPreferenceKeys.maxLineWidth);
	}

	protected def int getLength(ITextSegment first, ITextSegment last) {
		return last.endOffset - first.offset;
	}

	@Deprecated
	protected def <T1 extends ISemanticRegion, T2 extends ISemanticRegion> Iterable<ISemanticRegion> regionsBetweenPair(
		Pair<T1, T2> pair) {
		if(pair === null)
			return Collections.emptyList

		val regions = new LinkedList<ISemanticRegion>
		var currentRegion = pair.key.nextSemanticRegion
		while(currentRegion !== null && currentRegion.endOffset < pair.value.offset) {
			regions.add(currentRegion)
			currentRegion = currentRegion.nextSemanticRegion
		}
		return regions
	}

	protected def <T1 extends ISemanticRegion, T2 extends ISemanticRegion> ISemanticRegionsFinder regionFor(
		Pair<T1, T2> pair) {
		if(pair === null)
			return SemanticRegionNullFinder.INSTANCE
		val regions = new SemanticRegionIterable(pair.key, pair.value)
		return new SemanticRegionInIterableFinder(regions)
	}

	@Deprecated
	protected def Iterable<ISemanticRegion> keyword(Iterable<ISemanticRegion> regions, String keyword) {
		val results = new LinkedList<ISemanticRegion>
		for (region : regions) {
			val grammarElement = region.grammarElement
			if(grammarElement instanceof Keyword)
				if(keyword.equals(grammarElement.value))
					results.add(region)
		}
		return results
	}

	// GTFormater fixes
	override dispatch void format(org.emoflon.ibex.gt.editor.gT.EditorAttributeAssignment attribute,
		extension IFormattableDocument document) {
		// No space before and after ".".
		attribute.regionFor.keyword(".").surround[noSpace]

		// One space before and after the assignment.
		// Fixed: correct keyword selection
		attribute.regionFor.keyword(editorAttributeAssignmentAccess.colonEqualsSignKeyword_2).surround[oneSpace]
	}

	// Keep at most one line between comments intact
	override ITextReplacer createCommentReplacer(IComment comment) {
		val EObject grammarElement = comment.getGrammarElement()

		if(grammarElement instanceof AbstractRule) {
			val String ruleName = (grammarElement as AbstractRule).getName()
			if(ruleName.startsWith("ML"))
				return createMultiLineCommentReplacer(comment)
			if(ruleName.startsWith("SL")) {
				return createSingleLineCommentReplacer(comment)
			}
		}

		val String elementName = new GrammarElementTitleSwitch().showQualified().showRule().doSwitch(grammarElement);
		throw new IllegalStateException("No " + typeof(ITextReplacer).getSimpleName() + " configured for " +
			elementName);
	}

	def ITextReplacer createSingleLineCommentReplacer(IComment comment) {
		return new GipslSinglelineCodeCommentReplacer(comment, "//")
	}

	def ITextReplacer createMultiLineCommentReplacer(IComment comment) {
		return new GipslMultilineCommentReplacer(comment, '*')
	}

	override ITextReplacer createWhitespaceReplacer(ITextSegment hiddens, IHiddenRegionFormatting formatting) {
		return new GipslWhitespaceReplacer(hiddens, formatting);
	}

}
