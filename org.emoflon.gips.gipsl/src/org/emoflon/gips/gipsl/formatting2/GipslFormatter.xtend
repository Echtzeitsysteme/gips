/*
 * generated by Xtext 2.37.0
 */
package org.emoflon.gips.gipsl.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.emoflon.gips.gipsl.gipsl.EditorGTFile
import org.emoflon.gips.gipsl.gipsl.GipsMapping
import org.emoflon.gips.gipsl.services.GipslGrammarAccess
import org.emoflon.ibex.gt.editor.formatting2.GTFormatter
import org.emoflon.gips.gipsl.gipsl.GipsConstant
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.emoflon.gips.gipsl.gipsl.ImportedPattern
import org.eclipse.xtend.lib.annotations.Accessors
import org.emoflon.ibex.gt.editor.gT.EditorCondition
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction
import org.emoflon.gips.gipsl.gipsl.GipsObjective
import org.emoflon.gips.gipsl.gipsl.GipsConstraint
import org.emoflon.gips.gipsl.gipsl.GipsConfig
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable
import org.emoflon.gips.gipsl.gipsl.GipsBooleanImplication
import org.emoflon.gips.gipsl.gipsl.GipslPackage
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticSum
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticProduct
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticExponential
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticUnary
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticBracket
import org.emoflon.gips.gipsl.gipsl.GipsConstantReference
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticOperand
import org.emoflon.gips.gipsl.gipsl.GipsBooleanDisjunction
import org.emoflon.gips.gipsl.gipsl.GipsBooleanConjunction
import org.emoflon.gips.gipsl.gipsl.GipsBooleanNegation
import org.emoflon.gips.gipsl.gipsl.GipsBooleanBracket
import org.emoflon.gips.gipsl.gipsl.GipsRelationalExpression
import org.emoflon.gips.gipsl.gipsl.GipsLocalContextExpression
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression
import org.emoflon.gips.gipsl.gipsl.GipsSetElementExpression
import org.emoflon.gips.gipsl.gipsl.GipsNodeExpression
import org.emoflon.gips.gipsl.gipsl.GipsVariableReferenceExpression
import org.emoflon.gips.gipsl.gipsl.GipsAttributeExpression
import org.emoflon.gips.gipsl.gipsl.GipsSetExpression
import org.emoflon.gips.gipsl.gipsl.GipsFilterOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeSelect
import org.emoflon.gips.gipsl.gipsl.GipsSortOperation
import org.emoflon.gips.gipsl.gipsl.GipsSortPredicate
import org.emoflon.gips.gipsl.gipsl.GipsSimpleAlgorithm
import org.emoflon.gips.gipsl.gipsl.GipsConcatenationOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression
import org.emoflon.gips.gipsl.gipsl.GipsTransformOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeQuery
import org.emoflon.gips.gipsl.gipsl.GipsElementQuery
import org.emoflon.gips.gipsl.gipsl.GipsSimpleQuery
import org.emoflon.gips.gipsl.gipsl.GipsSimpleSelect
import org.emoflon.gips.gipsl.gipsl.GipsSumOperation
import org.eclipse.xtext.formatting2.FormatterPreferenceValuesProvider
import org.eclipse.xtext.preferences.IPreferenceValuesProvider
import org.eclipse.xtext.formatting2.FormatterPreferences
import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess
import org.eclipse.xtext.formatting2.regionaccess.IEObjectRegion

import static org.emoflon.gips.gipsl.gipsl.GipslPackage.Literals.*
import org.eclipse.xtext.Keyword
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.eclipse.xtext.formatting2.regionaccess.IAstRegion
import org.emoflon.ibex.gt.editor.gT.EditorPattern
import org.emoflon.ibex.gt.editor.gT.GTPackage
import org.eclipse.xtext.formatting2.FormatterPreferenceKeys
import org.emoflon.ibex.gt.editor.gT.EditorNode
import org.emoflon.ibex.gt.editor.gT.EditorAttributeAssignment
import org.eclipse.ui.internal.EditorReference
import org.eclipse.xtext.formatting2.regionaccess.ITextSegment
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter

class GipslFormatter extends GTFormatter {

	@Inject extension GipslGrammarAccess
	
	def dispatch void format(EditorGTFile editorGTFile, extension IFormattableDocument document) {
		editorGTFile.prepend[setNewLines(0,0,1); noSpace]
		
		// _format(editorGTFile as org.emoflon.ibex.gt.editor.gT.EditorGTFile, document);
		// because EditorGTFile extends EditorGTFile, we need to call explicitly the method on EditorGTFile 
		// (if we want the gt formatting on the whole file)
		editorGTFile.package.format

		formatList(editorGTFile.imports, document, 1, 1, -1)

		formatList(editorGTFile.importedPattern, document, 2, 1, -1)

		editorGTFile.config.prepend[newLines = 2]
		editorGTFile.config.format

		// At this point, everything can be declared in any order. 
		// Each element needs to be checked on a case-by-case basis.
		// To make this work, each element can only modify the hidden region 'in front' of itself; 
		// otherwise, a ConflictingRegionsException might be triggered.
		for (editorPattern : editorGTFile.patterns) {
			editorPattern.format
			editorPattern.groupElementWithPrevElement(document, 1, 2, EditorCondition)
		}

		for (editorCondition : editorGTFile.conditions) {
			editorCondition.format
			editorCondition.groupElementWithPrevElement(document, 1, 2, EditorCondition)
		}

		for (gipsMapping : editorGTFile.mappings) {
			gipsMapping.format
			gipsMapping.groupElementWithPrevElement(document, 1, 2, GipsMapping)
		}

		for (gipsConstraint : editorGTFile.constraints) {
			gipsConstraint.format
			gipsConstraint.groupElementWithPrevElement(document, 1, 2, GipsMapping)
		}

		for (gipsConstant : editorGTFile.constants) {
			gipsConstant.format
		}

		for (gipsLinearFunction : editorGTFile.functions) {
			gipsLinearFunction.format
			gipsLinearFunction.groupElementWithPrevElement(document, 1, 2, GipsLinearFunction, GipsObjective)
		}

		editorGTFile.objective.format
		editorGTFile.objective.groupElementWithPrevElement(document, 1, 2, GipsLinearFunction)
	}
			
	def dispatch void format(org.emoflon.gips.gipsl.gipsl.Package gipsPackage, extension IFormattableDocument document) {
		gipsPackage.regionFor.keyword(packageAccess.packageKeyword_0).append[oneSpace]
	}

	def dispatch void format(ImportedPattern importedPattern, extension IFormattableDocument document) {
		importedPattern.regionFor.keyword(importedPatternAccess.fromKeyword_0).append[oneSpace]
		importedPattern.regionFor.keyword(importedPatternAccess.importKeyword_2).prepend[oneSpace].append[oneSpace]
	}

	def dispatch void format(GipsConfig gipsConfig, extension IFormattableDocument document) {
		gipsConfig.regionFor.keyword(gipsConfigAccess.configKeyword_1).append[oneSpace]
		gipsConfig.regionFor.keyword(gipsConfigAccess.leftCurlyBracketKeyword_2).append[noSpace; newLine]

		val body = gipsConfig.regionFor.keywordPairs(gipsConfigAccess.leftCurlyBracketKeyword_2,
			gipsConfigAccess.rightCurlyBracketKeyword_16)
		if (body.size > 0)
			body.get(0).interior[indent]

		gipsConfig.regionFor.keywords(":=").forEach [
			it.surround[oneSpace]
		]

		gipsConfig.regionFor.keywords("[").forEach [
			it.prepend[oneSpace].append[noSpace]
		]

		gipsConfig.regionFor.keywords(",").forEach [
			it.prepend[noSpace].append[oneSpace]
		]

		gipsConfig.regionFor.keywords("]").forEach [
			it.prepend[noSpace]
		]

		gipsConfig.regionFor.keywords(";").forEach [
			it.prepend[noSpace].append[newLine]
		]
		
		gipsConfig.regionFor.keyword(gipsConfigAccess.rightCurlyBracketKeyword_16).prepend[newLine]
	}

	def dispatch void format(GipsMapping gipsMapping, extension IFormattableDocument document) {
		gipsMapping.regionFor.keyword(gipsMappingAccess.mappingKeyword_0).append[oneSpace]
		gipsMapping.regionFor.keyword(gipsMappingAccess.toKeyword_2).surround[oneSpace]		

		val moreThanOneVariable = gipsMapping.variables.length > 1
		if(moreThanOneVariable){
			gipsMapping.regionFor.keyword(gipsMappingAccess.leftCurlyBracketKeyword_4_0).prepend[oneSpace]
				
			val body = gipsMapping.regionFor.keywordPairs(gipsMappingAccess.leftCurlyBracketKeyword_4_0, gipsMappingAccess.rightCurlyBracketKeyword_4_2)
			if (body.length > 0)
				body.get(0).interior[indent]
				
			for (gipsMappingVariable : gipsMapping.variables)
				gipsMappingVariable.format.surround[newLine]

			gipsMapping.regionFor.keyword(gipsMappingAccess.rightCurlyBracketKeyword_4_2).prepend[noSpace]
		}else{
			gipsMapping.regionFor.keyword(gipsMappingAccess.leftCurlyBracketKeyword_4_0).surround[oneSpace]
			for (gipsMappingVariable : gipsMapping.variables)
					gipsMappingVariable.format.append[oneSpace]
		}
		
		gipsMapping.regionFor.keyword(gipsMappingAccess.semicolonKeyword_5).prepend[noSpace]
	}

	def dispatch void format(GipsMappingVariable gipsMappingVariable, extension IFormattableDocument document) {
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.varKeyword_0).append[oneSpace]
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.colonKeyword_2).surround[oneSpace]
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.boundBindKeyword_4_0_0).surround[oneSpace]
		gipsMappingVariable.formatChilds(document)
	}

	def dispatch void format(GipsConstant gipsConstant, extension IFormattableDocument document) {
		gipsConstant.regionFor.keyword(gipsConstantAccess.letKeyword_0).append[oneSpace]
		gipsConstant.regionFor.keyword(gipsConstantAccess.colonEqualsSignKeyword_2).surround[oneSpace]
		gipsConstant.regionFor.keyword(gipsConstantAccess.semicolonKeyword_4).prepend[noSpace]
		gipsConstant.formatChilds(document)
	}

	def dispatch void format(GipsConstantReference gipsConstantReference, extension IFormattableDocument document) {
		gipsConstantReference.regionFor.keyword(gipsConstantReferenceAccess.fullStopKeyword_1).surround[noSpace]
		gipsConstantReference.formatChilds(document)
	}

	def dispatch void format(GipsConstraint gipsConstraint, extension IFormattableDocument document) {
		gipsConstraint.regionFor.keyword(gipsConstraintAccess.isLocalWithKeyword_1_0_0).surround[oneSpace]
		gipsConstraint.regionFor.keyword(gipsConstraintAccess.leftCurlyBracketKeyword_2).prepend[oneSpace]

		val body = gipsConstraint.regionFor.keywordPairs(gipsConstraintAccess.leftCurlyBracketKeyword_2,
			gipsConstraintAccess.rightCurlyBracketKeyword_5)
		if (body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsConstraint.constants)
			gipsConstant.format.surround[newLine]

		gipsConstraint.expression.format.surround[newLine]
	}

	def dispatch void format(GipsLinearFunction gipsLinearFunction, extension IFormattableDocument document) {
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.functionKeyword_0).append[oneSpace]
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.withKeyword_2).surround[oneSpace]
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.leftCurlyBracketKeyword_4).prepend[oneSpace]

		val body = gipsLinearFunction.regionFor.keywordPairs(gipsLinearFunctionAccess.leftCurlyBracketKeyword_4,
			gipsLinearFunctionAccess.rightCurlyBracketKeyword_7)
		if (body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsLinearFunction.constants)
			gipsConstant.format.surround[newLine]

		gipsLinearFunction.expression.format.surround[newLine]
	}

	//	handled by GipsArithmeticOperand
//		def dispatch void format(GipsLinearFunctionReference gipsLinearFunctionReference, extension IFormattableDocument document) {}
	
	def dispatch void format(GipsObjective gipsObjective, extension IFormattableDocument document) {
		gipsObjective.regionFor.keyword(gipsObjectiveAccess.colonKeyword_1).surround[oneSpace]
		gipsObjective.regionFor.keyword(gipsObjectiveAccess.leftCurlyBracketKeyword_3).prepend[oneSpace]

		val body = gipsObjective.regionFor.keywordPairs(gipsObjectiveAccess.leftCurlyBracketKeyword_3,
			gipsObjectiveAccess.rightCurlyBracketKeyword_6)
		if (body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsObjective.constants)
			gipsConstant.format.surround[newLine]

		gipsObjective.expression.format.surround[newLine]
	}

	//	def dispatch void format(GipsBooleanExpression gipsBooleanExpression, extension IFormattableDocument document) {}

	def dispatch void format(GipsBooleanImplication expr, extension IFormattableDocument document) {				
		expr.formatOperatorOrRelation(GIPS_BOOLEAN_IMPLICATION__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsBooleanDisjunction expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_BOOLEAN_DISJUNCTION__OPERATOR, document)	
		expr.formatChilds(document)
	}

	def dispatch void format(GipsBooleanConjunction expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_BOOLEAN_CONJUNCTION__OPERATOR, document)	
		expr.formatChilds(document)
	}

	def dispatch void format(GipsBooleanNegation expr, extension IFormattableDocument document) {
		// no space between '!' and operand
		expr.operand.format.prepend[noSpace; noAutowrap]
	}

	def dispatch void format(GipsBooleanBracket expr, extension IFormattableDocument document) {
		// no space between operand and brackets
		expr.operand.format.surround[noSpace]
	}

	def dispatch void format(GipsRelationalExpression expr, extension IFormattableDocument document) {				
		expr.formatOperatorOrRelation(GIPS_RELATIONAL_EXPRESSION__OPERATOR, document)
		expr.formatChilds(document)	
	}

//	def dispatch void format(GipsArithmeticExpression gipsArithmeticExpression, extension IFormattableDocument document) {}

	def dispatch void format(GipsArithmeticSum expr, extension IFormattableDocument document) {			
		expr.formatOperatorOrRelation(GIPS_ARITHMETIC_SUM__OPERATOR, document)
		expr.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticProduct expr, extension IFormattableDocument document) {
		expr.formatOperatorOrRelation(GIPS_ARITHMETIC_PRODUCT__OPERATOR, document)		
		expr.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticExponential expr, extension IFormattableDocument document) {
//		gipsArithmeticExponential.append[autowrap]
		expr.formatOperatorOrRelation(GIPS_ARITHMETIC_EXPONENTIAL__OPERATOR, document)		
		expr.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticUnary expr, extension IFormattableDocument document) {
//		gipsArithmeticUnary.append[autowrap]
		expr.regionFor.feature(GIPS_ARITHMETIC_UNARY__OPERATOR).append[noSpace; noAutowrap]
		expr.operand.format.surround[noSpace]
	}

	def dispatch void format(GipsArithmeticBracket expr, extension IFormattableDocument document) {
		expr.operand.format
		
		val isMultiLine = expr.operand.previousHiddenRegion.isMultiline		
		if(isMultiLine){
			expr.interior[indent]
			expr.operand.surround[newLine]			
		}else{
			expr.operand.interior[indent]
			expr.operand.surround[noSpace]
		}
		
	}

	def dispatch void format(GipsArithmeticOperand gipsArithmeticOperand, extension IFormattableDocument document) {
		// deals with all subclasses of GipsArithmeticOperand
//		gipsArithmeticOperand.append[autowrap]
		gipsArithmeticOperand.regionFor.keyword(".").surround[noSpace]
		gipsArithmeticOperand.formatChilds(document)
	}

//	def dispatch void format(GipsValueExpression gipsValueExpression, extension IFormattableDocument document) {}

	def dispatch void format(GipsMappingExpression gipsMappingExpression, extension IFormattableDocument document) {
		gipsMappingExpression.regionFor.keyword(gipsMappingExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsMappingExpression.formatChilds(document)
	}

	def dispatch void format(GipsTypeExpression gipsTypeExpression, extension IFormattableDocument document) {
		gipsTypeExpression.regionFor.keyword(gipsTypeExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsTypeExpression.formatChilds(document)
	}

	def dispatch void format(GipsPatternExpression gipsPatternExpression, extension IFormattableDocument document) {
		gipsPatternExpression.regionFor.keyword(gipsPatternExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsPatternExpression.formatChilds(document)
	}

	def dispatch void format(GipsRuleExpression gipsRuleExpression, extension IFormattableDocument document) {
		gipsRuleExpression.regionFor.keyword(gipsRuleExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsRuleExpression.formatChilds(document)
	}

	def dispatch void format(GipsLocalContextExpression gipsLocalContextExpression, extension IFormattableDocument document) {
		gipsLocalContextExpression.regionFor.keyword(gipsLocalContextExpressionAccess.contextKeyword_1).append[noSpace]
		gipsLocalContextExpression.expression.format
	}

	def dispatch void format(GipsSetElementExpression gipsSetElementExpression, extension IFormattableDocument document) {
		gipsSetElementExpression.regionFor.keyword(gipsSetElementExpressionAccess.elementKeyword_1).append[noSpace]
		gipsSetElementExpression.expression.format
	}

	def dispatch void format(GipsVariableReferenceExpression gipsVariableReferenceExpression, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsVariableReferenceExpression.regionFor.keyword(gipsVariableReferenceExpressionAccess.fullStopKeyword_0).append[noSpace]
		gipsVariableReferenceExpression.regionFor.keyword(gipsVariableReferenceExpressionAccess.fullStopKeyword_1_1_1).surround[noSpace]
		gipsVariableReferenceExpression.variable.format
	}

	def dispatch void format(GipsNodeExpression gipsNodeExpression, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsNodeExpression.regionFor.keyword(gipsNodeExpressionAccess.fullStopKeyword_1).append[noSpace]
		gipsNodeExpression.regionFor.keyword(gipsNodeExpressionAccess.nodesKeyword_2).append[noSpace]
		gipsNodeExpression.regionFor.keyword(gipsNodeExpressionAccess.fullStopKeyword_3).append[noSpace]
		gipsNodeExpression.attributeExpression.format
	}

	def dispatch void format(GipsAttributeExpression gipsAttributeExpression, extension IFormattableDocument document) {
		gipsAttributeExpression.regionFor.keyword(gipsAttributeExpressionAccess.fullStopKeyword_1).append[noSpace]
		gipsAttributeExpression.attribute.format
		gipsAttributeExpression.right.format.prepend[noSpace] // attribute chaining, remove space before '.'
	}

	def dispatch void format(GipsSetExpression expr, extension IFormattableDocument document) {
		val arrowOperator = expr.regionFor.keyword(gipsSetExpressionAccess.hyphenMinusGreaterThanSignKeyword_1)
		if(arrowOperator.nextHiddenRegion.isMultiline){
			arrowOperator.append[newLine]
			document.set(arrowOperator.nextHiddenRegion, expr.nextHiddenRegion, [indent]);
		}else{
			arrowOperator.append[noSpace]
		}
		
		expr.operation.format
		expr.right.format.prepend[noSpace] // arrow chaining, remove space before '->'
	}
	
	// def dispatch void format(GipsSetOperation gipsSetOperation, extension IFormattableDocument document){}
	
	def dispatch void format(GipsFilterOperation operation, extension IFormattableDocument document) {
//		operation.regionFor.keyword(gipsFilterOperationAccess.filterKeyword_0).append[noSpace]
//		operation.expression.format.surround[noSpace]		
		operation.formatMethodCall(document, gipsFilterOperationAccess.filterKeyword_0, operation.expression)
	}

	// def dispatch void format(GipsSelectOperation gipsSelectOperation, extension IFormattableDocument document){}
	
	def dispatch void format(GipsTypeSelect operation, extension IFormattableDocument document) {
//		operation.regionFor.keyword(gipsTypeSelectAccess.selectTypeKeyword_0).append[noSpace]
//		operation.type.format.surround[noSpace]
		operation.formatMethodCall(document, gipsTypeSelectAccess.selectTypeKeyword_0, operation.type)
	}

	// def dispatch void format(GipsAlgorithmOperation gipsAlgorithmOperation, extension IFormattableDocument document){}
	
	def dispatch void format(GipsSortOperation operation, extension IFormattableDocument document) {
//		operation.regionFor.keyword(gipsSortOperationAccess.sortKeyword_0).append[noSpace]
//		operation.predicate.format.surround[noSpace]
		operation.formatMethodCall(document, gipsSortOperationAccess.sortKeyword_0, operation.predicate)
	}

	def dispatch void format(GipsSortPredicate gipsSortpredicate, extension IFormattableDocument document) {
		gipsSortpredicate.e1.format.prepend[noSpace]
		gipsSortpredicate.regionFor.feature(GIPS_SORT_PREDICATE__RELATION).surround[oneSpace]
		gipsSortpredicate.e2.format.prepend[noSpace]
	}

	def dispatch void format(GipsSimpleAlgorithm operation, extension IFormattableDocument document) {
//		operation.regionFor.feature(GIPS_SIMPLE_ALGORITHM__OPERATOR).append[noSpace]
		operation.formatMethodCall(document, GIPS_SIMPLE_ALGORITHM__OPERATOR)
	}

	def dispatch void format(GipsConcatenationOperation operation, extension IFormattableDocument document) {
//		operation.regionFor.feature(GIPS_CONCATENATION_OPERATION__OPERATOR).append[noSpace]	
//		operation.value.format.surround[noSpace]		
		operation.formatMethodCall(document, GIPS_CONCATENATION_OPERATION__OPERATOR, operation.value)
	}
	
	def dispatch void format(GipsTransformOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsTransformOperationAccess.transformKeyword_0, operation.expression)
	}
	
//	def dispatch void format(GipsReduceOperation gipsReduceOperation, extension IFormattableDocument document) {}

	def dispatch void format(GipsSumOperation operation, extension IFormattableDocument document) {
		operation.formatMethodCall(document, gipsSumOperationAccess.sumKeyword_0, operation.expression)
	}
	
	def dispatch void format(GipsSimpleSelect operation, extension IFormattableDocument document) {
//		operation.regionFor.feature(GIPS_SIMPLE_SELECT__OPERATOR).append[noSpace]	
		operation.formatMethodCall(document, GIPS_SIMPLE_SELECT__OPERATOR)
	}

//	def dispatch void format(GipsQueryOperation gipsQueryOperation, extension IFormattableDocument document) {}
	
	def dispatch void format(GipsTypeQuery operation, extension IFormattableDocument document) {
//		operation.regionFor.keyword(gipsTypeQueryAccess.containsTypeKeyword_0).append[noSpace]
//		operation.type.format.surround[noSpace]
		operation.formatMethodCall(document, gipsTypeQueryAccess.containsTypeKeyword_0, operation.type)
	}
	
	def dispatch void format(GipsElementQuery operation, extension IFormattableDocument document) {
//		operation.regionFor.keyword(gipsElementQueryAccess.containsElementKeyword_0).append[noSpace]
//		operation.element.format.surround[noSpace]
		operation.formatMethodCall(document, gipsElementQueryAccess.containsElementKeyword_0, operation.element)
	}
	
	def dispatch void format(GipsSimpleQuery operation, extension IFormattableDocument document) {
//		operation.operator.format
//		operation.regionFor.keyword(gipsSimpleQueryAccess.leftParenthesisRightParenthesisKeyword_1).prepend[noSpace]	
		operation.formatMethodCall(document, gipsSimpleQueryAccess.leftParenthesisRightParenthesisKeyword_1)	
	}
		
	// Helper
	protected def int getMaxLineWidth(){
		this.request.preferences.getPreference(FormatterPreferenceKeys.maxLineWidth);
	}
	
	protected def int getLength(ITextSegment first, ITextSegment last){
		return last.endOffset - first.offset;
	}
	
	protected def EObject formatMethodCall(EObject owner, extension IFormattableDocument document,  EStructuralFeature methodName, EObject...parameters){
		val mId =  owner.regionFor.feature(methodName)
		return owner.formatMethodCall(document, mId, parameters);
	}
	
	protected def EObject formatMethodCall(EObject owner, extension IFormattableDocument document,  Keyword methodName, EObject...parameters){
		val mId = owner.regionFor.keyword(methodName)
		return owner.formatMethodCall(document, mId, parameters);
	}
	
	protected def EObject formatMethodCall(EObject owner, extension IFormattableDocument document,  ISemanticRegion methodName, EObject...parameters){
		methodName.append[noSpace]
					
		val open = owner.regionFor.keyword("(") 
		val close = owner.regionFor.keyword(")")
		
		if(open === null || close === null)
			return owner;
		
		if(parameters === null || parameters.length === 0){
			open.append[noSpace]
			return owner
		}
		
		if(open.nextHiddenRegion.multiline){
			open.append[newLine]
			for(parameter : parameters)
				parameter.format.immediatelyFollowing.keyword(",").prepend[noSpace].append[newLine]
			parameters.lastOrNull.append[newLine]
			interior(open,close, [indent])
			return owner
		}
		
		open.append[noSpace]
		for(parameter : parameters)
			parameter.format.immediatelyFollowing.keyword(",").prepend[noSpace].append[oneSpace]
		parameters.lastOrNull.append[noSpace]
		return owner
	}
	
	protected def ISemanticRegion formatOperatorOrRelation(EObject owner, EStructuralFeature opFeature, extension IFormattableDocument document){
		val operatorRegion = owner.regionFor.feature(opFeature);
		
		if(!operatorRegion.previousHiddenRegion.isMultiline)
			operatorRegion.prepend[oneSpace]
		else
			operatorRegion.prepend[setNewLines(0,0,1)]	
			
		if(!operatorRegion.nextHiddenRegion.isMultiline)
			operatorRegion.append[oneSpace]
		else
			operatorRegion.append[setNewLines(0,0,1)]
			
		return operatorRegion
	}
	

			
	protected static def EObject groupElementWithPrevElement(EObject element, extension IFormattableDocument document,
		int newLinesOnMatch, int newLinesOnMiss, Class<?>... groupies) {
		if (groupies === null || groupies.length === 0)
			return element

		if (element.previousSibling.instanceOf(groupies))
			element.prepend[newLines = newLinesOnMatch]
		else
			element.prepend[newLines = newLinesOnMiss]

		return element
	}

	protected static def EObject getPreviousSibling(EObject element) {
		if (element === null)
			return null;

		val elementTextNode = NodeModelUtils.findActualNodeFor(element)
		val previousTextNode = elementTextNode.previousSibling
		if (previousTextNode === null)
			return null;

		return NodeModelUtils.findActualSemanticObjectFor(previousTextNode)
	}

	protected static def EObject getNextSibling(EObject element) {
		if (element === null)
			return null;

		val elementTextNode = NodeModelUtils.findActualNodeFor(element)
		val previousTextNode = elementTextNode.nextSibling
		if (previousTextNode === null)
			return null;

		return NodeModelUtils.findActualSemanticObjectFor(previousTextNode)
	}

	protected static def boolean instanceOf(EObject element, Class<?>... types) {
		if (element === null)
			return false

		if (types === null || types.length === 0)
			return true

		for (Class<?> type : types) {
			if (type.isInstance(element))
				return true;
		}

		return false
	}

	/**
	 * Stolen from {@link GTFormatter#formatList}
	 * 
	 * @param newLinesBeforeFirst lines before the first item, does nothing for values smaller 0
	 * @param newLinesBetweenItems lines inbetween items, does nothing for values smaller 0
	 * @param newLinesAfterLastItem lines afther the last item, does nothing for values smaller 0
	 */
	protected static def void formatList(List<? extends EObject> items, extension IFormattableDocument document,
		int newLinesBeforeFirst, int newLinesBetweenItems, int newLinesAfterLastItem) {

		if (items.size() == 0)
			return;

		if (newLinesBeforeFirst >= 0)
			items.get(0).prepend[newLines = newLinesBeforeFirst]

		for (var index = 0; index < items.size(); index++)
			items.get(index).format

		if (newLinesBetweenItems >= 0)
			for (var index = 0; index < items.size() - 1; index++)
				items.get(index).append[newLines = newLinesBetweenItems]

		if (newLinesAfterLastItem >= 0)
			items.get(items.size() - 1).append[newLines = newLinesAfterLastItem]
	}

	protected static def formatChilds(EObject parent, extension IFormattableDocument document) {
		parent.eContents.forEach[it.format]
	}
	
	// GTFormater fixes
		
	override dispatch void format(org.emoflon.ibex.gt.editor.gT.EditorAttributeAssignment attribute, extension IFormattableDocument document) {
		// No space before and after ".".
		attribute.regionFor.keyword(".").surround[noSpace]

		// One space before and after the relation.
		// Fixed: correct feature selection
		attribute.regionFor.feature(GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__RELATION).surround[oneSpace]
	}

}
