/*
 * generated by Xtext 2.37.0
 */
package org.emoflon.gips.gipsl.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.emoflon.gips.gipsl.gipsl.EditorGTFile
import org.emoflon.gips.gipsl.gipsl.GipsMapping
import org.emoflon.gips.gipsl.services.GipslGrammarAccess
import org.emoflon.ibex.gt.editor.formatting2.GTFormatter
import org.emoflon.gips.gipsl.gipsl.GipsConstant
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.emoflon.gips.gipsl.gipsl.ImportedPattern
import org.eclipse.xtend.lib.annotations.Accessors
import org.emoflon.ibex.gt.editor.gT.EditorCondition
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction
import org.emoflon.gips.gipsl.gipsl.GipsObjective
import org.emoflon.gips.gipsl.gipsl.GipsConstraint
import org.emoflon.gips.gipsl.gipsl.GipsConfig
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable
import org.emoflon.gips.gipsl.gipsl.GipsBooleanImplication
import org.emoflon.gips.gipsl.gipsl.GipslPackage
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticSum
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticProduct
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticExponential
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticUnary
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticBracket
import org.emoflon.gips.gipsl.gipsl.GipsConstantReference
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticOperand
import org.emoflon.gips.gipsl.gipsl.GipsBooleanDisjunction
import org.emoflon.gips.gipsl.gipsl.GipsBooleanConjunction
import org.emoflon.gips.gipsl.gipsl.GipsBooleanNegation
import org.emoflon.gips.gipsl.gipsl.GipsBooleanBracket
import org.emoflon.gips.gipsl.gipsl.GipsRelationalExpression
import org.emoflon.gips.gipsl.gipsl.GipsLocalContextExpression
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression
import org.emoflon.gips.gipsl.gipsl.GipsSetElementExpression
import org.emoflon.gips.gipsl.gipsl.GipsNodeExpression
import org.emoflon.gips.gipsl.gipsl.GipsVariableReferenceExpression
import org.emoflon.gips.gipsl.gipsl.GipsAttributeExpression
import org.emoflon.gips.gipsl.gipsl.GipsSetExpression
import org.emoflon.gips.gipsl.gipsl.GipsFilterOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeSelect
import org.emoflon.gips.gipsl.gipsl.GipsSortOperation
import org.emoflon.gips.gipsl.gipsl.GipsSortPredicate
import org.emoflon.gips.gipsl.gipsl.GipsSimpleAlgorithm
import org.emoflon.gips.gipsl.gipsl.GipsConcatenationOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression
import org.emoflon.gips.gipsl.gipsl.GipsTransformOperation
import org.emoflon.gips.gipsl.gipsl.GipsTypeQuery
import org.emoflon.gips.gipsl.gipsl.GipsElementQuery
import org.emoflon.gips.gipsl.gipsl.GipsSimpleQuery
import org.emoflon.gips.gipsl.gipsl.GipsSimpleSelect
import org.emoflon.gips.gipsl.gipsl.GipsSumOperation

class GipslFormatter extends GTFormatter {

	@Inject extension GipslGrammarAccess

	@Accessors
	var int maxLineLength = 80;

	def dispatch void format(EditorGTFile editorGTFile, extension IFormattableDocument document) {
		// _format(editorGTFile as org.emoflon.ibex.gt.editor.gT.EditorGTFile, document);
		// because EditorGTFile extends EditorGTFile, we need to call explicitly the method on EditorGTFile 
		// (if we want the gt formatting on the whole file)
		editorGTFile.package.prepend[noSpace]
		editorGTFile.package.format

		formatList(editorGTFile.imports, document, 1, 1, -1)

		formatList(editorGTFile.importedPattern, document, 2, 1, -1)

		editorGTFile.config.prepend[newLines = 2]
		editorGTFile.config.format

		// At this point, everything can be declared in any order. 
		// Each element needs to be checked on a case-by-case basis.
		// To make this work, each element can only modify the hidden region 'in front' of itself; 
		// otherwise, a ConflictingRegionsException might be triggered.
		for (editorPattern : editorGTFile.patterns) {
			editorPattern.format
			editorPattern.groupElementWithPrevElement(document, 1, 2, EditorCondition)
		}

		for (editorCondition : editorGTFile.conditions) {
			editorCondition.format
			editorCondition.groupElementWithPrevElement(document, 1, 2, EditorCondition)
		}

		for (gipsMapping : editorGTFile.mappings) {
			gipsMapping.format
			gipsMapping.groupElementWithPrevElement(document, 1, 2, GipsMapping)
		}

		for (gipsConstraint : editorGTFile.constraints) {
			gipsConstraint.format
			gipsConstraint.groupElementWithPrevElement(document, 1, 2, GipsMapping)
		}

		for (gipsConstant : editorGTFile.constants) {
			gipsConstant.format
		}

		for (gipsLinearFunction : editorGTFile.functions) {
			gipsLinearFunction.format
			gipsLinearFunction.groupElementWithPrevElement(document, 1, 2, GipsLinearFunction, GipsObjective)
		}

		editorGTFile.objective.format
		editorGTFile.objective.groupElementWithPrevElement(document, 1, 2, GipsLinearFunction)
	}

	def dispatch void format(org.emoflon.gips.gipsl.gipsl.Package element, extension IFormattableDocument document) {
		element.regionFor.keyword(packageAccess.packageKeyword_0).append[oneSpace]
	}

	def dispatch void format(ImportedPattern element, extension IFormattableDocument document) {
		element.regionFor.keyword(importedPatternAccess.fromKeyword_0).append[oneSpace]
		element.regionFor.keyword(importedPatternAccess.importKeyword_2).prepend[oneSpace].append[oneSpace]
	}

	def dispatch void format(GipsConfig element, extension IFormattableDocument document) {
		element.regionFor.keyword(gipsConfigAccess.configKeyword_1).append[oneSpace]

		val body = element.regionFor.keywordPairs(gipsConfigAccess.leftCurlyBracketKeyword_2,
			gipsConfigAccess.rightCurlyBracketKeyword_16)
		if (body.size > 0)
			body.get(0).interior[indent]

		element.regionFor.keywords(":=").forEach [
			it.surround[oneSpace]
		]

		val hasEntries = element.regionFor.keywords(":=").size > 0

		element.regionFor.keywords("[").forEach [
			it.prepend[oneSpace].append[noSpace]
		]

		element.regionFor.keywords(",").forEach [
			it.prepend[noSpace].append[oneSpace]
		]

		element.regionFor.keywords("]").forEach [
			it.prepend[noSpace]
		]

		element.regionFor.keywords(";").forEach [
			it.prepend[noSpace].append[newLine]
		]

		if (!hasEntries)
			element.regionFor.keyword(gipsConfigAccess.rightCurlyBracketKeyword_16).prepend[newLine]

		// Each of these should be their own semantic elements
		element.regionFor.keyword(gipsConfigAccess.solverKeyword_3).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.launchConfigKeyword_8_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.timeLimitKeyword_9_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.randomSeedKeyword_10_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.presolveKeyword_11_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.debugOutputKeyword_12_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.toleranceKeyword_13_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.lpOutputKeyword_14_0).prepend[newLine]
		element.regionFor.keyword(gipsConfigAccess.threadCountKeyword_15_0).prepend[newLine]
	}

	def dispatch void format(GipsMapping gipsMapping, extension IFormattableDocument document) {
		gipsMapping.regionFor.keyword(gipsMappingAccess.mappingKeyword_0).append[oneSpace]
		gipsMapping.regionFor.keyword(gipsMappingAccess.toKeyword_2).surround[oneSpace]

		// parameters
		gipsMapping.regionFor.keyword(gipsMappingAccess.leftCurlyBracketKeyword_4_0).prepend[oneSpace]
		val body = gipsMapping.regionFor.keywordPairs(gipsMappingAccess.leftCurlyBracketKeyword_4_0,
			gipsMappingAccess.rightCurlyBracketKeyword_4_2)
		if (body.length > 0)
			body.get(0).interior[indent]

		for (gipsMappingVariable : gipsMapping.variables) {
			gipsMappingVariable.format.surround[newLine]
		}

		gipsMapping.regionFor.keyword(gipsMappingAccess.semicolonKeyword_5).prepend[noSpace]
	}

	def dispatch void format(GipsMappingVariable gipsMappingVariable, extension IFormattableDocument document) {
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.varKeyword_0).append[oneSpace]
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.colonKeyword_2).surround[oneSpace]
		gipsMappingVariable.regionFor.keyword(gipsMappingVariableAccess.boundBindKeyword_4_0_0).surround[oneSpace]
		gipsMappingVariable.formatChilds(document)
	}

	def dispatch void format(GipsConstant gipsConstant, extension IFormattableDocument document) {
		gipsConstant.regionFor.keyword(gipsConstantAccess.letKeyword_0).append[oneSpace]
		gipsConstant.regionFor.keyword(gipsConstantAccess.colonEqualsSignKeyword_2).surround[oneSpace]
		gipsConstant.regionFor.keyword(gipsConstantAccess.semicolonKeyword_4).prepend[noSpace]
		gipsConstant.formatChilds(document)
	}

	def dispatch void format(GipsConstantReference gipsConstantReference, extension IFormattableDocument document) {
		gipsConstantReference.regionFor.keyword(gipsConstantReferenceAccess.fullStopKeyword_1).surround[noSpace]
		gipsConstantReference.formatChilds(document)
	}

	def dispatch void format(GipsConstraint gipsConstraint, extension IFormattableDocument document) {
		gipsConstraint.regionFor.keyword(gipsConstraintAccess.isLocalWithKeyword_1_0_0).surround[oneSpace]
		gipsConstraint.regionFor.keyword(gipsConstraintAccess.leftCurlyBracketKeyword_2).prepend[oneSpace]

		val body = gipsConstraint.regionFor.keywordPairs(gipsConstraintAccess.leftCurlyBracketKeyword_2,
			gipsConstraintAccess.rightCurlyBracketKeyword_5)
		if (body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsConstraint.constants)
			gipsConstant.format.surround[newLine]

		gipsConstraint.expression.format.surround[newLine]
	}

	def dispatch void format(GipsLinearFunction gipsLinearFunction, extension IFormattableDocument document) {
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.functionKeyword_0).append[oneSpace]
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.withKeyword_2).surround[oneSpace]
		gipsLinearFunction.regionFor.keyword(gipsLinearFunctionAccess.leftCurlyBracketKeyword_4).prepend[oneSpace]

		val body = gipsLinearFunction.regionFor.keywordPairs(gipsLinearFunctionAccess.leftCurlyBracketKeyword_4,
			gipsLinearFunctionAccess.rightCurlyBracketKeyword_7)
		if (body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsLinearFunction.constants)
			gipsConstant.format.surround[newLine]

		gipsLinearFunction.expression.format.surround[newLine]
	}

	//	handled by GipsArithmeticOperand
//		def dispatch void format(GipsLinearFunctionReference gipsLinearFunctionReference, extension IFormattableDocument document) {}
	
	def dispatch void format(GipsObjective gipsObjective, extension IFormattableDocument document) {
		gipsObjective.regionFor.keyword(gipsObjectiveAccess.colonKeyword_1).surround[oneSpace]
		gipsObjective.regionFor.keyword(gipsObjectiveAccess.leftCurlyBracketKeyword_3).prepend[oneSpace]

		val body = gipsObjective.regionFor.keywordPairs(gipsObjectiveAccess.leftCurlyBracketKeyword_3,
			gipsObjectiveAccess.rightCurlyBracketKeyword_6)
		if (body.size > 0)
			body.get(0).interior[indent]

		for (gipsConstant : gipsObjective.constants)
			gipsConstant.format.surround[newLine]

		gipsObjective.expression.format.surround[newLine]
	}

	//	def dispatch void format(GipsBooleanExpression gipsBooleanExpression, extension IFormattableDocument document) {}

	def dispatch void format(GipsBooleanImplication gipsBooleanImplication, extension IFormattableDocument document) {
		gipsBooleanImplication.regionFor.feature(GipslPackage.Literals.GIPS_BOOLEAN_IMPLICATION__OPERATOR).surround[oneSpace]		
		gipsBooleanImplication.formatChilds(document)
	}

	def dispatch void format(GipsBooleanDisjunction gipsBooleanDisjunction, extension IFormattableDocument document) {
		gipsBooleanDisjunction.regionFor.feature(GipslPackage.Literals.GIPS_BOOLEAN_DISJUNCTION__OPERATOR).surround[oneSpace]		
		gipsBooleanDisjunction.formatChilds(document)
	}

	def dispatch void format(GipsBooleanConjunction gipsBooleanConjunction, extension IFormattableDocument document) {
		gipsBooleanConjunction.regionFor.feature(GipslPackage.Literals.GIPS_BOOLEAN_CONJUNCTION__OPERATOR).surround[oneSpace]		
		gipsBooleanConjunction.formatChilds(document)
	}

	def dispatch void format(GipsBooleanNegation gipsBooleanNegation, extension IFormattableDocument document) {
		// no space between '!' and operand
		gipsBooleanNegation.operand.format.prepend[noSpace]
	}

	def dispatch void format(GipsBooleanBracket gipsBooleanBracket, extension IFormattableDocument document) {
		// no space between operand and brackets
		gipsBooleanBracket.operand.format.surround[noSpace]
	}

	def dispatch void format(GipsRelationalExpression gipsRelationalExpression, extension IFormattableDocument document) {
		gipsRelationalExpression.regionFor.feature(GipslPackage.Literals.GIPS_RELATIONAL_EXPRESSION__OPERATOR).surround[oneSpace]		
		gipsRelationalExpression.formatChilds(document)
	}

//	def dispatch void format(GipsArithmeticExpression gipsArithmeticExpression, extension IFormattableDocument document) {}

	def dispatch void format(GipsArithmeticSum gipsArithmeticSum, extension IFormattableDocument document) {
		gipsArithmeticSum.regionFor.feature(GipslPackage.Literals.GIPS_ARITHMETIC_SUM__OPERATOR).surround[oneSpace]		
		gipsArithmeticSum.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticProduct gipsArithmeticProduct, extension IFormattableDocument document) {
		gipsArithmeticProduct.regionFor.feature(GipslPackage.Literals.GIPS_ARITHMETIC_PRODUCT__OPERATOR).surround[oneSpace]		
		gipsArithmeticProduct.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticExponential gipsArithmeticExponential, extension IFormattableDocument document) {
		gipsArithmeticExponential.regionFor.feature(GipslPackage.Literals.GIPS_ARITHMETIC_EXPONENTIAL__OPERATOR).surround[oneSpace]		
		gipsArithmeticExponential.formatChilds(document)
	}

	def dispatch void format(GipsArithmeticUnary gipsArithmeticUnary, extension IFormattableDocument document) {
		gipsArithmeticUnary.regionFor.feature(GipslPackage.Literals.GIPS_ARITHMETIC_UNARY__OPERATOR).append[noSpace]
		gipsArithmeticUnary.operand.format.surround[noSpace]
	}

	def dispatch void format(GipsArithmeticBracket gipsArithmeticBracket, extension IFormattableDocument document) {
		// no space between operand and parenthesis
		gipsArithmeticBracket.operand.format.surround[noSpace]
	}

	def dispatch void format(GipsArithmeticOperand gipsArithmeticOperand, extension IFormattableDocument document) {
		// deals with all subclasses of GipsArithmeticOperand
		gipsArithmeticOperand.regionFor.keyword(".").surround[noSpace]
		gipsArithmeticOperand.formatChilds(document)
	}

//	def dispatch void format(GipsValueExpression gipsValueExpression, extension IFormattableDocument document) {}

	def dispatch void format(GipsMappingExpression gipsMappingExpression, extension IFormattableDocument document) {
		gipsMappingExpression.regionFor.keyword(gipsMappingExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsMappingExpression.formatChilds(document)
	}

	def dispatch void format(GipsTypeExpression gipsTypeExpression, extension IFormattableDocument document) {
		gipsTypeExpression.regionFor.keyword(gipsTypeExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsTypeExpression.formatChilds(document)
	}

	def dispatch void format(GipsPatternExpression gipsPatternExpression, extension IFormattableDocument document) {
		gipsPatternExpression.regionFor.keyword(gipsPatternExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsPatternExpression.formatChilds(document)
	}

	def dispatch void format(GipsRuleExpression gipsRuleExpression, extension IFormattableDocument document) {
		gipsRuleExpression.regionFor.keyword(gipsRuleExpressionAccess.fullStopKeyword_2).surround[noSpace]
		gipsRuleExpression.formatChilds(document)
	}

	def dispatch void format(GipsLocalContextExpression gipsLocalContextExpression, extension IFormattableDocument document) {
		gipsLocalContextExpression.regionFor.keyword(gipsLocalContextExpressionAccess.contextKeyword_1).append[noSpace]
		gipsLocalContextExpression.expression.format
	}

	def dispatch void format(GipsSetElementExpression gipsSetElementExpression, extension IFormattableDocument document) {
		gipsSetElementExpression.regionFor.keyword(gipsSetElementExpressionAccess.elementKeyword_1).append[noSpace]
		gipsSetElementExpression.expression.format
	}

	def dispatch void format(GipsVariableReferenceExpression gipsVariableReferenceExpression, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsVariableReferenceExpression.regionFor.keyword(gipsVariableReferenceExpressionAccess.fullStopKeyword_0).append[noSpace]
		gipsVariableReferenceExpression.regionFor.keyword(gipsVariableReferenceExpressionAccess.fullStopKeyword_1_1_1).surround[noSpace]
		gipsVariableReferenceExpression.variable.format
	}

	def dispatch void format(GipsNodeExpression gipsNodeExpression, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsNodeExpression.regionFor.keyword(gipsNodeExpressionAccess.fullStopKeyword_1).append[noSpace]
		gipsNodeExpression.regionFor.keyword(gipsNodeExpressionAccess.nodesKeyword_2).append[noSpace]
		gipsNodeExpression.regionFor.keyword(gipsNodeExpressionAccess.fullStopKeyword_3).append[noSpace]
		gipsNodeExpression.attributeExpression.format
	}

	def dispatch void format(GipsAttributeExpression gipsAttributeExpression, extension IFormattableDocument document) {
		gipsAttributeExpression.regionFor.keyword(gipsAttributeExpressionAccess.fullStopKeyword_1).append[noSpace]
		gipsAttributeExpression.attribute.format
		gipsAttributeExpression.right.format.prepend[noSpace] // attribute chaining, remove space before '.'
	}

	def dispatch void format(GipsSetExpression gipsSetExpression, extension IFormattableDocument document) {
		gipsSetExpression.regionFor.keyword(gipsSetExpressionAccess.hyphenMinusGreaterThanSignKeyword_1).append[noSpace]
		gipsSetExpression.operation.format
		gipsSetExpression.right.format.prepend[noSpace] // set chaining, remove space before '->'
	}
	
	// def dispatch void format(GipsSetOperation gipsSetOperation, extension IFormattableDocument document){}
	
	def dispatch void format(GipsFilterOperation gipsFilterOperation, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsFilterOperation.regionFor.keyword(gipsFilterOperationAccess.filterKeyword_0).append[noSpace]
		gipsFilterOperation.regionFor.keyword(gipsFilterOperationAccess.leftParenthesisKeyword_1).append[noSpace]
		gipsFilterOperation.regionFor.keyword(gipsFilterOperationAccess.rightParenthesisKeyword_3).prepend[noSpace]
		gipsFilterOperation.expression.format
	}

	// def dispatch void format(GipsSelectOperation gipsSelectOperation, extension IFormattableDocument document){}
	
	def dispatch void format(GipsTypeSelect gipsTypeSelect, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsTypeSelect.regionFor.keyword(gipsTypeSelectAccess.selectTypeKeyword_0).append[noSpace]
		gipsTypeSelect.regionFor.keyword(gipsTypeSelectAccess.leftParenthesisKeyword_1).append[noSpace]
		gipsTypeSelect.regionFor.keyword(gipsTypeSelectAccess.rightParenthesisKeyword_3).prepend[noSpace]
		gipsTypeSelect.type.format
	}

	// def dispatch void format(GipsAlgorithmOperation gipsAlgorithmOperation, extension IFormattableDocument document){}
	
	def dispatch void format(GipsSortOperation gipsSortOperation, extension IFormattableDocument document) {
		// remove all spaces between keywords
		gipsSortOperation.regionFor.keyword(gipsSortOperationAccess.sortKeyword_0).append[noSpace]
		gipsSortOperation.regionFor.keyword(gipsSortOperationAccess.leftParenthesisKeyword_1).append[noSpace]
		gipsSortOperation.regionFor.keyword(gipsSortOperationAccess.rightParenthesisKeyword_3).prepend[noSpace]
		gipsSortOperation.predicate.format
	}

	def dispatch void format(GipsSortPredicate gipsSortPredicate, extension IFormattableDocument document) {
		gipsSortPredicate.regionFor.keyword(gipsSortPredicateAccess.e1Keyword_0).append[oneSpace]
		gipsSortPredicate.e1.format
		gipsSortPredicate.regionFor.feature(GipslPackage.Literals.GIPS_SORT_PREDICATE__RELATION).surround[oneSpace]
		gipsSortPredicate.regionFor.keyword(gipsSortPredicateAccess.e2Keyword_3).append[oneSpace]
		gipsSortPredicate.e2.format
	}

	def dispatch void format(GipsSimpleAlgorithm gipsSimpleAlgorithm, extension IFormattableDocument document) {
		gipsSimpleAlgorithm.regionFor.keyword(gipsSimpleAlgorithmAccess.leftParenthesisRightParenthesisKeyword_1).prepend[noSpace]
	}

	def dispatch void format(GipsConcatenationOperation gipsConcatenationOperation, extension IFormattableDocument document) {
		gipsConcatenationOperation.operator.format
		gipsConcatenationOperation.regionFor.keyword(gipsConcatenationOperationAccess.leftParenthesisKeyword_1).prepend[noSpace]		
		gipsConcatenationOperation.value.format.surround[noSpace]
	}
	
	def dispatch void format(GipsTransformOperation gipsTransformOperation, extension IFormattableDocument document) {
		gipsTransformOperation.regionFor.keyword(gipsTransformOperationAccess.transformKeyword_0).append[noSpace]
		gipsTransformOperation.expression.format.surround[noSpace]
	}
	
//	def dispatch void format(GipsReduceOperation gipsReduceOperation, extension IFormattableDocument document) {}

	def dispatch void format(GipsSumOperation gipsSumOperation, extension IFormattableDocument document) {
		gipsSumOperation.regionFor.keyword(gipsSumOperationAccess.sumKeyword_0).append[noSpace]
		gipsSumOperation.expression.format.surround[noSpace]
	}
	
	def dispatch void format(GipsSimpleSelect gipsSimpleSelect, extension IFormattableDocument document) {
		gipsSimpleSelect.operator.format
		gipsSimpleSelect.regionFor.keyword(gipsSimpleSelectAccess.leftParenthesisRightParenthesisKeyword_1).prepend[noSpace]		
	}

//	def dispatch void format(GipsQueryOperation gipsQueryOperation, extension IFormattableDocument document) {}
	
	def dispatch void format(GipsTypeQuery gipsTypeQuery, extension IFormattableDocument document) {
		gipsTypeQuery.regionFor.keyword(gipsTypeQueryAccess.containsTypeKeyword_0).append[noSpace]
		gipsTypeQuery.type.format.surround[noSpace]
	}
	
	def dispatch void format(GipsElementQuery gipsElementQuery, extension IFormattableDocument document) {
		gipsElementQuery.regionFor.keyword(gipsElementQueryAccess.containsElementKeyword_0).append[noSpace]
		gipsElementQuery.element.format.surround[noSpace]
	}
	
	def dispatch void format(GipsSimpleQuery gipsSimpleQuery, extension IFormattableDocument document) {
		gipsSimpleQuery.operator.format
		gipsSimpleQuery.regionFor.keyword(gipsSimpleQueryAccess.leftParenthesisRightParenthesisKeyword_1).prepend[noSpace]		
	}
	
	// Helper
	protected static def EObject groupElementWithPrevElement(EObject element, extension IFormattableDocument document,
		int newLinesOnMatch, int newLinesOnMiss, Class<?>... groupies) {
		if (groupies === null || groupies.length === 0)
			return element

		if (element.previousSibling.instanceOf(groupies))
			element.prepend[newLines = newLinesOnMatch]
		else
			element.prepend[newLines = newLinesOnMiss]

		return element
	}

	protected static def EObject getPreviousSibling(EObject element) {
		if (element === null)
			return null;

		val elementTextNode = NodeModelUtils.findActualNodeFor(element)
		val previousTextNode = elementTextNode.previousSibling
		if (previousTextNode === null)
			return null;

		return NodeModelUtils.findActualSemanticObjectFor(previousTextNode)
	}

	protected static def EObject getNextSibling(EObject element) {
		if (element === null)
			return null;

		val elementTextNode = NodeModelUtils.findActualNodeFor(element)
		val previousTextNode = elementTextNode.nextSibling
		if (previousTextNode === null)
			return null;

		return NodeModelUtils.findActualSemanticObjectFor(previousTextNode)
	}

	protected static def boolean instanceOf(EObject element, Class<?>... types) {
		if (element === null)
			return false

		if (types === null || types.length === 0)
			return true

		for (Class<?> type : types) {
			if (type.isInstance(element))
				return true;
		}

		return false
	}

	/**
	 * Stolen from {@link GTFormatter#formatList}
	 * 
	 * @param newLinesBeforeFirst lines before the first item, does nothing for values smaller 0
	 * @param newLinesBetweenItems lines inbetween items, does nothing for values smaller 0
	 * @param newLinesAfterLastItem lines afther the last item, does nothing for values smaller 0
	 */
	protected static def void formatList(List<? extends EObject> items, extension IFormattableDocument document,
		int newLinesBeforeFirst, int newLinesBetweenItems, int newLinesAfterLastItem) {

		if (items.size() == 0)
			return;

		if (newLinesBeforeFirst >= 0)
			items.get(0).prepend[newLines = newLinesBeforeFirst]

		for (var index = 0; index < items.size(); index++)
			items.get(index).format

		if (newLinesBetweenItems >= 0)
			for (var index = 0; index < items.size() - 1; index++)
				items.get(index).append[newLines = newLinesBetweenItems]

		if (newLinesAfterLastItem >= 0)
			items.get(items.size() - 1).append[newLines = newLinesAfterLastItem]
	}

	protected static def formatChilds(EObject parent, extension IFormattableDocument document) {
		parent.eContents.forEach[it.format]
	}

}
