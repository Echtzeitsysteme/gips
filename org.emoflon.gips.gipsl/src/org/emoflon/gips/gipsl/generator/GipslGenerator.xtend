/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.Collection
import org.apache.log4j.Logger
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.resource.SynchronizedXtextResourceSet
import org.emoflon.ibex.common.slimgt.util.SlimGTWorkspaceUtil
import java.util.LinkedList
import java.io.File
import org.emoflon.gips.gipsl.util.GipslResourceManager
import java.util.HashMap
import org.eclipse.xtext.EcoreUtil2
import org.emoflon.ibex.gt.gtl.gTL.EditorFile
import org.emoflon.gips.gipsl.util.GipslModelFlattener
import org.moflon.core.utilities.LogUtils
import org.moflon.core.utilities.ExtensionsUtil
import org.emoflon.ibex.common.slimgt.build.SlimGTBuilderExtension

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GipslGenerator extends AbstractGenerator {

	Logger logger = Logger.getLogger(typeof(GipslGenerator));
	var ResourceSet resourceSet = null

	override void doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var lResource = input.resourceSet as SynchronizedXtextResourceSet
		val iProject = SlimGTWorkspaceUtil.getCurrentProject(input)
		
		if(resourceSet === null) {
			resourceSet = lResource
		} else if(resourceSet !== null && !resourceSet.equals(lResource)) {
			resourceSet = lResource
		} else {
			return
		}
		
		logger.info('''Building project «iProject.name» ...''')
		val files = new LinkedList
		SlimGTWorkspaceUtil.gatherFilesWithEnding(files, new File(iProject.location.toPortableString), ".gipsl", true)
		
		val manager = new GipslResourceManager();
		val pkg2Files = new HashMap<String, Collection<EditorFile>>
		for(File f : files) {
			val efOpt = manager.loadGTLModelByFullPath(input, f.canonicalPath)
			if(efOpt.isPresent) {
				val ef = efOpt.get
				var editorFiles = pkg2Files.get(ef.package.name)
				if(editorFiles === null) {
					editorFiles = new LinkedList
					pkg2Files.put(ef.package.name, editorFiles)
				}
				editorFiles.add(ef)
				EcoreUtil2.resolveLazyCrossReferences(ef.eResource, [| false]);
				EcoreUtil2.resolveAll(ef)
			}
		}
		
		logger.info('''Building project «iProject.name» -> flattening gipsl & gtl files ...''')
		val pkg2flattened = new HashMap<String, org.emoflon.gips.gipsl.gipsl.EditorFile>
		try{
			flatten(pkg2flattened, pkg2Files, manager);
		} catch(Exception e) {
			LogUtils.error(logger, e)
		}
		
		logger.info('''Building project «iProject.name» -> calling gips builder extensions ...''')
		ExtensionsUtil
			.collectExtensions(SlimGTBuilderExtension.BUILDER_EXTENSON_ID, "builder", typeof(SlimGTBuilderExtension))
			.filter[builder | builder.hasProperNature(iProject)]
			.forEach[builder | pkg2flattened.values.forEach[ef | builder.build(iProject, ef)]];
	}
	
	def void flatten(HashMap<String, org.emoflon.gips.gipsl.gipsl.EditorFile> pkg2flattened, HashMap<String, Collection<EditorFile>> pkg2Files, GipslResourceManager manager) {
		for(String pkg : pkg2Files.keySet) {
			val efs = pkg2Files.get(pkg)
			val flattener = new GipslModelFlattener(manager, efs)
			val flattenedEf = flattener.flattenedModel
			pkg2flattened.put(pkg, flattenedEf)
		}
	}
}
 