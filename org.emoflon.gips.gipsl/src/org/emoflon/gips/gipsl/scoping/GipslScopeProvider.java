/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.scoping;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.emoflon.gips.gipsl.gipsl.EditorGTFile;
import org.emoflon.gips.gipsl.gipsl.GipsAttributeLiteral;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction;
import org.emoflon.gips.gipsl.gipsl.GipsLocalContextExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable;
import org.emoflon.gips.gipsl.gipsl.GipsNodeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression;
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSetElementExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSortPredicate;
import org.emoflon.gips.gipsl.gipsl.GipsTransformOperation;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsTypeQuery;
import org.emoflon.gips.gipsl.gipsl.GipsTypeSelect;
import org.emoflon.gips.gipsl.gipsl.GipsValueExpression;
import org.emoflon.gips.gipsl.gipsl.GipsVariableReferenceExpression;
import org.emoflon.gips.gipsl.gipsl.ImportedPattern;
import org.emoflon.gips.gipsl.gipsl.impl.EditorGTFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLocalContextExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsMappingImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsNodeExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSetElementExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSortPredicateImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsTransformOperationImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsValueExpressionImpl;
import org.emoflon.ibex.gt.editor.gT.EditorOperator;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;

/**
 * This class contains custom scoping description.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class GipslScopeProvider extends AbstractGipslScopeProvider {

	protected Map<Resource, Map<URI, Resource>> resourceCache = new HashMap<>();
	protected Set<EDataType> variableDataTypes = Set.of(EcorePackage.Literals.EDOUBLE, EcorePackage.Literals.EFLOAT,
			EcorePackage.Literals.EINT, EcorePackage.Literals.ELONG, EcorePackage.Literals.ESHORT,
			EcorePackage.Literals.EBYTE, EcorePackage.Literals.EBOOLEAN);

	@Override
	public IScope getScope(EObject context, EReference reference) {
		try {
			return getScopeInternal(context, reference);
		} catch (Exception e) {
			e.printStackTrace();
			return IScope.NULLSCOPE;
		}
	}

	public IScope getScopeInternal(EObject context, EReference reference) throws Exception {
		if (GipslScopeContextUtil.isPatternImportPattern(context, reference)) {
			return scopeForImportedPatternPattern((ImportedPattern) context, reference);
		} else if (GipslScopeContextUtil.isGipsMapping(context, reference)) {
			return scopeForGipsMapping((GipsMapping) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingVariableType(context, reference)) {
			return scopeForGipsMappingVariableType((GipsMappingVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingVariableParameter(context, reference)) {
			return scopeForGipsMappingVariableParameter((GipsMappingVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsVariableReferenceExpression(context, reference)) {
			return scopeForGipsVariableReferenceExpression((GipsVariableReferenceExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsConstraintContext(context, reference)) {
			return scopeForGipsConstraintContext((GipsConstraint) context, reference);
		} else if (GipslScopeContextUtil.isGipsLinearFunctionContext(context, reference)) {
			return scopeForGipsLinearFunctionContext((GipsLinearFunction) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingExpression(context, reference)) {
			return scopeForGipsMappingExpression((GipsMappingExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeExpression(context, reference)) {
			return scopeForGipsTypeExpression((GipsTypeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsPatternExpression(context, reference)) {
			return scopeForGipsPatternExpression((GipsPatternExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsRuleExpression(context, reference)) {
			return scopeForGipsRuleExpression((GipsRuleExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsNodeExpression(context, reference)) {
			return scopeForGipsNodeExpression((GipsNodeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsAttributeLiteral(context, reference)) {
			return scopeForGipsAttributeLiteral((GipsAttributeLiteral) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeSelect(context, reference)) {
			return scopeForGipsTypeSelect((GipsTypeSelect) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeQuery(context, reference)) {
			return scopeForGipsTypeQuery((GipsTypeQuery) context, reference);
		} else {
			return super.getScope(context, reference);
		}
	}

	protected Resource loadResource(final Resource requester, final URI gtModelUri) {
		Map<URI, Resource> cache = resourceCache.get(requester);
		if (cache == null) {
			cache = new HashMap<>();
			resourceCache.put(requester, cache);
		}

		Resource other = cache.get(gtModelUri);
		if (other == null) {
			XtextResourceSet rs = new XtextResourceSet();
			try {
				other = rs.getResource(gtModelUri, true);
			} catch (Exception e) {
				return other;
			}
			cache.put(gtModelUri, other);

			if (other == null)
				return other;

			EcoreUtil2.resolveLazyCrossReferences(other, () -> false);
		}

		return other;
	}

	private IScope scopeForImportedPatternPattern(ImportedPattern context, EReference reference) {
		if (context == null || context.getFile() == null || context.getFile().isBlank())
			return IScope.NULLSCOPE;

		Resource resource = null;
		String currentImport = context.getFile().replace("\"", "");
		File importFile = new File(currentImport);
		if (importFile.exists() && importFile.isFile() && importFile.isAbsolute()) {
			URI gtModelUri = URI.createFileURI(currentImport);
			resource = loadResource(context.eResource(), gtModelUri);
			if (resource == null)
				return IScope.NULLSCOPE;
		} else {
			// 1. Case: package name
			if (!(currentImport.contains("/") || currentImport.contains("\\"))) {
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(context.eResource());

				String currentFile = context.eResource().getURI().toString().replace("platform:/resource/", "")
						.replace(currentProject.getName(), "");
				currentFile = currentProject.getLocation().toPortableString() + currentFile;
				currentFile = currentFile.replace("/", "\\");

				IWorkspace ws = ResourcesPlugin.getWorkspace();
				for (IProject project : ws.getRoot().getProjects()) {
					try {
						if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
							continue;
					} catch (CoreException e) {
						continue;
					}

					File projectFile = new File(project.getLocation().toPortableString());
					List<File> gtFiles = new LinkedList<>();
					GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

					for (File gtFile : gtFiles) {
						URI gtModelUri;
						try {
							gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
						} catch (IOException e) {
							continue;
						}

						String fileString = gtModelUri.toFileString();

						if (fileString.equals(currentFile))
							continue;

						resource = loadResource(context.eResource(), gtModelUri);
						if (resource == null)
							continue;

						EObject gtModel = resource.getContents().get(0);

						if (gtModel == null)
							continue;

						if (gtModel instanceof EditorGTFile gipsEditorFile) {
							if (gipsEditorFile.getPackage().getName().equals(context.getFile())) {
								break;
							}
						}
						resource = null;
					}

					if (resource != null)
						break;
				}
			} else { // 2. Case: relative path
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(context.eResource());
				if (currentProject == null)
					return IScope.NULLSCOPE;

				String absolutePath = null;
				try {
					absolutePath = Paths.get(currentProject.getLocation().toPortableString())
							.resolve(Paths.get(currentImport)).toFile().getCanonicalPath();
				} catch (IOException e) {
					return IScope.NULLSCOPE;
				}
				URI gtModelUri = URI.createFileURI(absolutePath);
				resource = loadResource(context.eResource(), gtModelUri);
				if (resource == null)
					return IScope.NULLSCOPE;
			}
		}

		Set<String> allPatterns = new HashSet<>();
		EditorGTFile currentFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		currentFile.getPatterns().forEach(p -> allPatterns.add(p.getName()));

		EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
		EObject gtModel = resource.getContents().get(0);
		if (gtModel instanceof org.emoflon.ibex.gt.editor.gT.EditorGTFile gtFile) {
			return Scopes.scopeFor(gtFile.getPatterns().stream().filter(p -> !allPatterns.contains(p.getName()))
					.collect(Collectors.toList()));
		} else if (gtModel instanceof EditorGTFile gipsFile) {
			return Scopes.scopeFor(gipsFile.getPatterns().stream().filter(p -> !allPatterns.contains(p.getName()))
					.collect(Collectors.toList()));
		} else {
			return IScope.NULLSCOPE;
		}

	}

	public IScope scopeForGipsMapping(GipsMapping context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getAllEditorPatterns(context));
	}

	public IScope scopeForGipsMappingVariableType(GipsMappingVariable context, EReference reference) {
		return Scopes.scopeFor(variableDataTypes);
	}

	public IScope scopeForGipsMappingVariableParameter(GipsMappingVariable context, EReference reference) {
		if (context.getType() == null)
			return IScope.NULLSCOPE;

		GipsMapping mapping = GTEditorPatternUtils.getContainer(context, GipsMappingImpl.class);
		if (mapping == null)
			return IScope.NULLSCOPE;

		EditorPattern pattern = mapping.getPattern();
		if (pattern == null)
			return IScope.NULLSCOPE;

		if (pattern.getParameters() == null || pattern.getParameters().isEmpty())
			return IScope.NULLSCOPE;

		// TODO: Exclude parameters that are not exclusively used in attribute
		// assignments (i.e. parameters used in conditions for pattern matching)
		return Scopes.scopeFor(pattern.getParameters().stream()
				.filter(param -> variableDataTypes.contains(param.getType())).collect(Collectors.toList()));
	}

	public IScope scopeForGipsVariableReferenceExpression(GipsVariableReferenceExpression context,
			EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context,
				Set.of(GipsValueExpressionImpl.class, GipsTransformOperationImpl.class));

		if (container instanceof GipsValueExpression root) {
			if (root.getValue() instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
						&& !mapping.getMapping().getVariables().isEmpty()) {
					return Scopes.scopeFor(mapping.getMapping().getVariables());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (root.getValue() instanceof GipsLocalContextExpression local) {
				if (!GipslScopeContextUtil.hasLocalContext(local)) {
					return IScope.NULLSCOPE;
				}
				EObject localContext = GipslScopeContextUtil.getLocalContext(local);
				if (localContext instanceof GipsMapping mapping) {
					if (mapping.getVariables() != null && !mapping.getVariables().isEmpty()) {
						return Scopes.scopeFor(mapping.getVariables());
					} else {
						return IScope.NULLSCOPE;
					}
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (root.getValue() instanceof GipsSetElementExpression setElement) {
				EObject setContext = GipslScopeContextUtil.getSetContext(setElement);
				if (setContext instanceof GipsMappingExpression mapping) {
					if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
							&& !mapping.getMapping().getVariables().isEmpty()) {
						return Scopes.scopeFor(mapping.getMapping().getVariables());
					} else {
						return IScope.NULLSCOPE;
					}
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (container instanceof GipsTransformOperation root) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
						&& !mapping.getMapping().getVariables().isEmpty()) {
					return Scopes.scopeFor(mapping.getMapping().getVariables());
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}

	}

	public IScope scopeForGipsConstraintContext(GipsConstraint context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		List<EObject> allContext = new LinkedList<>();
		allContext.addAll(editorFile.getMappings());
		allContext.addAll(GipslScopeContextUtil.getClasses(context));
		allContext.addAll(GipslScopeContextUtil.getAllEditorPatterns(context));
		return Scopes.scopeFor(allContext);
	}

	public IScope scopeForGipsLinearFunctionContext(GipsLinearFunction context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		List<EObject> allContext = new LinkedList<>();
		allContext.addAll(editorFile.getMappings());
		allContext.addAll(GipslScopeContextUtil.getClasses(context));
		allContext.addAll(GipslScopeContextUtil.getAllEditorPatterns(context));
		return Scopes.scopeFor(allContext);
	}

	public IScope scopeForGipsMappingExpression(GipsMappingExpression context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getMappings());
	}

	public IScope scopeForGipsTypeExpression(GipsTypeExpression context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

	public IScope scopeForGipsPatternExpression(GipsPatternExpression context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getPatterns(context));
	}

	public IScope scopeForGipsRuleExpression(GipsRuleExpression context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getRules(context));
	}

	public IScope scopeForGipsNodeExpression(GipsNodeExpression context, EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context, Set.of(
				GipsLocalContextExpressionImpl.class, GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class));

		EditorPattern editorPattern = null;

		if (container instanceof GipsLocalContextExpression root) {
			if (!GipslScopeContextUtil.hasLocalContext(root)) {
				return IScope.NULLSCOPE;
			}
			EObject localContext = GipslScopeContextUtil.getLocalContext(root);
			if (localContext instanceof GipsMapping mapping) {
				if (mapping.getPattern() != null) {
					editorPattern = mapping.getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (localContext instanceof EditorPattern) {
				editorPattern = (EditorPattern) localContext;
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (container instanceof GipsSetElementExpression || container instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(container);
			if (setContext instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getPattern() != null) {
					editorPattern = mapping.getMapping().getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsPatternExpression pattern) {
				if (pattern.getPattern() != null) {
					editorPattern = pattern.getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsRuleExpression rule) {
				if (rule.getRule() != null) {
					editorPattern = rule.getRule();
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}

		return Scopes.scopeFor(GTEditorPatternUtils.getAllNodesOfPattern(editorPattern,
				n -> n.getOperator() != EditorOperator.CREATE));
	}

	public IScope scopeForGipsAttributeLiteral(GipsAttributeLiteral context, EReference reference) {
		EObject root = (EObject) GipslScopeContextUtil.getContainer(context, Set.of(GipsNodeExpressionImpl.class,
				GipsLocalContextExpressionImpl.class, GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class));
		if (root instanceof GipsNodeExpression node) {
			if (node.getNode() != null && node.getNode().getType() != null) {
				return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsLocalContextExpression local) {
			EObject localContext = GipslScopeContextUtil.getLocalContext(local);
			if (localContext instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsSetElementExpression || root instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsTypeExpression type) {
				if (type.getType() != null) {
					return Scopes.scopeFor(type.getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}
	}

	public IScope scopeForGipsTypeSelect(GipsTypeSelect context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

	public IScope scopeForGipsTypeQuery(GipsTypeQuery context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

}
