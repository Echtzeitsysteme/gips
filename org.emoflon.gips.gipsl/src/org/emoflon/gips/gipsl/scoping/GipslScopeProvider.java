/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.scoping;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.emoflon.gips.gipsl.gipsl.EditorGTFile;
import org.emoflon.gips.gipsl.gipsl.GipsAttributeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsAttributeLiteral;
import org.emoflon.gips.gipsl.gipsl.GipsConstant;
import org.emoflon.gips.gipsl.gipsl.GipsConstantReference;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsJoinBySelectionOperation;
import org.emoflon.gips.gipsl.gipsl.GipsJoinPairSelection;
import org.emoflon.gips.gipsl.gipsl.GipsJoinSingleSelection;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunctionReference;
import org.emoflon.gips.gipsl.gipsl.GipsLocalContextExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable;
import org.emoflon.gips.gipsl.gipsl.GipsNodeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression;
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSetElementExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSortPredicate;
import org.emoflon.gips.gipsl.gipsl.GipsTransformOperation;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExtension;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExtensionVariable;
import org.emoflon.gips.gipsl.gipsl.GipsTypeQuery;
import org.emoflon.gips.gipsl.gipsl.GipsTypeSelect;
import org.emoflon.gips.gipsl.gipsl.GipsValueExpression;
import org.emoflon.gips.gipsl.gipsl.GipsVariableReferenceExpression;
import org.emoflon.gips.gipsl.gipsl.GipslPackage;
import org.emoflon.gips.gipsl.gipsl.ImportedPattern;
import org.emoflon.gips.gipsl.gipsl.impl.EditorGTFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsAttributeExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstraintImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLinearFunctionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLocalContextExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsMappingImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsNodeExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsObjectiveImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSetElementExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSortPredicateImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsTransformOperationImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsValueExpressionImpl;
import org.emoflon.ibex.gt.editor.gT.EditorOperator;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;

/**
 * This class contains custom scoping description.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class GipslScopeProvider extends AbstractGipslScopeProvider {

	protected Map<Resource, Map<URI, Resource>> resourceCache = new HashMap<>();
	protected Set<EDataType> variableDataTypes = Set.of(EcorePackage.Literals.EDOUBLE, EcorePackage.Literals.EFLOAT,
			EcorePackage.Literals.EINT, EcorePackage.Literals.ELONG, EcorePackage.Literals.ESHORT,
			EcorePackage.Literals.EBYTE, EcorePackage.Literals.EBOOLEAN);

	@Override
	public IScope getScope(EObject context, EReference reference) {
		try {
			return getScopeInternal(context, reference);
		} catch (Exception e) {
			e.printStackTrace();
			return IScope.NULLSCOPE;
		}
	}

	public IScope getScopeInternal(EObject context, EReference reference) throws Exception {
		if (GipslScopeContextUtil.isPatternImportPattern(context, reference)) {
			return scopeForImportedPatternPattern((ImportedPattern) context, reference);
		} else if (GipslScopeContextUtil.isGipsMapping(context, reference)) {
			return scopeForGipsMapping((GipsMapping) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingVariableType(context, reference)) {
			return scopeForGipsMappingVariableType((GipsMappingVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeExtension(context, reference)) {
			return scopeForGipsTypeExtension((GipsTypeExtension) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeExtensionVariableType(context, reference)) {
			return scopeForGipsTypeExtensionVariableType((GipsTypeExtensionVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingVariableParameter(context, reference)) {
			return scopeForGipsMappingVariableParameter((GipsMappingVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsConstantReference(context, reference)) {
			return scopeForGipsConstantReference((GipsConstantReference) context, reference);
		} else if (GipslScopeContextUtil.isGipsVariableReferenceExpression(context, reference)) {
			return scopeForGipsVariableReferenceExpression((GipsVariableReferenceExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsConstraintContext(context, reference)) {
			return scopeForGipsConstraintContext((GipsConstraint) context, reference);
		} else if (GipslScopeContextUtil.isGipsLinearFunctionContext(context, reference)) {
			return scopeForGipsLinearFunctionContext((GipsLinearFunction) context, reference);
		} else if (GipslScopeContextUtil.isGipsLinearFunctionReference(context, reference)) {
			return scopeForGipsLinearFunctionReference((GipsLinearFunctionReference) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingExpression(context, reference)) {
			return scopeForGipsMappingExpression((GipsMappingExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeExpression(context, reference)) {
			return scopeForGipsTypeExpression((GipsTypeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsPatternExpression(context, reference)) {
			return scopeForGipsPatternExpression((GipsPatternExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsRuleExpression(context, reference)) {
			return scopeForGipsRuleExpression((GipsRuleExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsNodeExpression(context, reference)) {
			return scopeForGipsNodeExpression((GipsNodeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsJoinBySelection(context, reference)) {
			return scopeForGipsJoin((GipsJoinBySelectionOperation) context, reference);
		} else if (GipslScopeContextUtil.isGipsJoinPairSelection(context, reference)) {
			return scopeForGipsJoinPair((GipsJoinPairSelection) context, reference);
		} else if (GipslScopeContextUtil.isGipsJoinSingleSelection(context, reference)) {
			return scopeForGipsJoinSingle((GipsJoinSingleSelection) context, reference);
		} else if (GipslScopeContextUtil.isGipsAttributeExpression(context, reference)) {
			return scopeForGipsAttributeExpression((GipsAttributeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsAttributeLiteral(context, reference)) {
			return scopeForGipsAttributeLiteral((GipsAttributeLiteral) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeSelect(context, reference)) {
			return scopeForGipsTypeSelect((GipsTypeSelect) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeQuery(context, reference)) {
			return scopeForGipsTypeQuery((GipsTypeQuery) context, reference);
		} else {
			return super.getScope(context, reference);
		}
	}

	protected Resource loadResource(final Resource requester, final URI gtModelUri) {
		Map<URI, Resource> cache = resourceCache.get(requester);
		if (cache == null) {
			cache = new HashMap<>();
			resourceCache.put(requester, cache);
		}

		Resource other = cache.get(gtModelUri);
		if (other == null) {
			XtextResourceSet rs = new XtextResourceSet();
			try {
				other = rs.getResource(gtModelUri, true);
			} catch (Exception e) {
				return other;
			}
			cache.put(gtModelUri, other);

			if (other == null)
				return other;

			EcoreUtil2.resolveLazyCrossReferences(other, () -> false);
		}

		return other;
	}

	private IScope scopeForImportedPatternPattern(ImportedPattern context, EReference reference) {
		if (context == null || context.getFile() == null || context.getFile().isBlank())
			return IScope.NULLSCOPE;

		Resource resource = null;
		String currentImport = context.getFile().replace("\"", "");
		File importFile = new File(currentImport);
		if (importFile.exists() && importFile.isFile() && importFile.isAbsolute()) {
			URI gtModelUri = URI.createFileURI(currentImport);
			resource = loadResource(context.eResource(), gtModelUri);
			if (resource == null)
				return IScope.NULLSCOPE;
		} else {
			// 1. Case: package name
			if (!(currentImport.contains("/") || currentImport.contains("\\"))) {
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(context.eResource());

				String currentFile = context.eResource().getURI().toString().replace("platform:/resource/", "")
						.replace(currentProject.getName(), "");
				currentFile = currentProject.getLocation().toPortableString() + currentFile;
				currentFile = currentFile.replace("/", "\\");

				IWorkspace ws = ResourcesPlugin.getWorkspace();
				for (IProject project : ws.getRoot().getProjects()) {
					try {
						if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
							continue;
					} catch (CoreException e) {
						continue;
					}

					File projectFile = new File(project.getLocation().toPortableString());
					List<File> gtFiles = new LinkedList<>();
					GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

					for (File gtFile : gtFiles) {
						URI gtModelUri;
						try {
							gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
						} catch (IOException e) {
							continue;
						}

						String fileString = gtModelUri.toFileString();

						if (fileString.equals(currentFile))
							continue;

						resource = loadResource(context.eResource(), gtModelUri);
						if (resource == null)
							continue;

						EObject gtModel = resource.getContents().get(0);

						if (gtModel == null)
							continue;

						if (gtModel instanceof EditorGTFile gipsEditorFile) {
							if (gipsEditorFile.getPackage().getName().equals(context.getFile())) {
								break;
							}
						}
						resource = null;
					}

					if (resource != null)
						break;
				}
			} else { // 2. Case: relative path
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(context.eResource());
				if (currentProject == null)
					return IScope.NULLSCOPE;

				String absolutePath = null;
				try {
					absolutePath = Paths.get(currentProject.getLocation().toPortableString())
							.resolve(Paths.get(currentImport)).toFile().getCanonicalPath();
				} catch (IOException e) {
					return IScope.NULLSCOPE;
				}
				URI gtModelUri = URI.createFileURI(absolutePath);
				resource = loadResource(context.eResource(), gtModelUri);
				if (resource == null)
					return IScope.NULLSCOPE;
			}
		}

		Set<String> allPatterns = new HashSet<>();
		EditorGTFile currentFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		currentFile.getPatterns().forEach(p -> allPatterns.add(p.getName()));

		EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
		EObject gtModel = resource.getContents().get(0);
		if (gtModel instanceof org.emoflon.ibex.gt.editor.gT.EditorGTFile gtFile) {
			return Scopes.scopeFor(gtFile.getPatterns().stream().filter(p -> !allPatterns.contains(p.getName()))
					.collect(Collectors.toList()));
		} else if (gtModel instanceof EditorGTFile gipsFile) {
			return Scopes.scopeFor(gipsFile.getPatterns().stream().filter(p -> !allPatterns.contains(p.getName()))
					.collect(Collectors.toList()));
		} else {
			return IScope.NULLSCOPE;
		}

	}

	public IScope scopeForGipsMapping(GipsMapping context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getAllEditorPatterns(context));
	}

	public IScope scopeForGipsMappingVariableType(GipsMappingVariable context, EReference reference) {
		return Scopes.scopeFor(variableDataTypes);
	}

	public IScope scopeForGipsMappingVariableParameter(GipsMappingVariable context, EReference reference) {
		if (context.getType() == null)
			return IScope.NULLSCOPE;

		GipsMapping mapping = GTEditorPatternUtils.getContainer(context, GipsMappingImpl.class);
		if (mapping == null)
			return IScope.NULLSCOPE;

		EditorPattern pattern = mapping.getPattern();
		if (pattern == null)
			return IScope.NULLSCOPE;

		if (pattern.getParameters() == null || pattern.getParameters().isEmpty())
			return IScope.NULLSCOPE;

		// TODO: Exclude parameters that are not exclusively used in attribute
		// assignments (i.e. parameters used in conditions for pattern matching)
		return Scopes.scopeFor(pattern.getParameters().stream()
				.filter(param -> variableDataTypes.contains(param.getType())).collect(Collectors.toList()));
	}

	public IScope scopeForGipsVariableReferenceExpression(GipsVariableReferenceExpression context,
			EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context,
				Set.of(GipsValueExpressionImpl.class, GipsTransformOperationImpl.class));

		if (container instanceof GipsValueExpression root) {
			if (root.getValue() instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
						&& !mapping.getMapping().getVariables().isEmpty()) {
					return Scopes.scopeFor(mapping.getMapping().getVariables());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (root.getValue() instanceof GipsLocalContextExpression local) {
				if (!GipslScopeContextUtil.hasLocalContext(local)) {
					return IScope.NULLSCOPE;
				}
				EObject localContext = GipslScopeContextUtil.getLocalContext(local);
				if (localContext instanceof GipsMapping mapping) {
					if (mapping.getVariables() != null && !mapping.getVariables().isEmpty()) {
						return Scopes.scopeFor(mapping.getVariables());
					} else {
						return IScope.NULLSCOPE;
					}
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (root.getValue() instanceof GipsSetElementExpression setElement) {
				EObject setContext = GipslScopeContextUtil.getSetContext(setElement);
				if (setContext instanceof GipsMappingExpression mapping) {
					if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
							&& !mapping.getMapping().getVariables().isEmpty()) {
						return Scopes.scopeFor(mapping.getMapping().getVariables());
					} else {
						return IScope.NULLSCOPE;
					}
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (container instanceof GipsTransformOperation root) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
						&& !mapping.getMapping().getVariables().isEmpty()) {
					return Scopes.scopeFor(mapping.getMapping().getVariables());
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}

	}

	private IScope scopeForGipsTypeExtension(GipsTypeExtension context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

	public IScope scopeForGipsTypeExtensionVariableType(GipsTypeExtensionVariable context, EReference reference) {
		return Scopes.scopeFor(variableDataTypes);
	}

	public IScope scopeForGipsConstantReference(GipsConstantReference context, EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context, Set.of(EditorGTFileImpl.class,
				GipsConstraintImpl.class, GipsLinearFunctionImpl.class, GipsObjectiveImpl.class));
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		List<GipsConstant> constants = new LinkedList<>();
		constants.addAll(editorFile.getConstants());

		if (container instanceof GipsConstraint constraint) {
			constants.addAll(constraint.getConstants());
		} else if (container instanceof GipsLinearFunction function) {
			constants.addAll(function.getConstants());
		} else if (container instanceof GipsObjective objective) {
			constants.addAll(objective.getConstants());
		}

		return Scopes.scopeFor(constants);
	}

	public IScope scopeForGipsConstraintContext(GipsConstraint context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		List<EObject> allContext = new LinkedList<>();
		allContext.addAll(editorFile.getMappings());
		allContext.addAll(GipslScopeContextUtil.getClasses(context));
		allContext.addAll(GipslScopeContextUtil.getAllEditorPatterns(context));
		return Scopes.scopeFor(allContext);
	}

	public IScope scopeForGipsLinearFunctionContext(GipsLinearFunction context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		List<EObject> allContext = new LinkedList<>();
		allContext.addAll(editorFile.getMappings());
		allContext.addAll(GipslScopeContextUtil.getClasses(context));
		allContext.addAll(GipslScopeContextUtil.getAllEditorPatterns(context));
		return Scopes.scopeFor(allContext);
	}

	public IScope scopeForGipsLinearFunctionReference(GipsLinearFunctionReference context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getFunctions());
	}

	public IScope scopeForGipsMappingExpression(GipsMappingExpression context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getMappings());
	}

	public IScope scopeForGipsTypeExpression(GipsTypeExpression context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

	public IScope scopeForGipsPatternExpression(GipsPatternExpression context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getPatterns(context));
	}

	public IScope scopeForGipsRuleExpression(GipsRuleExpression context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getRules(context));
	}

	public IScope scopeForGipsNodeExpression(GipsNodeExpression context, EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context, Set.of(
				GipsLocalContextExpressionImpl.class, GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class));

		EditorPattern editorPattern = null;

		if (container instanceof GipsLocalContextExpression root) {
			if (!GipslScopeContextUtil.hasLocalContext(root)) {
				return IScope.NULLSCOPE;
			}
			EObject localContext = GipslScopeContextUtil.getLocalContext(root);
			if (localContext instanceof GipsMapping mapping) {
				if (mapping.getPattern() != null) {
					editorPattern = mapping.getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (localContext instanceof EditorPattern) {
				editorPattern = (EditorPattern) localContext;
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (container instanceof GipsSetElementExpression || container instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(container);
			if (setContext instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getPattern() != null) {
					editorPattern = mapping.getMapping().getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsPatternExpression pattern) {
				if (pattern.getPattern() != null) {
					editorPattern = pattern.getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsRuleExpression rule) {
				if (rule.getRule() != null) {
					editorPattern = rule.getRule();
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}

		return Scopes.scopeFor(editorPattern.getNodes().stream().filter(n -> n.getOperator() != EditorOperator.CREATE)
				.collect(Collectors.toList()));
	}

	public IScope scopeForGipsJoin(GipsJoinBySelectionOperation context, EReference reference) {
		EObject localContext = GipslScopeContextUtil.getLocalContext(context);
		EObject setContext = GipslScopeContextUtil.getSetContext(context);

		if (setContext instanceof GipsTypeExpression typeExpression) {
			// provide context 'nodes' to choose from
			EditorPattern editorPattern = GipslScopeContextUtil.getPatternOrRuleOf(localContext);
			if (editorPattern == null)
				return IScope.NULLSCOPE;
			return Scopes.scopeFor(editorPattern.getNodes().stream() //
					.filter(n -> n.getOperator() != EditorOperator.CREATE) //
					.filter(n -> typeExpression.getType().isSuperTypeOf(n.getType())
							|| n.getType().isSuperTypeOf(typeExpression.getType())) //
					.toList());
		}

		if (localContext instanceof EClass eClass) {
			// provide set 'nodes' to choose from
			EditorPattern editorPattern = GipslScopeContextUtil.getPatternOrRuleOf(setContext);
			if (editorPattern == null)
				return IScope.NULLSCOPE;

			return Scopes.scopeFor(editorPattern.getNodes().stream() //
					.filter(n -> n.getOperator() != EditorOperator.CREATE) //
					.filter(n -> eClass.isSuperTypeOf(n.getType()) || n.getType().isSuperTypeOf(eClass)) //
					.toList());
		}

		// we don't give suggestion for possible tuples
		return IScope.NULLSCOPE;
	}

	public IScope scopeForGipsJoinPair(GipsJoinPairSelection context, EReference reference) {
		EObject patternRef = null;

		// left side relates to the set on which we are operating. The right side
		// relates to the context.
		if (reference == GipslPackage.Literals.GIPS_JOIN_PAIR_SELECTION__LEFT_NODE) {
			patternRef = GipslScopeContextUtil.getSetContext(context);
		} else if (reference == GipslPackage.Literals.GIPS_JOIN_PAIR_SELECTION__RIGHT_NODE) {
			patternRef = GipslScopeContextUtil.getLocalContext(context);
		}

		EditorPattern editorPattern = GipslScopeContextUtil.getPatternOrRuleOf(patternRef);
		if (editorPattern == null)
			return IScope.NULLSCOPE;

		return Scopes.scopeFor(editorPattern.getNodes().stream() //
				.filter(n -> n.getOperator() != EditorOperator.CREATE) //
				.toList());
	}

	public IScope scopeForGipsJoinSingle(GipsJoinSingleSelection context, EReference reference) {
		EObject localContext = GipslScopeContextUtil.getLocalContext(context);
		EObject setContext = GipslScopeContextUtil.getSetContext(context);
		EObject patternRef = null;

		if (setContext instanceof GipsTypeExpression) {
			patternRef = localContext;
		} else {
			patternRef = setContext;
		}

		EditorPattern editorPattern = GipslScopeContextUtil.getPatternOrRuleOf(patternRef);
		if (editorPattern == null)
			return IScope.NULLSCOPE;

		return Scopes.scopeFor(editorPattern.getNodes().stream() //
				.filter(n -> n.getOperator() != EditorOperator.CREATE) //
				.toList());
	}

	public IScope scopeForGipsAttributeExpression(GipsAttributeExpression context, EReference reference) {
		EObject root = null;
		if (context.eContainer() != null && context.eContainer().eContainer() != null
				&& context.eContainer().eContainer() instanceof GipsAttributeExpression previous
				&& previous.getAttribute() != null) {
			root = previous;
		} else {
			root = (EObject) GipslScopeContextUtil.getContainer(context,
					Set.of(GipsNodeExpressionImpl.class, GipsLocalContextExpressionImpl.class,
							GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class,
							GipsAttributeExpressionImpl.class));
		}

		if (root instanceof GipsNodeExpression node) {
			if (node.getNode() != null && node.getNode().getType() != null) {
				return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsAttributeExpression attribute) {
			if (attribute.getAttribute().getLiteral().getEType() instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsLocalContextExpression local) {
			EObject localContext = GipslScopeContextUtil.getLocalContext(local);
			if (localContext instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsSetElementExpression || root instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsTypeExpression type) {
				if (type.getType() != null) {
					return Scopes.scopeFor(type.getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}
	}

	public IScope scopeForGipsAttributeLiteral(GipsAttributeLiteral context, EReference reference) {
		EObject root = null;
		if (context.eContainer() != null && context.eContainer().eContainer() != null
				&& context.eContainer().eContainer() instanceof GipsAttributeExpression previous
				&& previous.getAttribute() != null) {
			root = previous;
		} else {
			root = (EObject) GipslScopeContextUtil.getContainer(context,
					Set.of(GipsNodeExpressionImpl.class, GipsLocalContextExpressionImpl.class,
							GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class));
		}

		if (root instanceof GipsNodeExpression node) {
			if (node.getNode() != null && node.getNode().getType() != null) {
				return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsAttributeExpression attribute) {
			if (attribute.getAttribute().getLiteral().getEType() instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsLocalContextExpression local) {
			EObject localContext = GipslScopeContextUtil.getLocalContext(local);
			if (localContext instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsSetElementExpression || root instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsTypeExpression type) {
				if (type.getType() != null) {
					return Scopes.scopeFor(type.getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}
	}

	public IScope getlastAttributeScope(GipsAttributeExpression attribute) {
		if (attribute == null) {
			return IScope.NULLSCOPE;
		}

		if (attribute.getRight() != null) {
			return getlastAttributeScope(attribute.getRight());
		} else {
			if (attribute.getAttribute() != null && attribute.getAttribute().getLiteral() != null
					&& attribute.getAttribute().getLiteral().getEType() instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		}
	}

	public IScope scopeForGipsTypeSelect(GipsTypeSelect context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

	public IScope scopeForGipsTypeQuery(GipsTypeQuery context, EReference reference) {
		return Scopes.scopeFor(GipslScopeContextUtil.getClasses(context));
	}

}
