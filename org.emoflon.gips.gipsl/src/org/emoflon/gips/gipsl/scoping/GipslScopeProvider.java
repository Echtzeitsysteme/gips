/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.scoping;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.emoflon.gips.gipsl.gipsl.EditorFile;
import org.emoflon.gips.gipsl.gipsl.GipsAttributeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsAttributeLiteral;
import org.emoflon.gips.gipsl.gipsl.GipsConstant;
import org.emoflon.gips.gipsl.gipsl.GipsConstantReference;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunctionReference;
import org.emoflon.gips.gipsl.gipsl.GipsLocalContextExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable;
import org.emoflon.gips.gipsl.gipsl.GipsNodeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression;
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSetElementExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSortPredicate;
import org.emoflon.gips.gipsl.gipsl.GipsTransformOperation;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsTypeQuery;
import org.emoflon.gips.gipsl.gipsl.GipsTypeSelect;
import org.emoflon.gips.gipsl.gipsl.GipsValueExpression;
import org.emoflon.gips.gipsl.gipsl.GipsVariableReferenceExpression;
import org.emoflon.gips.gipsl.gipsl.impl.EditorFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsAttributeExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstraintImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLinearFunctionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLocalContextExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsMappingImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsNodeExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsObjectiveImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSetElementExpressionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSortPredicateImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsTransformOperationImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsValueExpressionImpl;
import org.emoflon.gips.gipsl.util.GipslResourceManager;
import org.emoflon.ibex.common.slimgt.util.SlimGTModelUtil;
import org.emoflon.ibex.gt.gtl.gTL.SlimParameter;
import org.emoflon.ibex.gt.gtl.gTL.SlimRule;
import org.emoflon.ibex.gt.gtl.scoping.GTLScopeProvider;
import org.emoflon.ibex.gt.gtl.util.GTLModelUtil;

/**
 * This class contains custom scoping description.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class GipslScopeProvider extends GTLScopeProvider {

	final public static Set<EDataType> variableDataTypes = Set.of(EcorePackage.Literals.EDOUBLE,
			EcorePackage.Literals.EFLOAT, EcorePackage.Literals.EINT, EcorePackage.Literals.ELONG,
			EcorePackage.Literals.ESHORT, EcorePackage.Literals.EBYTE, EcorePackage.Literals.EBOOLEAN);

	final protected GipslResourceManager gipslManager;

	public GipslScopeProvider() {
		super(new GipslResourceManager());
		gipslManager = (GipslResourceManager) gtlManager;
	}

	public GipslScopeProvider(GipslResourceManager gipslManager) {
		super(gipslManager);
		this.gipslManager = gipslManager;
	}

	@Override
	public IScope getScope(EObject context, EReference reference) {
		try {
			return getScopeInternal(context, reference);
		} catch (Exception e) {
			e.printStackTrace();
			return IScope.NULLSCOPE;
		}
	}

	public IScope getScopeInternal(EObject context, EReference reference) throws Exception {
		if (GipslScopeContextUtil.isGipsMapping(context, reference)) {
			return scopeForGipsMapping((GipsMapping) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingVariableType(context, reference)) {
			return scopeForGipsMappingVariableType((GipsMappingVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingVariableParameter(context, reference)) {
			return scopeForGipsMappingVariableParameter((GipsMappingVariable) context, reference);
		} else if (GipslScopeContextUtil.isGipsConstantReference(context, reference)) {
			return scopeForGipsConstantReference((GipsConstantReference) context, reference);
		} else if (GipslScopeContextUtil.isGipsVariableReferenceExpression(context, reference)) {
			return scopeForGipsVariableReferenceExpression((GipsVariableReferenceExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsConstraintContext(context, reference)) {
			return scopeForGipsConstraintContext((GipsConstraint) context, reference);
		} else if (GipslScopeContextUtil.isGipsLinearFunctionContext(context, reference)) {
			return scopeForGipsLinearFunctionContext((GipsLinearFunction) context, reference);
		} else if (GipslScopeContextUtil.isGipsLinearFunctionReference(context, reference)) {
			return scopeForGipsLinearFunctionReference((GipsLinearFunctionReference) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingExpression(context, reference)) {
			return scopeForGipsMappingExpression((GipsMappingExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeExpression(context, reference)) {
			return scopeForGipsTypeExpression((GipsTypeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsPatternExpression(context, reference)) {
			return scopeForGipsPatternExpression((GipsPatternExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsRuleExpression(context, reference)) {
			return scopeForGipsRuleExpression((GipsRuleExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsNodeExpression(context, reference)) {
			return scopeForGipsNodeExpression((GipsNodeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsAttributeExpression(context, reference)) {
			return scopeForGipsAttributeExpression((GipsAttributeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsAttributeLiteral(context, reference)) {
			return scopeForGipsAttributeLiteral((GipsAttributeLiteral) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeSelect(context, reference)) {
			return scopeForGipsTypeSelect((GipsTypeSelect) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeQuery(context, reference)) {
			return scopeForGipsTypeQuery((GipsTypeQuery) context, reference);
		}

		return super.getScopeInternal(context, reference);
	}

	public IScope scopeForGipsMapping(GipsMapping context, EReference reference) {
		EditorFile currentFile = SlimGTModelUtil.getContainer(context, EditorFile.class);
		if (currentFile == null)
			return IScope.NULLSCOPE;

		return Scopes.scopeFor(gtlManager.getAllRulesInScope(currentFile));
	}

	public IScope scopeForGipsMappingVariableType(GipsMappingVariable context, EReference reference) {
		return Scopes.scopeFor(variableDataTypes);
	}

	public IScope scopeForGipsMappingVariableParameter(GipsMappingVariable context, EReference reference) {
		if (context.getType() == null)
			return IScope.NULLSCOPE;

		GipsMapping mapping = SlimGTModelUtil.getContainer(context, GipsMappingImpl.class);
		if (mapping == null)
			return IScope.NULLSCOPE;

		SlimRule pattern = mapping.getPattern();

		if (pattern == null)
			return IScope.NULLSCOPE;

		Collection<SlimParameter> parameters = GTLModelUtil.getAllParameters(pattern);
		if (parameters == null || parameters.isEmpty())
			return IScope.NULLSCOPE;

		// TODO: Exclude parameters that are not exclusively used in attribute
		// assignments (i.e. parameters used in conditions for pattern matching)
		return Scopes.scopeFor(parameters.stream().filter(param -> variableDataTypes.contains(param.getType()))
				.collect(Collectors.toList()));
	}

	public IScope scopeForGipsVariableReferenceExpression(GipsVariableReferenceExpression context,
			EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context,
				Set.of(GipsValueExpressionImpl.class, GipsTransformOperationImpl.class));

		if (container instanceof GipsValueExpression root) {
			if (root.getValue() instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
						&& !mapping.getMapping().getVariables().isEmpty()) {
					return Scopes.scopeFor(mapping.getMapping().getVariables());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (root.getValue() instanceof GipsLocalContextExpression local) {
				if (!GipslScopeContextUtil.hasLocalContext(local)) {
					return IScope.NULLSCOPE;
				}
				EObject localContext = GipslScopeContextUtil.getLocalContext(local);
				if (localContext instanceof GipsMapping mapping) {
					if (mapping.getVariables() != null && !mapping.getVariables().isEmpty()) {
						return Scopes.scopeFor(mapping.getVariables());
					} else {
						return IScope.NULLSCOPE;
					}
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (root.getValue() instanceof GipsSetElementExpression setElement) {
				EObject setContext = GipslScopeContextUtil.getSetContext(setElement);
				if (setContext instanceof GipsMappingExpression mapping) {
					if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
							&& !mapping.getMapping().getVariables().isEmpty()) {
						return Scopes.scopeFor(mapping.getMapping().getVariables());
					} else {
						return IScope.NULLSCOPE;
					}
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (container instanceof GipsTransformOperation root) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getVariables() != null
						&& !mapping.getMapping().getVariables().isEmpty()) {
					return Scopes.scopeFor(mapping.getMapping().getVariables());
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}

	}

	public IScope scopeForGipsConstantReference(GipsConstantReference context, EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context, Set.of(EditorFileImpl.class,
				GipsConstraintImpl.class, GipsLinearFunctionImpl.class, GipsObjectiveImpl.class));
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		Collection<GipsConstant> constants = gipslManager.getAllConstantsInScope(editorFile);

		if (container instanceof GipsConstraint constraint) {
			constants.addAll(constraint.getConstants());
		} else if (container instanceof GipsLinearFunction function) {
			constants.addAll(function.getConstants());
		} else if (container instanceof GipsObjective objective) {
			constants.addAll(objective.getConstants());
		}

		return Scopes.scopeFor(constants);

	}

	public IScope scopeForGipsConstraintContext(GipsConstraint context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		List<EObject> allContext = new LinkedList<>();
		allContext.addAll(gipslManager.getAllMappingsInScope(editorFile));
		allContext.addAll(SlimGTModelUtil.getClasses(editorFile));
		allContext.addAll(gipslManager.getAllRulesInScope(editorFile));
		return Scopes.scopeFor(allContext);
	}

	public IScope scopeForGipsLinearFunctionContext(GipsLinearFunction context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		List<EObject> allContext = new LinkedList<>();
		allContext.addAll(gipslManager.getAllMappingsInScope(editorFile));
		allContext.addAll(SlimGTModelUtil.getClasses(editorFile));
		allContext.addAll(gipslManager.getAllRulesInScope(editorFile));
		return Scopes.scopeFor(allContext);
	}

	public IScope scopeForGipsLinearFunctionReference(GipsLinearFunctionReference context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(gipslManager.getAllFunctionsInScope(editorFile));
	}

	public IScope scopeForGipsMappingExpression(GipsMappingExpression context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(gipslManager.getAllMappingsInScope(editorFile));
	}

	public IScope scopeForGipsTypeExpression(GipsTypeExpression context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(SlimGTModelUtil.getClasses(editorFile));
	}

	public IScope scopeForGipsPatternExpression(GipsPatternExpression context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(gipslManager.getAllTruePatternsInScope(editorFile));
	}

	public IScope scopeForGipsRuleExpression(GipsRuleExpression context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(gipslManager.getAllTrueRulesInScope(editorFile));
	}

	public IScope scopeForGipsNodeExpression(GipsNodeExpression context, EReference reference) {
		EObject container = (EObject) GipslScopeContextUtil.getContainer(context, Set.of(
				GipsLocalContextExpressionImpl.class, GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class));

		SlimRule slimRule = null;

		if (container instanceof GipsLocalContextExpression root) {
			if (!GipslScopeContextUtil.hasLocalContext(root)) {
				return IScope.NULLSCOPE;
			}
			EObject localContext = GipslScopeContextUtil.getLocalContext(root);
			if (localContext instanceof GipsMapping mapping) {
				if (mapping.getPattern() != null) {
					slimRule = mapping.getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (localContext instanceof SlimRule) {
				slimRule = (SlimRule) localContext;
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (container instanceof GipsSetElementExpression || container instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(container);
			if (setContext instanceof GipsMappingExpression mapping) {
				if (mapping.getMapping() != null && mapping.getMapping().getPattern() != null) {
					slimRule = mapping.getMapping().getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsPatternExpression pattern) {
				if (pattern.getPattern() != null) {
					slimRule = pattern.getPattern();
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsRuleExpression rule) {
				if (rule.getRule() != null) {
					slimRule = rule.getRule();
				} else {
					return IScope.NULLSCOPE;
				}
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}

		return Scopes.scopeFor(GTLModelUtil.getAllDeletedAndContextRuleNodesNoLocals(slimRule));
	}

	public IScope scopeForGipsAttributeExpression(GipsAttributeExpression context, EReference reference) {
		EObject root = null;
		if (context.eContainer() != null && context.eContainer().eContainer() != null
				&& context.eContainer().eContainer() instanceof GipsAttributeExpression previous
				&& previous.getAttribute() != null) {
			root = previous;
		} else {
			root = (EObject) GipslScopeContextUtil.getContainer(context,
					Set.of(GipsNodeExpressionImpl.class, GipsLocalContextExpressionImpl.class,
							GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class,
							GipsAttributeExpressionImpl.class));
		}

		if (root instanceof GipsNodeExpression node) {
			if (node.getNode() != null && node.getNode().getType() != null) {
				return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsAttributeExpression attribute) {
			if (attribute.getAttribute().getLiteral().getEType() instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsLocalContextExpression local) {
			EObject localContext = GipslScopeContextUtil.getLocalContext(local);
			if (localContext instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsSetElementExpression || root instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsTypeExpression type) {
				if (type.getType() != null) {
					return Scopes.scopeFor(type.getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}
	}

	public IScope scopeForGipsAttributeLiteral(GipsAttributeLiteral context, EReference reference) {
		EObject root = null;
		if (context.eContainer() != null && context.eContainer().eContainer() != null
				&& context.eContainer().eContainer() instanceof GipsAttributeExpression previous
				&& previous.getAttribute() != null) {
			root = previous;
		} else {
			root = (EObject) GipslScopeContextUtil.getContainer(context,
					Set.of(GipsNodeExpressionImpl.class, GipsLocalContextExpressionImpl.class,
							GipsSetElementExpressionImpl.class, GipsSortPredicateImpl.class));
		}

		if (root instanceof GipsNodeExpression node) {
			if (node.getNode() != null && node.getNode().getType() != null) {
				return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsAttributeExpression attribute) {
			if (attribute.getAttribute().getLiteral().getEType() instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsLocalContextExpression local) {
			EObject localContext = GipslScopeContextUtil.getLocalContext(local);
			if (localContext instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		} else if (root instanceof GipsSetElementExpression || root instanceof GipsSortPredicate) {
			EObject setContext = GipslScopeContextUtil.getSetContext(root);
			if (setContext instanceof GipsTypeExpression type) {
				if (type.getType() != null) {
					return Scopes.scopeFor(type.getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsLocalContextExpression lce
					&& lce.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() == null) {
				if (node.getNode() != null && node.getNode().getType() != null) {
					return Scopes.scopeFor(node.getNode().getType().getEAllStructuralFeatures());
				} else {
					return IScope.NULLSCOPE;
				}
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsNodeExpression node
					&& node.getAttributeExpression() != null) {
				return getlastAttributeScope(node.getAttributeExpression());
			} else if (setContext instanceof GipsSetElementExpression see
					&& see.getExpression() instanceof GipsAttributeExpression attribute) {
				return getlastAttributeScope(attribute);
			} else {
				return IScope.NULLSCOPE;
			}
		} else {
			return IScope.NULLSCOPE;
		}
	}

	public IScope getlastAttributeScope(GipsAttributeExpression attribute) {
		if (attribute == null) {
			return IScope.NULLSCOPE;
		}

		if (attribute.getRight() != null) {
			return getlastAttributeScope(attribute.getRight());
		} else {
			if (attribute.getAttribute() != null && attribute.getAttribute().getLiteral() != null
					&& attribute.getAttribute().getLiteral().getEType() instanceof EClass cls) {
				return Scopes.scopeFor(cls.getEAllStructuralFeatures());
			} else {
				return IScope.NULLSCOPE;
			}
		}
	}

	public IScope scopeForGipsTypeSelect(GipsTypeSelect context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(SlimGTModelUtil.getClasses(editorFile));
	}

	public IScope scopeForGipsTypeQuery(GipsTypeQuery context, EReference reference) {
		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(context, EditorFileImpl.class);
		return Scopes.scopeFor(SlimGTModelUtil.getClasses(editorFile));
	}

}
