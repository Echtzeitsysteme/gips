/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.scoping;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.emoflon.gips.gipsl.gipsl.EditorGTFile;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsContextExpr;
import org.emoflon.gips.gipsl.gipsl.GipsFeatureExpr;
import org.emoflon.gips.gipsl.gipsl.GipsFeatureLit;
import org.emoflon.gips.gipsl.gipsl.GipsFeatureNavigation;
import org.emoflon.gips.gipsl.gipsl.GipsLambdaAttributeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsLambdaSelfExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsMappingContext;
import org.emoflon.gips.gipsl.gipsl.GipsNodeAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsPatternAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsPatternContext;
import org.emoflon.gips.gipsl.gipsl.GipsSelect;
import org.emoflon.gips.gipsl.gipsl.GipsStreamArithmetic;
import org.emoflon.gips.gipsl.gipsl.GipsStreamNavigation;
import org.emoflon.gips.gipsl.gipsl.GipsStreamSet;
import org.emoflon.gips.gipsl.gipsl.GipsTypeAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsTypeCast;
import org.emoflon.gips.gipsl.gipsl.GipsTypeContext;
import org.emoflon.gips.gipsl.gipsl.impl.EditorGTFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstraintImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsContextExprImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsMappingAttributeExprImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsNodeAttributeExprImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsObjectiveImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsPatternAttributeExprImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsSelectImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsStreamArithmeticImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsStreamNavigationImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsStreamSetImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsTypeAttributeExprImpl;
import org.emoflon.ibex.gt.editor.gT.EditorOperator;
import org.emoflon.ibex.gt.editor.utils.GTEditorModelUtils;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;

/**
 * This class contains custom scoping description.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class GipslScopeProvider extends AbstractGipslScopeProvider {

	@Override
	public IScope getScope(EObject context, EReference reference) {
		try {
			return getScopeInternal(context, reference);
		} catch (Exception e) {
			e.printStackTrace();
			return super.getScope(context, reference);
		}
	}

	public IScope getScopeInternal(EObject context, EReference reference) throws Exception {
		if (GipslScopeContextUtil.isGipsMapping(context, reference)) {
			return scopeForGipsMapping((GipsMapping) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingContext(context, reference)) {
			return scopeForGipsMappingContext((GipsMappingContext) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeContext(context, reference)) {
			return scopeForGipsTypeContext((GipsTypeContext) context, reference);
		} else if (GipslScopeContextUtil.isGipsPatternContext(context, reference)) {
			return scopeForGipsPatternContext((GipsPatternContext) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingAttributeExprMapping(context, reference)) {
			return scopeForGipsMappingAttributeExprMapping((GipsMappingAttributeExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsPatternAttributeExprMapping(context, reference)) {
			return scopeForGipsPatternAttributeExprMapping((GipsPatternAttributeExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeAttributeExprMapping(context, reference)) {
			return scopeForGipsTypeAttributeExprMapping((GipsTypeAttributeExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsMappingAttributeExprNode(context, reference)) {
			return scopeForGipsMappingAttributeExprNode((GipsMappingAttributeExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsContextExprNode(context, reference)) {
			return scopeForGipsContextExprNode((GipsContextExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsContextExprFeature(context, reference)) {
			return scopeForGipsContextExprFeature((GipsContextExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsLambdaAttributeExpressionVariable(context, reference)) {
			return scopeForGipsLambdaAttributeExpressionVariable((GipsLambdaAttributeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsLambdaSelfExpressionVariable(context, reference)) {
			return scopeForGipsLambdaSelfExpressionVariable((GipsLambdaSelfExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsLambdaAttributeExpression(context, reference)) {
			return scopeForGipsLambdaAttributeExpression((GipsLambdaAttributeExpression) context, reference);
		} else if (GipslScopeContextUtil.isGipsSelect(context, reference)) {
			return scopeForGipsSelect((GipsSelect) context, reference);
		} else if (GipslScopeContextUtil.isGipsNodeAttributeExprNode(context, reference)) {
			return scopeForGipsNodeAttributeExprNode((GipsNodeAttributeExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsNodeAttributeExprFeature(context, reference)) {
			return scopeForGipsNodeAttributeExprFeature((GipsNodeAttributeExpr) context, reference);
		} else if (GipslScopeContextUtil.isGipsFeatureNavigationFeature(context, reference)) {
			return scopeForGipsFeatureNavigationFeature((GipsFeatureNavigation) context, reference);
		} else if (GipslScopeContextUtil.isGipsFeatureLit(context, reference)) {
			return scopeForGipsFeatureLit((GipsFeatureLit) context, reference);
		} else if (GipslScopeContextUtil.isGipsTypeCast(context, reference)) {
			return scopeForGipsTypeCast((GipsTypeCast) context, reference);
		}

		else {
			return super.getScope(context, reference);
		}
	}

	private IScope scopeForGipsPatternContext(GipsPatternContext context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getPatterns());
	}

	public IScope scopeForGipsMapping(GipsMapping context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getPatterns());
	}

	public IScope scopeForGipsMappingContext(GipsMappingContext context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getMappings());
	}

	public IScope scopeForGipsTypeContext(GipsTypeContext context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile));
	}

	public IScope scopeForGipsMappingAttributeExprMapping(GipsMappingAttributeExpr context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getMappings());
	}

	public IScope scopeForGipsMappingAttributeExprNode(GipsMappingAttributeExpr context, EReference reference) {
		return Scopes.scopeFor(context.getMapping().getPattern().getNodes());
	}

	private IScope scopeForGipsTypeAttributeExprMapping(GipsTypeAttributeExpr context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile));
	}

	private IScope scopeForGipsPatternAttributeExprMapping(GipsPatternAttributeExpr context, EReference reference) {
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
		return Scopes.scopeFor(editorFile.getPatterns());
	}

	public IScope scopeForGipsContextExprNode(GipsContextExpr context, EReference reference) {
		EObject contextType = null;
		GipsConstraint parent = GTEditorPatternUtils.getContainer(context, GipsConstraintImpl.class);
		if (parent != null) {
			contextType = parent.getContext();
		} else {
			GipsObjective parentAlt = GTEditorPatternUtils.getContainer(context, GipsObjectiveImpl.class);
			if (parentAlt != null) {
				contextType = parentAlt.getContext();
			} else {
				return super.getScope(context, reference);
			}
		}

		if (contextType instanceof GipsMappingContext mappingContext) {
			// Return context nodes only!
			return Scopes.scopeFor(mappingContext.getMapping().getPattern().getNodes().stream()
					.filter(node -> !node.isLocal() && node.getOperator() != EditorOperator.CREATE)
					.collect(Collectors.toList()));
		} else if (contextType instanceof GipsPatternContext patternContext) {
			// Return context nodes only!
			return Scopes.scopeFor(patternContext.getPattern().getNodes().stream()
					.filter(node -> !node.isLocal() && node.getOperator() != EditorOperator.CREATE)
					.collect(Collectors.toList()));
		} else {
			return super.getScope(context, reference);
		}
	}

	public IScope scopeForGipsLambdaAttributeExpressionVariable(GipsLambdaAttributeExpression context,
			EReference reference) {
		Set<Class<?>> classes = Set.of(GipsStreamSetImpl.class, GipsStreamArithmeticImpl.class);
		EObject parent = (EObject) GipslScopeContextUtil.getContainer(context, classes);
		if (parent == null) {
			return super.getScope(context, reference);
		}

		if (parent instanceof GipsStreamSet streamSet) {
			return Scopes.scopeFor(List.of(streamSet.getLambda()));
		} else {
			GipsStreamArithmetic streamArithmetic = (GipsStreamArithmetic) parent;
			return Scopes.scopeFor(List.of(streamArithmetic.getLambda()));
		}
	}

	private IScope scopeForGipsLambdaSelfExpressionVariable(GipsLambdaSelfExpression context, EReference reference) {
		Set<Class<?>> classes = Set.of(GipsStreamSetImpl.class, GipsStreamArithmeticImpl.class);
		EObject parent = (EObject) GipslScopeContextUtil.getContainer(context, classes);
		if (parent == null) {
			return super.getScope(context, reference);
		}

		if (parent instanceof GipsStreamSet streamSet) {
			return Scopes.scopeFor(List.of(streamSet.getLambda()));
		} else {
			GipsStreamArithmetic streamArithmetic = (GipsStreamArithmetic) parent;
			return Scopes.scopeFor(List.of(streamArithmetic.getLambda()));
		}
	}

	public IScope scopeForGipsLambdaAttributeExpression(GipsLambdaAttributeExpression context, EReference reference) {
		Set<Class<?>> classes = Set.of(GipsContextExprImpl.class, GipsMappingAttributeExprImpl.class,
				GipsPatternAttributeExprImpl.class, GipsTypeAttributeExprImpl.class, GipsStreamNavigationImpl.class,
				GipsStreamSetImpl.class, GipsSelectImpl.class, GipsStreamArithmeticImpl.class);
		EObject parent = (EObject) GipslScopeContextUtil.getContainer(context, classes);
		if (parent == null) {
			return super.getScope(context, reference);
		}

		while (parent != null) {
			if (parent instanceof GipsSelect select) {
				return Scopes.scopeFor(((EClass) select.getType()).getEAllStructuralFeatures());
			} else if (parent instanceof GipsMappingAttributeExpr mapping) {
				return Scopes.scopeFor(mapping.getMapping().getPattern().getNodes());
			} else if (parent instanceof GipsPatternAttributeExpr pattern) {
				return Scopes.scopeFor(pattern.getPattern().getNodes());
			} else if (parent instanceof GipsTypeAttributeExpr type) {
				return Scopes.scopeFor(type.getType().getEAllStructuralFeatures());
			} else if (parent instanceof GipsContextExpr contextExpr) {
				if (contextExpr.getExpr() != null) {
					if (contextExpr.getExpr() instanceof GipsNodeAttributeExpr nodeExpr) {
						GipsFeatureExpr expr = GipslScopeContextUtil.findLeafExpression(nodeExpr.getExpr());
						if (expr instanceof GipsFeatureLit lit) {
							EClass clazz = (EClass) lit.getFeature().getEType();
							return Scopes.scopeFor(clazz.getEAllStructuralFeatures());
						} else {
							return super.getScope(context, reference);
						}
					} else if (contextExpr.getExpr() instanceof GipsFeatureExpr featExpr) {
						GipsFeatureExpr expr = GipslScopeContextUtil.findLeafExpression(featExpr);
						if (expr instanceof GipsFeatureLit lit) {
							EClass clazz = (EClass) lit.getFeature().getEType();
							return Scopes.scopeFor(clazz.getEAllStructuralFeatures());
						} else {
							return super.getScope(context, reference);
						}
					} else {
						return super.getScope(context, reference);
					}
				} else {
					return super.getScope(context, reference);
				}
			} else if (parent instanceof GipsStreamNavigation nav) {
				if (nav.getLeft() instanceof GipsSelect select) {
					return Scopes.scopeFor(((EClass) select.getType()).getEAllStructuralFeatures());
				} else {
					parent = (EObject) GipslScopeContextUtil.getContainer(parent, classes);
				}
			} else {
				parent = (EObject) GipslScopeContextUtil.getContainer(parent, classes);
			}
			// TODO: Traverese nested stream expressions recursively to derive the current
			// type
		}

		// TODO: For now we'll exit this gracefully if anything unexpected occurs
		return super.getScope(context, reference);
	}

	public IScope scopeForGipsSelect(GipsSelect context, EReference reference) {
		Set<Class<?>> classes = Set.of(GipsContextExprImpl.class, GipsMappingAttributeExprImpl.class,
				GipsPatternAttributeExprImpl.class, GipsTypeAttributeExprImpl.class, GipsNodeAttributeExprImpl.class);
		EObject parent = (EObject) GipslScopeContextUtil.getContainer(context, classes);
		if (parent instanceof GipsMappingAttributeExpr || parent instanceof GipsPatternAttributeExpr) {
			// TODO: Find all rules that refine the rule that corresponds to this mapping
			// TODO: Deactivated for now, since we do not support rule inheritance in any
			// meaningful way
			// return Scopes.scopeFor(List.of(mapping.getMapping().getRule()));
			return super.getScope(context, reference);
		} else if (parent instanceof GipsTypeAttributeExpr typeExpr) {
			EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
			return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile).stream()
					.filter(c -> c.getEAllSuperTypes().contains(typeExpr.getType())).collect(Collectors.toSet()));
		} else if (parent instanceof GipsContextExpr contextExpr) {
			if (contextExpr.getExpr() != null) {
				if (contextExpr.getExpr() instanceof GipsNodeAttributeExpr nodeExpr) {
					GipsFeatureExpr expr = GipslScopeContextUtil.findLeafExpression(nodeExpr.getExpr());
					if (expr instanceof GipsFeatureLit lit) {
						EClass clazz = (EClass) lit.getFeature().getEType();
						EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
						return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile).stream()
								.filter(c -> c.getEAllSuperTypes().contains(clazz)).collect(Collectors.toSet()));
					} else {
						return super.getScope(context, reference);
					}
				} else if (contextExpr.getExpr() instanceof GipsFeatureExpr featExpr) {
					GipsFeatureExpr expr = GipslScopeContextUtil.findLeafExpression(featExpr);
					if (expr instanceof GipsFeatureLit lit) {
						EClass clazz = (EClass) lit.getFeature().getEType();
						EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
						return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile).stream()
								.filter(c -> c.getEAllSuperTypes().contains(clazz)).collect(Collectors.toSet()));
					} else {
						return super.getScope(context, reference);
					}
				} else {
					return super.getScope(context, reference);
				}
			} else {
				return super.getScope(context, reference);
			}
		} else {
			return super.getScope(context, reference);
		}
	}

//	private IScope scopeForGipsContains(GipsContains context, EReference reference) {
//		// TODO Auto-generated method stub
//		return null;
//	}

	public IScope scopeForGipsContextExprFeature(GipsContextExpr context, EReference reference) {
		if (context.getTypeCast() == null) {
			EObject contextType = null;
			GipsConstraint parent = GTEditorPatternUtils.getContainer(context, GipsConstraintImpl.class);
			if (parent != null) {
				contextType = parent.getContext();
			} else {
				GipsObjective parentAlt = GTEditorPatternUtils.getContainer(context, GipsObjectiveImpl.class);
				if (parentAlt != null) {
					contextType = parentAlt.getContext();
				} else {
					return super.getScope(context, reference);
				}
			}

			if (contextType instanceof GipsTypeContext typeContext && typeContext.getType() instanceof EClass type) {
				return Scopes.scopeFor(type.getEAllStructuralFeatures());
			} else {
				return super.getScope(context, reference);
			}
		} else {
			return Scopes.scopeFor(context.getTypeCast().getType().getEAllStructuralFeatures());
		}

	}

	public IScope scopeForGipsNodeAttributeExprFeature(GipsNodeAttributeExpr context, EReference reference) {
		if (context.getTypeCast() == null) {
			return Scopes.scopeFor(context.getNode().getType().getEAllStructuralFeatures());
		} else {
			return Scopes.scopeFor(context.getTypeCast().getType().getEAllStructuralFeatures());
		}

	}

	public IScope scopeForGipsNodeAttributeExprNode(GipsNodeAttributeExpr context, EReference reference) {
		if (context.eContainer() instanceof GipsContextExpr) {
			EObject contextType = null;
			GipsConstraint root = GTEditorPatternUtils.getContainer(context, GipsConstraintImpl.class);
			if (root != null) {
				contextType = root.getContext();
			} else {
				GipsObjective rootAlt = GTEditorPatternUtils.getContainer(context, GipsObjectiveImpl.class);
				if (rootAlt != null) {
					contextType = rootAlt.getContext();
				} else {
					return super.getScope(context, reference);
				}
			}

			if (contextType instanceof GipsMappingContext mappingContext) {
				// Return context nodes only!
				return Scopes.scopeFor(mappingContext.getMapping().getPattern().getNodes().stream()
						.filter(node -> !node.isLocal() && node.getOperator() != EditorOperator.CREATE)
						.collect(Collectors.toList()));
			} else if (contextType instanceof GipsPatternContext patternContext) {
				// Return context nodes only!
				return Scopes.scopeFor(patternContext.getPattern().getNodes().stream()
						.filter(node -> !node.isLocal() && node.getOperator() != EditorOperator.CREATE)
						.collect(Collectors.toList()));
			} else {
				return super.getScope(context, reference);
			}
		} else if (context.eContainer() instanceof GipsLambdaAttributeExpression lambda) {
			return scopeForGipsLambdaAttributeExpression(lambda, reference);
		} else {
			GipsMappingAttributeExpr parentExpr = (GipsMappingAttributeExpr) context.eContainer();
			return Scopes.scopeFor(parentExpr.getMapping().getPattern().getNodes());
		}
	}

	public IScope scopeForGipsFeatureNavigationFeature(GipsFeatureNavigation context, EReference reference) {
		GipsFeatureLit parentFeature = (GipsFeatureLit) context.getLeft();
		if (parentFeature.getFeature().getEType() instanceof EClass parentClass) {
			if (parentFeature.getTypeCast() == null) {
				return Scopes.scopeFor(parentClass.getEAllStructuralFeatures());
			} else {
				return Scopes.scopeFor(parentFeature.getTypeCast().getType().getEAllStructuralFeatures());
			}

		} else {
			return super.getScope(context, reference);
		}
	}

	public IScope scopeForGipsFeatureLit(GipsFeatureLit context, EReference reference) {
		if (context.eContainer() instanceof GipsNodeAttributeExpr nodeExpr) {
			if (nodeExpr.getTypeCast() == null) {
				return Scopes.scopeFor(nodeExpr.getNode().getType().getEAllStructuralFeatures());
			} else {
				return Scopes.scopeFor(nodeExpr.getTypeCast().getType().getEAllStructuralFeatures());
			}
		} else if (context.eContainer() instanceof GipsContextExpr contextExpr) {
			if (contextExpr.getTypeCast() == null) {
				EObject contextType = null;
				GipsConstraint root = GTEditorPatternUtils.getContainer(context, GipsConstraintImpl.class);
				if (root != null) {
					contextType = root.getContext();
				} else {
					GipsObjective rootAlt = GTEditorPatternUtils.getContainer(context, GipsObjectiveImpl.class);
					if (rootAlt != null) {
						contextType = rootAlt.getContext();
					} else {
						return super.getScope(context, reference);
					}
				}

				if (contextType instanceof GipsTypeContext typeContext
						&& typeContext.getType() instanceof EClass type) {
					return Scopes.scopeFor(type.getEAllStructuralFeatures());
				} else {
					return super.getScope(context, reference);
				}
			} else {
				return Scopes.scopeFor(contextExpr.getTypeCast().getType().getEAllStructuralFeatures());
			}
		} else if (context.eContainer() instanceof GipsLambdaAttributeExpression lambda) {
			return scopeForGipsLambdaAttributeExpression(lambda, reference);
		} else {
			GipsFeatureNavigation parent = (GipsFeatureNavigation) context.eContainer();
			GipsFeatureLit parentFeature = (GipsFeatureLit) parent.getLeft();
			if (context == parentFeature) {
				if (parent.eContainer() instanceof GipsNodeAttributeExpr parentNodeExpr) {
					if (parentNodeExpr.getTypeCast() == null) {
						return Scopes.scopeFor(parentNodeExpr.getNode().getType().getEAllStructuralFeatures());
					} else {
						return Scopes.scopeFor(parentNodeExpr.getTypeCast().getType().getEAllStructuralFeatures());
					}
				} else if (parent.eContainer() instanceof GipsContextExpr contextExpr) {
					if (contextExpr.getTypeCast() == null) {
						EObject contextType = null;
						GipsConstraint root = GTEditorPatternUtils.getContainer(context, GipsConstraintImpl.class);
						if (root != null) {
							contextType = root.getContext();
						} else {
							GipsObjective rootAlt = GTEditorPatternUtils.getContainer(context, GipsObjectiveImpl.class);
							if (rootAlt != null) {
								contextType = rootAlt.getContext();
							} else {
								return super.getScope(context, reference);
							}
						}

						if (contextType instanceof GipsTypeContext typeContext
								&& typeContext.getType() instanceof EClass type) {
							return Scopes.scopeFor(type.getEAllStructuralFeatures());
						} else {
							return super.getScope(context, reference);
						}
					} else {
						return Scopes.scopeFor(contextExpr.getTypeCast().getType().getEAllStructuralFeatures());
					}
				} else if (parent.eContainer() instanceof GipsLambdaAttributeExpression lambda) {
					return scopeForGipsLambdaAttributeExpression(lambda, reference);
				} else {
					GipsFeatureNavigation parentNavigation = (GipsFeatureNavigation) parent.eContainer();
					parentFeature = (GipsFeatureLit) parentNavigation.getLeft();
					if (parentFeature.getFeature().getEType() instanceof EClass parentClass) {
						if (parentFeature.getTypeCast() == null) {
							return Scopes.scopeFor(parentClass.getEAllStructuralFeatures());
						} else {
							return Scopes.scopeFor(parentFeature.getTypeCast().getType().getEAllStructuralFeatures());
						}

					} else {
						return super.getScope(context, reference);
					}
				}
			} else {
				if (parentFeature.getFeature().getEType() instanceof EClass parentClass) {
					if (parentFeature.getTypeCast() == null) {
						return Scopes.scopeFor(parentClass.getEAllStructuralFeatures());
					} else {
						return Scopes.scopeFor(parentFeature.getTypeCast().getType().getEAllStructuralFeatures());
					}
				} else {
					return super.getScope(context, reference);
				}
			}

		}
	}

	public IScope scopeForGipsTypeCast(GipsTypeCast context, EReference reference) {
		if (context.eContainer() instanceof GipsContextExpr contextExpr) {
			Set<Class<?>> classes = Set.of(GipsConstraintImpl.class, GipsObjectiveImpl.class);
			EObject root = (EObject) GipslScopeContextUtil.getContainer(context, classes);
			EObject contextType = null;
			if (root instanceof GipsConstraint constr) {
				contextType = constr.getContext();
			} else if (root instanceof GipsObjectiveImpl obj) {
				contextType = obj.getContext();
			} else {
				return super.getScope(context, reference);
			}
			if (contextType instanceof GipsTypeContext type && type.getType() instanceof EClass clazz) {
				EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
				return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile).stream()
						.filter(c -> c.getEAllSuperTypes().contains(clazz)).collect(Collectors.toSet()));
			} else {
				return super.getScope(context, reference);
			}
		} else if (context.eContainer() instanceof GipsNodeAttributeExpr atrExpr) {
			EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
			return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile).stream()
					.filter(c -> c.getEAllSuperTypes().contains(atrExpr.getNode().getType()))
					.collect(Collectors.toSet()));
		} else if (context.eContainer() instanceof GipsFeatureLit lit) {
			if (!lit.getFeature().isMany()) {
				EditorGTFile editorFile = GTEditorPatternUtils.getContainer(context, EditorGTFileImpl.class);
				return Scopes.scopeFor(GTEditorModelUtils.getClasses(editorFile).stream()
						.filter(c -> c.getEAllSuperTypes().contains(lit.getFeature().getEType()))
						.collect(Collectors.toSet()));
			} else {
				return super.getScope(context, reference);
			}
		} else {
			return super.getScope(context, reference);
		}
	}

}
