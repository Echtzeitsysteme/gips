/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.validation;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.validation.Check;
import org.emoflon.gips.gipsl.gipsl.EditorGTFile;
import org.emoflon.gips.gipsl.gipsl.GipsAndBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsAndOperator;
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticExpr;
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticLiteral;
import org.emoflon.gips.gipsl.gipsl.GipsArithmeticUnaryOperator;
import org.emoflon.gips.gipsl.gipsl.GipsAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsBool;
import org.emoflon.gips.gipsl.gipsl.GipsBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanLiteral;
import org.emoflon.gips.gipsl.gipsl.GipsBracketBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsBracketExpr;
import org.emoflon.gips.gipsl.gipsl.GipsConstant;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsContains;
import org.emoflon.gips.gipsl.gipsl.GipsContextExpr;
import org.emoflon.gips.gipsl.gipsl.GipsExpArithmeticExpr;
import org.emoflon.gips.gipsl.gipsl.GipsExpOperator;
import org.emoflon.gips.gipsl.gipsl.GipsExpressionOperand;
import org.emoflon.gips.gipsl.gipsl.GipsFeatureExpr;
import org.emoflon.gips.gipsl.gipsl.GipsFeatureLit;
import org.emoflon.gips.gipsl.gipsl.GipsFeatureNavigation;
import org.emoflon.gips.gipsl.gipsl.GipsGlobalObjective;
import org.emoflon.gips.gipsl.gipsl.GipsImplicationBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsLambdaAttributeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsLambdaExpression;
import org.emoflon.gips.gipsl.gipsl.GipsLambdaSelfExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsMappingCheckValue;
import org.emoflon.gips.gipsl.gipsl.GipsMappingContext;
import org.emoflon.gips.gipsl.gipsl.GipsMappingValue;
import org.emoflon.gips.gipsl.gipsl.GipsNodeAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsNotBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsObjectiveExpression;
import org.emoflon.gips.gipsl.gipsl.GipsOrBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsOrOperator;
import org.emoflon.gips.gipsl.gipsl.GipsPatternAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsPatternContext;
import org.emoflon.gips.gipsl.gipsl.GipsProductArithmeticExpr;
import org.emoflon.gips.gipsl.gipsl.GipsProductOperator;
import org.emoflon.gips.gipsl.gipsl.GipsRelExpr;
import org.emoflon.gips.gipsl.gipsl.GipsRelOperator;
import org.emoflon.gips.gipsl.gipsl.GipsSelect;
import org.emoflon.gips.gipsl.gipsl.GipsStreamArithmetic;
import org.emoflon.gips.gipsl.gipsl.GipsStreamBoolExpr;
import org.emoflon.gips.gipsl.gipsl.GipsStreamExpr;
import org.emoflon.gips.gipsl.gipsl.GipsStreamNavigation;
import org.emoflon.gips.gipsl.gipsl.GipsStreamNoArgOperator;
import org.emoflon.gips.gipsl.gipsl.GipsStreamSet;
import org.emoflon.gips.gipsl.gipsl.GipsStreamSetOperator;
import org.emoflon.gips.gipsl.gipsl.GipsSumArithmeticExpr;
import org.emoflon.gips.gipsl.gipsl.GipsSumOperator;
import org.emoflon.gips.gipsl.gipsl.GipsTypeAttributeExpr;
import org.emoflon.gips.gipsl.gipsl.GipsTypeCast;
import org.emoflon.gips.gipsl.gipsl.GipsTypeContext;
import org.emoflon.gips.gipsl.gipsl.GipsUnaryArithmeticExpr;
import org.emoflon.gips.gipsl.gipsl.GipsVariableOperationExpression;
import org.emoflon.gips.gipsl.gipsl.GipslPackage;
import org.emoflon.gips.gipsl.gipsl.GlobalContext;
import org.emoflon.gips.gipsl.gipsl.ImportedPattern;
import org.emoflon.gips.gipsl.gipsl.Package;
import org.emoflon.gips.gipsl.gipsl.impl.EditorGTFileImpl;
import org.emoflon.gips.gipsl.scoping.GipslScopeContextUtil;
import org.emoflon.ibex.gt.editor.gT.EditorNode;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.gT.GTPackage;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class GipslValidator extends AbstractGipslValidator {

	/**
	 * The list of invalid mapping/objective names. Will be filled in the static
	 * block.
	 */
	public static final Set<String> INVALID_NAMES = new HashSet<String>();

	static {
		final String[] invalidNames = new String[] { "clone", "equals", "finalize", "getClass", "hashCode", "notify",
				"notifyAll", "toString", "wait", "abstract", "assert", "boolean", "break", "byte", "case", "catch",
				"char", "class", "const", "continue", "default", "do", "double", "EAttribute", "EBoolean", "EDataType",
				"EClass", "EClassifier", "EDouble", "EFloat", "EInt", "else", "enum", "EPackage", "EReference",
				"EString", "extends", "final", "finally", "float", "for", "goto", "if", "implements", "import",
				"instanceof", "int", "interface", "long", "native", "new", "package", "private", "protected", "public",
				"return", "short", "static", "strictfp", "super", "switch", "synchronized", "this", "throw", "throws",
				"transient", "try", "void", "volatile", "while",

				// New values
				"mapping", "objective", "global objective", "global", "min", "max", "constraint" };
		INVALID_NAMES.addAll(Arrays.asList(invalidNames));
	}

	static final String CODE_PREFIX = "org.emoflon.gips.gipsl.";

	// General errors for named elements.
	public static final String NAME_BLOCKED = CODE_PREFIX + "name.blocked";
	public static final String NAME_EXPECT_CAMEL_CASE = CODE_PREFIX + "name.expectCamelCase";
	public static final String NAME_EXPECT_LOWER_CASE = CODE_PREFIX + "name.expectLowerCase";
	public static final String NAME_EXPECT_UNIQUE = CODE_PREFIX + "name.expectUnique";

	public static final String GLOBAL_OBJECTIVE_DOES_NOT_EXIST = CODE_PREFIX + "objective.global.doesNotExist";

	public static final String GLOBAL_OBJECTIVE_IS_NULL_MESSAGE = "You need to specify a global objective.";
	public static final String GLOBAL_OBJECTIVE_IS_OPTIONAL_MESSAGE = "The global objective is optional if no local objective is defined.";
	public static final String GLOBAL_OBJECTIVE_DOES_NOT_CONTAIN_LOCAL_OBJECTIVE_MESSAGE = "Global objective does not contain any reference to a local objective.";

	public static final String MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Mapping '%s' must not be declared '%s'.";
	public static final String MAPPING_NAME_FORBIDDEN_MESSAGE = "Mappings cannot be be named '%s'. Use a different name.";
	public static final String MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Mapping name '%s' contains underscores. Use camelCase instead.";
	public static final String MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Mapping '%s' should start with a lower case character.";
	public static final String MAPPING_W_O_CONSTRAINTS_MESSAGE = "Mapping '%s' is not subject to any constraints.";
	public static final String MAPPING_W_O_CONSTRAINTS_AND_OBJECTIVE_MESSAGE = "Mapping '%s' is not subject to any constraints and not part of any objective function.";

	public static final String OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Objective '%s' must not be declared '%s'";
	public static final String OBJECTIVE_NAME_FORBIDDEN_MESSAGE = "Objectives cannot be be named '%s'. Use a different name.";
	public static final String OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Objective name '%s' contains underscores. Use camelCase instead.";
	public static final String OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Objective '%s' should start with a lower case character.";

	// Other errors for types
	public static final String OBJECTIVE_VALUE_IS_ZERO_MESSAGE = "Objective '%s' can be removed because its value is 0.";

	public static final String CONSTRAINT_EMPTY_MESSAGE = "Constraint is empty.";
	public static final String CONSTRAINT_EVAL_NOT_BOOLEAN_MESSAGE = "Constraint does not evaluate to a boolean";
	public static final String CONSTRAINT_EVAL_LITERAL_MESSAGE = "Constraint is always '%s'.";

	public static final String OBJECTIVE_EVAL_NOT_NUMBER_MESSAGE = "Objective does not evaluate to an integer or double.";
	public static final String OBJECTIVE_CONTEXT_CLASS_MESSAGE = "Objectives can not have a class as context.";

	public static final String LITERAL_NOT_PARSABLE_MESSAGE = "Literal is not parsable.";

	public static final String LAMBDA_EXPR_EVAL_NOT_PRIMITIVE_MESSAGE = "Lambda expression does not evaluate to a primitve type.";
	public static final String LAMBDA_EXPR_EVAL_LITERAL_MESSAGE = "Lambda expression is always '%s'.";
	public static final String LAMBDA_EXPR_EVAL_TYPE_ERROR = "Type error in lambda expression.";

	public static final String CONSTRAINT_DEFINED_MULTIPLE_TIMES_MESSAGE = "Constraint defined multiple times.";
	public static final String CONSTRAINT_HAS_NO_CONSTANT_SIDE_MESSAGE = "Constraint has no constant side.";
	public static final String CONSTRAINT_HAS_TWO_CONSTANT_SIDES_MESSAGE = "Constraint has only constant sides. Use GT to express this condition.";

	public static final String STREAM_ON_NON_COLLECTION_TYPE_MESSAGE = "Stream used on non collection type.";

	public static final String EXP_EXPR_NOT_CONSTANT_MESSAGE = "Exponential expression must be constant due to ILP.";
	public static final String PRODUCT_EXPR_NOT_CONSTANT_MESSAGE = "Product expressions can only have one dynamic sub expression due to ILP.";
	public static final String UNARY_ARITH_EXPR_NOT_CONSTANT_MESSAGE = "Unary arithmetic expression with operator '%s' must be constant due to ILP.";

	public static final String BOOL_EXPR_EVAL_ERROR_MESSAGE = "Boolean expression does not evaluate to boolean.";
	public static final String ARITH_EXPR_EVAL_ERROR_MESSAGE = "Arithmetic expression does not evaluate to a primitive type.";

	public static final String TYPE_DOES_NOT_CONTAIN_SELF_MESSAGE = "'%s' does not contain any self reference.";

	public static final String MAPPING_IN_MAPPING_FORBIDDEN_MESSAGE = "Mapping access within mapping context is forbidden.";
	public static final String IS_MAPPED_CALL_IN_CONTEXT_FORBIDDEN_MESSAGE = "\"isMapped()\" call in non mapping context is not possible.";

	// Exception error messages
	public static final String NOT_IMPLEMENTED_EXCEPTION_MESSAGE = "Not yet implemented";
	public static final String CONSTRAINT_CONTEXT_UNKNOWN_EXCEPTION_MESSAGE = "Context is neither a GipsType nor a GipsMapping.";

	// Number error messages
	public static final String SQRT_VALUE_SMALLER_THAN_ZERO = "Value in SQRT is smaller than 0.";

	/**
	 * This prevents all exceptions being "swallowed" by the default validator
	 * implementation. TODO: Remove this or make it a little nice for future stable
	 * release candidates.
	 */
	@Override
	protected void handleExceptionDuringValidation(final Throwable targetException) throws RuntimeException {
		targetException.printStackTrace();
	}

	/**
	 * Pattern names must be unique.
	 */
	@Override
	public void checkPatternNameUnique(EditorPattern pattern) {
		EditorGTFile file = GTEditorPatternUtils.getContainer(pattern, EditorGTFileImpl.class);
		long count = file.getPatterns().stream().filter(p -> p != null && p.getName() != null)
				.filter(p -> p.getName().equals(pattern.getName())).count();
		count += file.getImportedPattern().stream()
				.filter(p -> p != null && p.getPattern() != null && p.getPattern().getName() != null)
				.filter(p -> p.getPattern().getName().equals(pattern.getName())).count();
		if (count != 1) {
			error(String.format(PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE, pattern.getName(),
					super.getTimes((int) count)), GTPackage.Literals.EDITOR_PATTERN__NAME, NAME_EXPECT_UNIQUE);
		}

	}

	@Check
	public void packageValid(Package pkg) {
		if (pkg.getName() == null || pkg.getName().isBlank()) {
			error("Package name must not be empty!", GipslPackage.Literals.PACKAGE__NAME);
			return;
		}

		if (pkg.getName().contains(" ")) {
			error("Package name may not contain any white spaces.", GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().contains("\\")) {
			error("Package name may not contain any slashes.", GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().contains("/")) {
			error("Package name may not contain any slashes.", GipslPackage.Literals.PACKAGE__NAME);
		}

		StringBuilder sb = new StringBuilder();

		if (pkg.getName().chars().filter(c -> Character.isUpperCase(c)).map(c -> {
			sb.append((char) c + " ");
			return c;
		}).findAny().isPresent()) {
			error("Package name may not contain any upper case letters. The following illegal characters were found: "
					+ sb.toString(), GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().chars().filter(c -> !(Character.isLetter(c) || Character.isDigit(c) || c == '.' || c == '"'))
				.map(c -> {
					sb.append((char) c + " ");
					return c;
				}).findAny().isPresent()) {
			error("Package name may not contain any characters other than lower case letters, digits or dots. The following illegal characters were found: "
					+ sb.toString(), GipslPackage.Literals.PACKAGE__NAME);
		}

		// Check Workspace uniqueness
		IProject currentProject = GipslScopeContextUtil.getCurrentProject(pkg.eResource());
		String currentFile = pkg.eResource().getURI().toString().replace("platform:/resource/", "")
				.replace(currentProject.getName(), "");
		currentFile = currentProject.getLocation().toPortableString() + currentFile;
		currentFile = currentFile.replace("/", "\\");

		IWorkspace ws = ResourcesPlugin.getWorkspace();
		for (IProject project : ws.getRoot().getProjects()) {
			try {
				if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
					continue;
			} catch (CoreException e) {
				continue;
			}

			File projectFile = new File(project.getLocation().toPortableString());
			List<File> gtFiles = new LinkedList<>();
			GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

			for (File gtFile : gtFiles) {

				XtextResourceSet rs = new XtextResourceSet();
				URI gtModelUri;
				try {
					gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
				} catch (IOException e) {
					continue;
				}

				String fileString = gtModelUri.toFileString();

				if (fileString.equals(currentFile))
					continue;

				Resource resource = rs.getResource(gtModelUri, true);
				EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
				EObject gtModel = resource.getContents().get(0);

				if (gtModel == null)
					continue;

				if (gtModel instanceof EditorGTFile gipsEditorFile) {
					if (gipsEditorFile.getPackage().getName().equals(pkg.getName())) {
						error("Package name must be unique within the current workspace. Package name clash with: "
								+ gtModelUri, GipslPackage.Literals.PACKAGE__NAME);
					}
				}
			}
		}

	}

	/**
	 * Pattern names must be unique.
	 */
	@Check
	public void checkImportNameUnique(ImportedPattern pattern) {
		if (pattern.getPattern() == null)
			return;

		EditorGTFile file = GTEditorPatternUtils.getContainer(pattern, EditorGTFileImpl.class);
		long count = file.getPatterns().stream().filter(p -> p != null && p.getName() != null)
				.filter(p -> p.getName().equals(pattern.getPattern().getName())).count();
		count += file.getImportedPattern().stream()
				.filter(p -> p != null && p.getPattern() != null && p.getPattern().getName() != null)
				.filter(p -> p.getPattern().getName().equals(pattern.getPattern().getName())).count();
		if (count != 1) {
			error(String.format(PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE, pattern.getPattern().getName(),
					super.getTimes((int) count)), GipslPackage.Literals.IMPORTED_PATTERN__PATTERN, NAME_EXPECT_UNIQUE);
		}
	}

	/**
	 * URI valid
	 */
	@Check
	public void checkImportUriExists(ImportedPattern pattern) {
		if (pattern.getFile() == null || pattern.getFile().isBlank())
			return;

		XtextResourceSet rs = new XtextResourceSet();
		Resource resource = null;
		URI gtModelUri = null;
		String currentImport = pattern.getFile().replace("\"", "");
		File importFile = new File(currentImport);

		if (importFile.exists() && importFile.isFile() && importFile.isAbsolute()) {
			gtModelUri = URI.createFileURI(currentImport);
			try {
				resource = rs.getResource(gtModelUri, true);
			} catch (Exception e) {
				error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
						GipslPackage.Literals.IMPORTED_PATTERN__FILE);
				return;
			}
		} else {
			// 1. Case: package name
			if (!(currentImport.contains("/") || currentImport.contains("\\"))) {
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(pattern.eResource());

				String currentFile = pattern.eResource().getURI().toString().replace("platform:/resource/", "")
						.replace(currentProject.getName(), "");
				currentFile = currentProject.getLocation().toPortableString() + currentFile;
				currentFile = currentFile.replace("/", "\\");

				IWorkspace ws = ResourcesPlugin.getWorkspace();
				for (IProject project : ws.getRoot().getProjects()) {
					try {
						if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
							continue;
					} catch (CoreException e) {
						continue;
					}

					File projectFile = new File(project.getLocation().toPortableString());
					List<File> gtFiles = new LinkedList<>();
					GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

					for (File gtFile : gtFiles) {

						rs = new XtextResourceSet();
						try {
							gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
						} catch (IOException e) {
							continue;
						}

						String fileString = gtModelUri.toFileString();

						if (fileString.equals(currentFile))
							continue;

						resource = rs.getResource(gtModelUri, true);
						EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
						EObject gtModel = resource.getContents().get(0);

						if (gtModel == null)
							continue;

						if (gtModel instanceof EditorGTFile gipsEditorFile) {
							if (gipsEditorFile.getPackage().getName().equals(pattern.getFile())) {
								break;
							}
						}

						rs = null;
						resource = null;
					}

					if (resource != null)
						break;
				}
			} else { // 2. Case: relative path
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(pattern.eResource());

				String absolutePath = null;
				try {
					absolutePath = Paths.get(currentProject.getLocation().toPortableString())
							.resolve(Paths.get(currentImport)).toFile().getCanonicalPath();
				} catch (IOException e1) {
					error("Relative import URI <" + currentImport + "> is not resolvable.",
							GipslPackage.Literals.IMPORTED_PATTERN__FILE);
					return;
				}

				gtModelUri = URI.createFileURI(absolutePath);
				try {
					resource = rs.getResource(gtModelUri, true);
				} catch (Exception e) {
					error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
							GipslPackage.Literals.IMPORTED_PATTERN__FILE);
					return;
				}
			}
		}

		if (resource == null)
			error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
					GipslPackage.Literals.IMPORTED_PATTERN__FILE);
	}

	/**
	 * Checks if a global objective is specified in a given file. This must hold if
	 * there is any local objective defined. Furthermore, it displays a warning if
	 * the user specified a global objective but there is no local objective in the
	 * given file.
	 * 
	 * @param file File to check existence of a global objective for.
	 */
	@Check
	public void checkGlobalObjectiveNotNull(final EditorGTFile file) {
		if (file == null) {
			return;
		}

		if (file.getObjectives() != null && !file.getObjectives().isEmpty() && file.getGlobalObjective() == null) {
			error( //
					GLOBAL_OBJECTIVE_IS_NULL_MESSAGE, //
					// TODO: Change scope of the warning:
					GipslPackage.Literals.EDITOR_GT_FILE__GLOBAL_OBJECTIVE, //
					GLOBAL_OBJECTIVE_DOES_NOT_EXIST //
			);
		} else if (file.getObjectives() != null && file.getObjectives().isEmpty()
				&& file.getGlobalObjective() != null) {
			warning( //
					GLOBAL_OBJECTIVE_IS_OPTIONAL_MESSAGE, //
					GipslPackage.Literals.EDITOR_GT_FILE__GLOBAL_OBJECTIVE //
			);
		}
	}

	/**
	 * Checks the global objective regarding the use of dynamic sub types like
	 * 'self.value()' in non-linear mathematical expressions.
	 * 
	 * @param globObj Gips global objective to validate/check.
	 */
	@Check
	public void checkGlobalObjective(final GipsGlobalObjective globObj) {
		if (globObj == null) {
			return;
		}

		// Validate expression regarding dynamic uses (like self.value())
		validateArithExprDynamic(globObj.getExpr());

		// Check if global objective contains any reference to a local objective
		// If this is not the case, display a warning that the global objective is
		// constant
		if (!containsLocalObjectiveCall(globObj.getExpr())) {
			warning( //
					GLOBAL_OBJECTIVE_DOES_NOT_CONTAIN_LOCAL_OBJECTIVE_MESSAGE, //
					GipslPackage.Literals.GIPS_GLOBAL_OBJECTIVE__EXPR //
			);
		}
	}

	/**
	 * Returns true if the given arithmetic expression contains at least one call to
	 * a local Gips objective.
	 * 
	 * @param expr Gips arithmetic expression to check local objective call
	 *             existence for.
	 * @return True if the given arithmetic expression contains at least one call to
	 *         a local Gips objective.
	 */
	public boolean containsLocalObjectiveCall(final GipsArithmeticExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsBracketExpr) {
			final GipsBracketExpr bracketExpr = (GipsBracketExpr) expr;
			return containsLocalObjectiveCall(bracketExpr.getOperand());
		} else if (expr instanceof GipsExpArithmeticExpr) {
			final GipsExpArithmeticExpr expExpr = (GipsExpArithmeticExpr) expr;
			return containsLocalObjectiveCall(expExpr.getLeft()) || containsLocalObjectiveCall(expExpr.getRight());
		} else if (expr instanceof GipsExpressionOperand) {
			final GipsExpressionOperand exprOp = (GipsExpressionOperand) expr;
			return exprOp instanceof GipsObjectiveExpression;
		} else if (expr instanceof GipsProductArithmeticExpr) {
			final GipsProductArithmeticExpr prodExpr = (GipsProductArithmeticExpr) expr;
			return containsLocalObjectiveCall(prodExpr.getLeft()) || containsLocalObjectiveCall(prodExpr.getRight());
		} else if (expr instanceof GipsSumArithmeticExpr) {
			final GipsSumArithmeticExpr sumExpr = (GipsSumArithmeticExpr) expr;
			return containsLocalObjectiveCall(sumExpr.getLeft()) || containsLocalObjectiveCall(sumExpr.getRight());
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			final GipsUnaryArithmeticExpr unExpr = (GipsUnaryArithmeticExpr) expr;
			return containsLocalObjectiveCall(unExpr.getOperand());
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * Runs checks for all Gips mappings.
	 * 
	 * @param mapping Input Gips mapping to check.
	 */
	@Check
	public void checkMapping(final GipsMapping mapping) {
		if (mapping == null) {
			return;
		}

		checkMappingNameValid(mapping);
		checkMappingNameUnique(mapping);
		checkMappingUnused(mapping);
	}

	/**
	 * Checks for validity of a mapping name. The name must not be on the list of
	 * invalid names, the name should be in lowerCamelCase, and the name should
	 * start with a lower case character.
	 * 
	 * @param mapping Gips mapping to check.
	 */
	public void checkMappingNameValid(final GipsMapping mapping) {
		if (mapping == null || mapping.getName() == null) {
			return;
		}

		if (INVALID_NAMES.contains(mapping.getName())) {
			error( //
					String.format(MAPPING_NAME_FORBIDDEN_MESSAGE, mapping.getName()), //
					GipslPackage.Literals.GIPS_MAPPING__NAME, //
					NAME_EXPECT_UNIQUE //
			);
		} else {
			// The mapping name should be lowerCamelCase.
			if (mapping.getName().contains("_")) {
				warning( //
						String.format(MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE, mapping.getName()), //
						GipslPackage.Literals.GIPS_MAPPING__NAME, //
						NAME_BLOCKED //
				);
			} else {
				// The mapping name should start with a lower case character.
				if (!Character.isLowerCase(mapping.getName().charAt(0))) {
					warning( //
							String.format(MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, mapping.getName()), //
							GipslPackage.Literals.GIPS_MAPPING__NAME, NAME_EXPECT_LOWER_CASE //
					);
				}
			}
		}
	}

	/**
	 * Checks the uniqueness of the name of a given Gips mapping.
	 * 
	 * @param mapping Gips mapping to check uniqueness of the name for.
	 */
	public void checkMappingNameUnique(final GipsMapping mapping) {
		if (mapping == null || mapping.getName() == null) {
			return;
		}

		final EditorGTFile container = (EditorGTFile) mapping.eContainer();
		final long count = container.getMappings().stream()
				.filter(m -> m.getName() != null && m.getName().equals(mapping.getName())).count();
		if (count != 1) {
			error( //
					String.format(MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE, mapping.getName(), getTimes((int) count)), //
					GipslPackage.Literals.GIPS_MAPPING__NAME, //
					NAME_EXPECT_UNIQUE //
			);
		}
	}

	/**
	 * Checks if a mapping is either unconstrained or not used in an objective and
	 * throws a warning accordingly.
	 * 
	 * @param mapping Gips mapping to be checked.
	 */
	public void checkMappingUnused(final GipsMapping mapping) {
		final EditorGTFile container = (EditorGTFile) mapping.eContainer();
		boolean usedAsContext = container.getConstraints().stream().filter(c -> c.getContext() != null)
				.filter(c -> (c.getContext() instanceof GipsMappingContext))
				.map(c -> (GipsMappingContext) c.getContext()).filter(mc -> mc.getMapping().equals(mapping)).findAny()
				.isPresent();
		if (usedAsContext)
			return;

		List<GipsConstraint> otherConstraints = container.getConstraints().stream()
				.filter(c -> c.getContext() != null && c.getExpr() != null && c.getExpr().getExpr() != null)
				.filter(c -> {
					if (c.getContext() instanceof GipsMappingContext mapContext
							&& !mapContext.getMapping().equals(mapping)) {
						return true;
					} else if (!(c.getContext() instanceof GipsMappingContext)) {
						return true;
					} else {
						return false;
					}
				}).collect(Collectors.toList());

		for (GipsConstraint constraint : otherConstraints) {
			Set<GipsMapping> mappings = GipslScopeContextUtil.extractMappings(constraint.getExpr().getExpr());
			if (mappings.contains(mapping))
				return;
		}

		warning( //
				String.format(MAPPING_W_O_CONSTRAINTS_MESSAGE, mapping.getName()), //
				GipslPackage.Literals.GIPS_MAPPING__NAME);

		usedAsContext = container.getObjectives().stream().filter(c -> c.getContext() != null)
				.filter(c -> (c.getContext() instanceof GipsMappingContext))
				.map(c -> (GipsMappingContext) c.getContext()).filter(mc -> mc.getMapping().equals(mapping)).findAny()
				.isPresent();
		if (usedAsContext)
			return;

		List<GipsObjective> otherObjectives = container.getObjectives().stream()
				.filter(c -> c.getContext() != null && c.getExpr() != null).filter(c -> {
					if (c.getContext() instanceof GipsMappingContext mapContext
							&& !mapContext.getMapping().equals(mapping)) {
						return true;
					} else if (!(c.getContext() instanceof GipsMappingContext)) {
						return true;
					} else {
						return false;
					}
				}).collect(Collectors.toList());

		for (GipsObjective objective : otherObjectives) {
			Set<GipsMapping> mappings = GipslScopeContextUtil.extractMappings(objective.getExpr());
			if (mappings.contains(mapping))
				return;
		}

		warning( //
				String.format(MAPPING_W_O_CONSTRAINTS_AND_OBJECTIVE_MESSAGE, mapping.getName()), //
				GipslPackage.Literals.GIPS_MAPPING__NAME);
	}

	/**
	 * Runs all checks for a given constraint.
	 * 
	 * @param constraint Gips constraint to check.
	 */
	@Check
	public void checkConstraint(final GipsConstraint constraint) {
		if (constraint == null) {
			return;
		}

		if (constraint.getExpr() == null) {
			error( //
					String.format(CONSTRAINT_EMPTY_MESSAGE), //
					constraint, //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
			return;
		}

		if (constraint.getExpr().getExpr() == null) {
			error( //
					String.format(CONSTRAINT_EMPTY_MESSAGE), //
					constraint, //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
			return;
		}

		// Trigger validation of boolean expression
		getEvalTypeFromBoolExpr(constraint.getExpr().getExpr());

		// Check if constraint is a literal -> warning
		checkConstraintIsLiteral(constraint);

		// Check if constraint is unique
		checkConstraintUnique(constraint);

		// Check if constraint contains at least one 'self' call (only if context is not
		// global)
		if (!(constraint.getContext() instanceof GlobalContext)) {
			validateConstraintHasSelf(constraint);
		}

		// Validate expression -> Non-linear operations must be constant in ILP time
		validateConstraintDynamic(constraint);

		// Validate that no mapping gets accessed if context is mapping
		validateNoMappingAccessIfMappingContext(constraint);

		// Validation: No "self.isMapped()" in context != mapping
		validateNoIsMappedInContextNotMapping(constraint);
	}

	/**
	 * This method validates that "isMapped()" is only usable if the context is a
	 * mapping.
	 * 
	 * @param constraint Constraint to check "isMapped()" in contexts for.
	 */
	public void validateNoIsMappedInContextNotMapping(final GipsConstraint constraint) {
		if (!(constraint.getContext() instanceof GipsMappingContext)) {
			final GipsBoolExpr expr = constraint.getExpr().getExpr();
			final boolean containsMappingCheckValue = containsMappingCheckValue(expr);
			if (containsMappingCheckValue) {
				error( //
						IS_MAPPED_CALL_IN_CONTEXT_FORBIDDEN_MESSAGE, //
						constraint, //
						GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
				);
			}
		}
	}

	/**
	 * Returns true if the given boolean expression contains an isMapped call.
	 * 
	 * @param expr Arithmetic expression to check.
	 * @return True if the given arithmetic expression contains an isMapped call.
	 */
	public boolean containsMappingCheckValue(final GipsArithmeticExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsBracketExpr) {
			final GipsBracketExpr bracketExpr = (GipsBracketExpr) expr;
			return containsMappingCheckValue(bracketExpr.getOperand());
		} else if (expr instanceof GipsExpArithmeticExpr) {
			final GipsExpArithmeticExpr expExpr = (GipsExpArithmeticExpr) expr;
			return containsMappingCheckValue(expExpr.getLeft()) || containsMappingCheckValue(expExpr.getRight());
		} else if (expr instanceof GipsExpressionOperand) {
			final GipsExpressionOperand exprOp = (GipsExpressionOperand) expr;
			if (exprOp instanceof GipsArithmeticLiteral) {
				return false;
			} else if (exprOp instanceof GipsAttributeExpr) {
				if (exprOp instanceof GipsContextExpr) {
					final GipsContextExpr conExpr = (GipsContextExpr) exprOp;
					// Streams can be ignored
					return conExpr.getExpr() instanceof GipsVariableOperationExpression;
				} else if (exprOp instanceof GipsLambdaAttributeExpression) {
					// A GipsLambdaAttributeExpression can not contain an isMapped call
					return false;
				} else if (exprOp instanceof GipsMappingAttributeExpr) {
					// Streams can be ignored
					return false;
				} else if (exprOp instanceof GipsPatternAttributeExpr patternExpr) {
					// Streams can be ignored
					return false;
				} else if (exprOp instanceof GipsTypeAttributeExpr typeExpr) {
					// Streams can be ignored
					return false;
				}
			}
		} else if (expr instanceof GipsProductArithmeticExpr) {
			final GipsProductArithmeticExpr prodExpr = (GipsProductArithmeticExpr) expr;
			return containsMappingCheckValue(prodExpr.getLeft()) || containsMappingCheckValue(prodExpr.getRight());
		} else if (expr instanceof GipsSumArithmeticExpr) {
			final GipsSumArithmeticExpr sumExpr = (GipsSumArithmeticExpr) expr;
			return containsMappingCheckValue(sumExpr.getLeft()) || containsMappingCheckValue(sumExpr.getRight());
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			final GipsUnaryArithmeticExpr unExpr = (GipsUnaryArithmeticExpr) expr;
			return containsMappingCheckValue(unExpr.getOperand());
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * Returns true if the given boolean expression contains an isMapped call.
	 * 
	 * @param expr Boolean expression to check.
	 * @return True if the given boolean expression contains an isMapped call.
	 */
	public boolean containsMappingCheckValue(final GipsBoolExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsAndBoolExpr andExpr) {
			return containsMappingCheckValue(andExpr.getLeft()) || containsMappingCheckValue(andExpr.getRight());
		} else if (expr instanceof GipsBooleanLiteral) {
			return false;
		} else if (expr instanceof GipsBracketBoolExpr brackExpr) {
			return containsMappingCheckValue(brackExpr.getOperand());
		} else if (expr instanceof GipsImplicationBoolExpr implExpr) {
			return containsMappingCheckValue(implExpr.getLeft()) || containsMappingCheckValue(implExpr.getRight());
		} else if (expr instanceof GipsNotBoolExpr notExpr) {
			return containsMappingCheckValue(notExpr.getOperand());
		} else if (expr instanceof GipsOrBoolExpr orExpr) {
			return containsMappingCheckValue(orExpr.getLeft()) || containsMappingCheckValue(orExpr.getRight());
		} else if (expr instanceof GipsRelExpr relExpr) {
			return containsMappingCheckValue(relExpr.getLeft()) || containsMappingCheckValue(relExpr.getRight());
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * This method ensures that no mappings will be accessed from within the mapping
	 * context. This does not include 'self'.
	 * 
	 * @param constraint Constraint to check mapping in mapping access for.
	 */
	public void validateNoMappingAccessIfMappingContext(final GipsConstraint constraint) {
		if (constraint == null) {
			return;
		}

		// If context is not a mapping, return immediately
		if (getContextType(constraint.getContext()) != ContextType.MAPPING) {
			return;
		}

		final GipsBoolExpr expr = constraint.getExpr().getExpr();

		boolean leftMapping = false;
		boolean rightMapping = false;

		if (expr instanceof GipsRelExpr) {
			final GipsRelExpr relExpr = (GipsRelExpr) expr;
			leftMapping = containsMappingsCall(relExpr.getLeft());
			rightMapping = containsMappingsCall(relExpr.getRight());
		} else if (expr instanceof GipsBoolExpr) {
			// Special case: Complete boolean expression is just a literal
			if (expr instanceof GipsBooleanLiteral) {
				return;
			} else if (expr instanceof GipsImplicationBoolExpr impl) {
				leftMapping = containsMappingsCall(impl.getLeft());
				rightMapping = containsMappingsCall(impl.getRight());
			} else if (expr instanceof GipsOrBoolExpr or) {
				leftMapping = containsMappingsCall(or.getLeft());
				rightMapping = containsMappingsCall(or.getRight());
			} else if (expr instanceof GipsAndBoolExpr and) {
				leftMapping = containsMappingsCall(and.getLeft());
				rightMapping = containsMappingsCall(and.getRight());
			} else if (expr instanceof GipsNotBoolExpr not) {
				leftMapping = containsMappingsCall(not.getOperand());
				rightMapping = leftMapping;
			} else if (expr instanceof GipsBracketBoolExpr brack) {
				leftMapping = containsMappingsCall(brack.getOperand());
				rightMapping = leftMapping;
			} else {
				throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
			}
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}

		// Generate an error if mappings are referenced
		if (leftMapping || rightMapping) {
			error( //
					MAPPING_IN_MAPPING_FORBIDDEN_MESSAGE, //
					constraint, //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
		}
	}

	/**
	 * Returns true if the given boolean expression contains a mapping call.
	 * 
	 * @param expr Boolean expression to check.
	 * @return True if the given boolean expression contains a mapping call.
	 */
	public boolean containsMappingsCall(final GipsBoolExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsImplicationBoolExpr impl) {
			return containsMappingsCall(impl.getLeft()) || containsMappingsCall(impl.getRight());
		} else if (expr instanceof GipsOrBoolExpr or) {
			return containsMappingsCall(or.getLeft()) || containsMappingsCall(or.getRight());
		} else if (expr instanceof GipsAndBoolExpr and) {
			return containsMappingsCall(and.getLeft()) || containsMappingsCall(and.getRight());
		} else if (expr instanceof GipsNotBoolExpr not) {
			return containsMappingsCall(not.getOperand());
		} else if (expr instanceof GipsBracketBoolExpr brack) {
			return containsMappingsCall(brack.getOperand());
		} else if (expr instanceof GipsBooleanLiteral) {
			return false;
		} else if (expr instanceof GipsRelExpr) {
			final GipsRelExpr relExpr = (GipsRelExpr) expr;
			return containsMappingsCall(relExpr.getLeft()) || containsMappingsCall(relExpr.getRight());
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}

	}

	/**
	 * Returns true if the given arithmetic expression contains a mapping call.
	 * 
	 * @param expr Arithmetic expression to check.
	 * @return True if the given arithmetic expression contains a mapping call.
	 */
	public boolean containsMappingsCall(final GipsArithmeticExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsBracketExpr) {
			final GipsBracketExpr bracketExpr = (GipsBracketExpr) expr;
			return containsMappingsCall(bracketExpr.getOperand());
		} else if (expr instanceof GipsExpArithmeticExpr) {
			final GipsExpArithmeticExpr expExpr = (GipsExpArithmeticExpr) expr;
			return containsMappingsCall(expExpr.getLeft()) || containsMappingsCall(expExpr.getRight());
		} else if (expr instanceof GipsExpressionOperand) {
			final GipsExpressionOperand exprOp = (GipsExpressionOperand) expr;
			if (exprOp instanceof GipsArithmeticLiteral) {
				return false;
			} else if (exprOp instanceof GipsAttributeExpr) {
				if (exprOp instanceof GipsContextExpr) {
					final GipsContextExpr conExpr = (GipsContextExpr) exprOp;
					if (streamContainsMappingsCall(conExpr.getStream())) {
						return true;
					}
					return (conExpr.getExpr() instanceof GipsVariableOperationExpression
							&& !(conExpr.getExpr() instanceof GipsMappingCheckValue));
				} else if (exprOp instanceof GipsLambdaAttributeExpression) {
					// A GipsLambdaAttributeExpression can not contain a mappings call
					return false;
				} else if (exprOp instanceof GipsLambdaSelfExpression) {
					// A GipsLambdaSelfExpression can not contain a mappings call
					return false;
				} else if (exprOp instanceof GipsMappingAttributeExpr) {
					// A GipsMappingAttributeExpr always contains a mappings call
					return true;
				} else if (exprOp instanceof GipsPatternAttributeExpr patternExpr) {
					return streamContainsMappingsCall(patternExpr.getExpr());
				} else if (exprOp instanceof GipsTypeAttributeExpr typeExpr) {
					return streamContainsMappingsCall(typeExpr.getExpr());
				}
			} else if (exprOp instanceof GipsObjectiveExpression) {
				return false;
			}
		} else if (expr instanceof GipsProductArithmeticExpr) {
			final GipsProductArithmeticExpr prodExpr = (GipsProductArithmeticExpr) expr;
			return containsMappingsCall(prodExpr.getLeft()) || containsMappingsCall(prodExpr.getRight());
		} else if (expr instanceof GipsSumArithmeticExpr) {
			final GipsSumArithmeticExpr sumExpr = (GipsSumArithmeticExpr) expr;
			return containsMappingsCall(sumExpr.getLeft()) || containsMappingsCall(sumExpr.getRight());
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			final GipsUnaryArithmeticExpr unExpr = (GipsUnaryArithmeticExpr) expr;
			return containsMappingsCall(unExpr.getOperand());
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * Returns true if the given stream expression contains a mapping call.
	 * 
	 * @param expr Stream expression to check.
	 * @return True if the given stream expression contains a mapping call.
	 */
	public boolean streamContainsMappingsCall(final GipsStreamExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsSelect) {
			return false;
		} else if (expr instanceof GipsStreamArithmetic) {
			final GipsStreamArithmetic arithExpr = (GipsStreamArithmetic) expr;
			return containsMappingsCall(arithExpr.getLambda().getExpr());
		} else if (expr instanceof GipsStreamBoolExpr) {
			return false;
		} else if (expr instanceof GipsStreamNavigation) {
			final GipsStreamNavigation nav = (GipsStreamNavigation) expr;
			return streamContainsMappingsCall(nav.getLeft()) || streamContainsMappingsCall(nav.getRight());
		} else if (expr instanceof GipsStreamSet) {
			final GipsStreamSet set = (GipsStreamSet) expr;
			return containsMappingsCall(set.getLambda().getExpr());
		} else if (expr instanceof GipsContains contains) {
			return containsMappingsCall(contains.getExpr());
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * Checks if the constraint is a literal and, therefore, display a warning.
	 * 
	 * @param constraint Constraint to check.
	 */
	public void checkConstraintIsLiteral(final GipsConstraint constraint) {
		if (constraint == null) {
			return;
		}

		if (constraint.getExpr().getExpr() instanceof GipsBooleanLiteral) {
			final GipsBooleanLiteral lit = (GipsBooleanLiteral) constraint.getExpr().getExpr();
			final String warning = String.valueOf(lit.isLiteral());
			warning( //
					String.format(CONSTRAINT_EVAL_LITERAL_MESSAGE, warning), //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
		}
	}

	/**
	 * Checks if a given constraint is unique, i.e., if there is another constraint
	 * that has the exact same expression.
	 * 
	 * @param constraint Constraint to check uniqueness for.
	 */
	public void checkConstraintUnique(final GipsConstraint constraint) {
		if (constraint == null) {
			return;
		}

		final EditorGTFile file = (EditorGTFile) constraint.eContainer();
		final HashSet<GipsConstraint> others = new HashSet<>();
		for (final GipsConstraint other : file.getConstraints()) {
			if (constraint.equals(other)) {
				// TODO: ^equals() is defined as '==' in this case -.-
				// Therefore, this does not work, yet.
				others.add(other);
			}
		}

		if (others.size() > 1) {
			for (final GipsConstraint other : others) {
				warning( //
						CONSTRAINT_DEFINED_MULTIPLE_TIMES_MESSAGE, //
						other, //
						GipslPackage.Literals.GIPS_CONSTRAINT__CONTEXT //
				);
			}
		}
	}

	/**
	 * Validates that a constraint has at least one 'self' reference.
	 * 
	 * @param constraint Constraint to validate.
	 */
	public void validateConstraintHasSelf(final GipsConstraint constraint) {
		if (constraint == null || constraint.getExpr() == null) {
			return;
		}

		final GipsBoolExpr expr = constraint.getExpr().getExpr();
		boolean leftSelf = false;
		boolean rightSelf = false;

		final ContextType type = getContextType(constraint.getContext());

		if (expr instanceof GipsRelExpr) {
			final GipsRelExpr relExpr = (GipsRelExpr) expr;
			leftSelf = containsSelf(relExpr.getLeft(), type);
			rightSelf = containsSelf(relExpr.getRight(), type);
		} else if (expr instanceof GipsBoolExpr) {
			if (expr instanceof GipsImplicationBoolExpr impl) {
				leftSelf = containsSelf(impl.getLeft(), type);
				rightSelf = containsSelf(impl.getRight(), type);
			} else if (expr instanceof GipsOrBoolExpr or) {
				leftSelf = containsSelf(or.getLeft(), type);
				rightSelf = containsSelf(or.getRight(), type);
			} else if (expr instanceof GipsAndBoolExpr and) {
				leftSelf = containsSelf(and.getLeft(), type);
				rightSelf = containsSelf(and.getRight(), type);
			} else if (expr instanceof GipsNotBoolExpr not) {
				leftSelf = containsSelf(not.getOperand(), type);
				rightSelf = leftSelf;
			} else if (expr instanceof GipsBracketBoolExpr brack) {
				leftSelf = containsSelf(brack.getOperand(), type);
				rightSelf = leftSelf;
			} else if (expr instanceof GipsBooleanLiteral) {
				leftSelf = rightSelf = false;
			} else {
				throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
			}
		} else if (expr == null) {
			error( //
					String.format(CONSTRAINT_EMPTY_MESSAGE), //
					constraint, //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}

		// Generate an error if both sides of the constraint does not contain 'self'
		if (!(leftSelf || rightSelf)) {
			error( //
					String.format(TYPE_DOES_NOT_CONTAIN_SELF_MESSAGE, "Constraint"), //
					constraint, //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
		}
	}

	/**
	 * Returns the context type of a given EObject.
	 * 
	 * @param e EObject to determine context type for.
	 * @return Context type for given EObject.
	 */
	public ContextType getContextType(final EObject e) {
		ContextType type = ContextType.ERROR;

		if (e instanceof GipsPatternContext) {
			type = ContextType.PATTERN;
		} else if (e instanceof GipsTypeContext) {
			type = ContextType.TYPE;
		} else if (e instanceof GipsMappingContext) {
			type = ContextType.MAPPING;
		}

		return type;
	}

	/**
	 * Returns true if given arithmetic expression contains a self reference.
	 * 
	 * @param expr Arithmetic expression to check.
	 * @param type Context type.
	 * @return True if given arithmetic expression contains a self reference.
	 */
	public boolean containsSelf(final GipsArithmeticExpr expr, final ContextType type) {
		if (expr == null) {
			return false;
		}

		if (type == null) {
			throw new IllegalArgumentException();
		}

		if (expr instanceof GipsBracketExpr) {
			final GipsBracketExpr bracketExpr = (GipsBracketExpr) expr;
			return containsSelf(bracketExpr.getOperand(), type);
		} else if (expr instanceof GipsExpArithmeticExpr) {
			final GipsExpArithmeticExpr expExpr = (GipsExpArithmeticExpr) expr;
			return containsSelf(expExpr.getLeft(), type) || containsSelf(expExpr.getRight(), type);
		} else if (expr instanceof GipsExpressionOperand) {
			final GipsExpressionOperand exprOp = (GipsExpressionOperand) expr;
			if (exprOp instanceof GipsArithmeticLiteral) {
				return false;
			} else if (exprOp instanceof GipsAttributeExpr) {
				if (exprOp instanceof GipsContextExpr) {
					// Context expression is always a 'self' access
					return true;
				} else if (exprOp instanceof GipsLambdaAttributeExpression) {
					// A GipsLambdaAttributeExpression can not contain a 'self' access
					return false;
				} else if (exprOp instanceof GipsLambdaSelfExpression) {
					// A GipsLambdaSelfExpression, despite its name, can not contain 'self' access
					// to the constraint / objective context.
					return false;
				} else if (exprOp instanceof GipsMappingAttributeExpr attrExpr) {
					return containsSelf(attrExpr.getExpr(), type);
				} else if (exprOp instanceof GipsPatternAttributeExpr patternExpr) {
					return containsSelf(patternExpr.getExpr(), type);
				} else if (exprOp instanceof GipsTypeAttributeExpr typeExpr) {
					return containsSelf(typeExpr.getExpr(), type);
				} else if (expr instanceof GipsConstant) {
					return false;
				}

				throw new UnsupportedOperationException(
						NOT_IMPLEMENTED_EXCEPTION_MESSAGE + ": <" + expr.eClass() + ">");
			} else if (expr instanceof GipsConstant) {
				return false;
			} else if (expr instanceof GipsObjectiveExpression) {
				return false;
			}

			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE + ": <" + expr.eClass() + ">");
		} else if (expr instanceof GipsProductArithmeticExpr) {
			final GipsProductArithmeticExpr prodExpr = (GipsProductArithmeticExpr) expr;
			return containsSelf(prodExpr.getLeft(), type) || containsSelf(prodExpr.getRight(), type);
		} else if (expr instanceof GipsSumArithmeticExpr) {
			final GipsSumArithmeticExpr sumExpr = (GipsSumArithmeticExpr) expr;
			return containsSelf(sumExpr.getLeft(), type) || containsSelf(sumExpr.getRight(), type);
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			final GipsUnaryArithmeticExpr unExpr = (GipsUnaryArithmeticExpr) expr;
			return containsSelf(unExpr.getOperand(), type);
		} else if (expr instanceof GipsConstant) {
			return false;
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE + ": <" + expr.eClass() + ">");
	}

	/**
	 * Returns true if a given stream expression contains a self reference.
	 * 
	 * @param expr Stream expression to check.
	 * @param type Context type.
	 * @return True if given stream expression contains a self reference.
	 */
	public boolean containsSelf(final GipsStreamExpr expr, final ContextType type) {
		if (expr == null) {
			return false;
		}

		if (type == null) {
			throw new IllegalArgumentException();
		}

		if (expr instanceof GipsSelect) {
			// Stream -> no self
			return false;
		} else if (expr instanceof GipsStreamArithmetic) {
			// sum() -> validate lambda
			final GipsStreamArithmetic arithExpr = (GipsStreamArithmetic) expr;
			return containsSelf(arithExpr.getLambda().getExpr(), type);
		} else if (expr instanceof GipsStreamBoolExpr) {
			// Boolean operator -> no self
			return false;
		} else if (expr instanceof GipsStreamNavigation) {
			final GipsStreamNavigation navExpr = (GipsStreamNavigation) expr;
			return containsSelf(navExpr.getLeft(), type) || containsSelf(navExpr.getRight(), type);
		} else if (expr instanceof GipsStreamSet) {
			// filter() -> validate lambda
			final GipsStreamSet setExpr = (GipsStreamSet) expr;
			return containsSelf(setExpr.getLambda().getExpr(), type);
		} else if (expr instanceof GipsContains contains) {
			return containsSelf(contains.getExpr(), type);
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * Returns true if given boolean expression contains a self reference.
	 * 
	 * @param expr Boolean expression to check.
	 * @param type Context type.
	 * @return True if given boolean expression contains a self reference.
	 */
	public boolean containsSelf(final GipsBoolExpr expr, final ContextType type) {
		if (expr == null) {
			return false;
		}

		if (type == null) {
			throw new IllegalArgumentException();
		}

		if (expr instanceof GipsImplicationBoolExpr impl) {
			return containsSelf(impl.getLeft(), type) || containsSelf(impl.getRight(), type);
		} else if (expr instanceof GipsOrBoolExpr or) {
			return containsSelf(or.getLeft(), type) || containsSelf(or.getRight(), type);
		} else if (expr instanceof GipsAndBoolExpr and) {
			return containsSelf(and.getLeft(), type) || containsSelf(and.getRight(), type);
		} else if (expr instanceof GipsNotBoolExpr not) {
			return containsSelf(not.getOperand(), type);
		} else if (expr instanceof GipsBracketBoolExpr brack) {
			return containsSelf(brack.getOperand(), type);
		} else if (expr instanceof GipsBooleanLiteral) {
			return false;
		} else if (expr instanceof GipsRelExpr) {
			final GipsRelExpr relExpr = (GipsRelExpr) expr;
			return containsSelf(relExpr.getLeft(), type) || containsSelf(relExpr.getRight(), type);
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}

	}

	// TODO: Das andere was ich gemerkt habe ist auch, dass du keine mapping.value()
	// ausdrcke in den Arithmetischen Ausdrck innerhalb von sum() haben darfst,
	// wenn du bereits in der Filterfunktion auf mappings zugreifst.
	/**
	 * Validates constraints regarding their dynamic parts. Currently, the following
	 * rule set is implemented: Forbidden input for non-linear mathematical
	 * functions (abs, sin, cos, sqrt, pow): self.isMapped() (only for context =
	 * mapping? -> currently no ...), mappings.xy->count/sum + exists/notExists
	 * 
	 * @param constraint Constraint to check dynamic elements for.
	 */
	public void validateConstraintDynamic(final GipsConstraint constraint) {
		if (constraint == null || constraint.getExpr() == null || constraint.getExpr().getExpr() == null) {
			return;
		}

		final GipsBoolExpr expr = constraint.getExpr().getExpr();

		boolean leftDynamic = false;
		boolean rightDynamic = false;

		if (expr instanceof GipsRelExpr) {
			final GipsRelExpr relExpr = (GipsRelExpr) expr;
			leftDynamic = validateArithExprDynamic(relExpr.getLeft());
			rightDynamic = validateArithExprDynamic(relExpr.getRight());
		} else if (expr instanceof GipsBoolExpr) {
			if (expr instanceof GipsImplicationBoolExpr impl) {
				leftDynamic = validateBoolExprDynamic(impl.getLeft());
				rightDynamic = validateBoolExprDynamic(impl.getRight());
			} else if (expr instanceof GipsOrBoolExpr or) {
				leftDynamic = validateBoolExprDynamic(or.getLeft());
				rightDynamic = validateBoolExprDynamic(or.getRight());
			} else if (expr instanceof GipsAndBoolExpr and) {
				leftDynamic = validateBoolExprDynamic(and.getLeft());
				rightDynamic = validateBoolExprDynamic(and.getRight());
			} else if (expr instanceof GipsNotBoolExpr not) {
				leftDynamic = validateBoolExprDynamic(not.getOperand());
				rightDynamic = leftDynamic;
			} else if (expr instanceof GipsBracketBoolExpr brack) {
				leftDynamic = validateBoolExprDynamic(brack.getOperand());
				rightDynamic = leftDynamic;
			} else if (expr instanceof GipsBooleanLiteral) {
				// Special case: Complete boolean expression is just a literal
				return;
			} else {
				throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
			}
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}

		// Generate a warning if both sides of the constraint are constant
		if (!leftDynamic && !rightDynamic) {
			warning( //
					CONSTRAINT_HAS_TWO_CONSTANT_SIDES_MESSAGE, //
					constraint, //
					GipslPackage.Literals.GIPS_CONSTRAINT__EXPR //
			);
		}
	}

	public boolean validateBoolExprDynamic(final GipsBoolExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsImplicationBoolExpr impl) {
			return validateBoolExprDynamic(impl.getLeft()) || validateBoolExprDynamic(impl.getRight());
		} else if (expr instanceof GipsOrBoolExpr or) {
			return validateBoolExprDynamic(or.getLeft()) || validateBoolExprDynamic(or.getRight());
		} else if (expr instanceof GipsAndBoolExpr and) {
			return validateBoolExprDynamic(and.getLeft()) || validateBoolExprDynamic(and.getRight());
		} else if (expr instanceof GipsNotBoolExpr not) {
			return validateBoolExprDynamic(not.getOperand());
		} else if (expr instanceof GipsBracketBoolExpr brack) {
			return validateBoolExprDynamic(brack.getOperand());
		} else if (expr instanceof GipsBooleanLiteral) {
			// Special case: Complete boolean expression is just a literal
			return false;
		} else if (expr instanceof GipsRelExpr) {
			final GipsRelExpr relExpr = (GipsRelExpr) expr;
			return validateArithExprDynamic(relExpr.getLeft()) || validateArithExprDynamic(relExpr.getRight());
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}
	}

	public boolean validateArithExprDynamic(final GipsArithmeticExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsBracketExpr) {
			final GipsBracketExpr bracketExpr = (GipsBracketExpr) expr;
			return validateArithExprDynamic(bracketExpr.getOperand());
		} else if (expr instanceof GipsExpArithmeticExpr) {
			final GipsExpArithmeticExpr expExpr = (GipsExpArithmeticExpr) expr;
			final boolean dynLeft = validateArithExprDynamic(expExpr.getLeft());
			final boolean dynRight = validateArithExprDynamic(expExpr.getRight());
			if (dynLeft) {
				error( //
						EXP_EXPR_NOT_CONSTANT_MESSAGE, //
						expr, //
						GipslPackage.Literals.GIPS_EXP_ARITHMETIC_EXPR__LEFT //
				);
			}
			if (dynRight) {
				error( //
						EXP_EXPR_NOT_CONSTANT_MESSAGE, //
						expr, //
						GipslPackage.Literals.GIPS_EXP_ARITHMETIC_EXPR__RIGHT //
				);
			}
			return dynLeft || dynRight;
		} else if (expr instanceof GipsExpressionOperand) {
			final GipsExpressionOperand exprOp = (GipsExpressionOperand) expr;
			if (exprOp instanceof GipsArithmeticLiteral) {
				return false;
			} else if (exprOp instanceof GipsAttributeExpr) {
				if (exprOp instanceof GipsContextExpr) {
					final GipsContextExpr conExpr = (GipsContextExpr) exprOp;
					// Currently only MAPPED and VALUE are supported -> Both are dynamic
					return conExpr.getExpr() instanceof GipsVariableOperationExpression;
					// TODO: Use the solution below. But, in order for this to work, we need to
					// implement a multivariate return value (Enum type), which conveys more
					// information that just "there is a mapping access of some kind".
//					EObject container = (EObject) GipslScopeContextUtil.getContainer(expr,
//							Set.of(GipsConstraintImpl.class, GipsObjectiveImpl.class));
//					EObject context = null;
//					if (container instanceof GipsConstraint constraint) {
//						context = constraint.getContext();
//					} else if (container instanceof GipsObjective objective) {
//						context = objective.getContext();
//					} else {
//						return false;
//					}
//
//					if (context instanceof GipsMappingContext) {
//						return true;
//					} else {
//						return false;
//					}
				} else if (exprOp instanceof GipsLambdaAttributeExpression) {
					// Nothing to do here
					return false;
				} else if (exprOp instanceof GipsLambdaSelfExpression) {
					// Nothing to do here
					return false;
				} else if (exprOp instanceof GipsMappingAttributeExpr mappingExpr) {
					validateStreamExprDynamic(mappingExpr.getExpr());
					return true;
				} else if (exprOp instanceof GipsPatternAttributeExpr patternExpr) {
					return validateStreamExprDynamic(patternExpr.getExpr());
				} else if (exprOp instanceof GipsTypeAttributeExpr typeExpr) {
					return validateStreamExprDynamic(typeExpr.getExpr());
				}
			} else if (exprOp instanceof GipsObjectiveExpression) {
				// Only relevant for the global objective function
				return true;
			} else if (exprOp instanceof GipsConstant) {
				return false;
			}

			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE + ": <" + expr + ">");
		} else if (expr instanceof GipsProductArithmeticExpr) {
			final GipsProductArithmeticExpr prodExpr = (GipsProductArithmeticExpr) expr;
			final boolean dynLeft = validateArithExprDynamic(prodExpr.getLeft());
			final boolean dynRight = validateArithExprDynamic(prodExpr.getRight());
			if (dynLeft && dynRight) {
				error( //
						PRODUCT_EXPR_NOT_CONSTANT_MESSAGE, //
						expr, //
						GipslPackage.Literals.GIPS_PRODUCT_ARITHMETIC_EXPR__RIGHT //
				);
			}
			return dynLeft || dynRight;
		} else if (expr instanceof GipsSumArithmeticExpr) {
			final GipsSumArithmeticExpr sumExpr = (GipsSumArithmeticExpr) expr;
			return validateArithExprDynamic(sumExpr.getLeft()) | validateArithExprDynamic(sumExpr.getRight());
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			final GipsUnaryArithmeticExpr unExpr = (GipsUnaryArithmeticExpr) expr;
			final boolean isDyn = validateArithExprDynamic(unExpr.getOperand());
			if (isDyn && unExpr.getOperator() != GipsArithmeticUnaryOperator.NEG) {
				error( //
						String.format(UNARY_ARITH_EXPR_NOT_CONSTANT_MESSAGE, unExpr.getOperator()), //
						expr, //
						GipslPackage.Literals.GIPS_UNARY_ARITHMETIC_EXPR__OPERAND //
				);
			}
			return isDyn;
		} else if (expr instanceof GipsConstant) {
			return false;
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE + ": <" + expr + ">");
	}

	public boolean validateStreamExprDynamic(final GipsStreamExpr expr) {
		if (expr == null) {
			return false;
		}

		if (expr instanceof GipsStreamNavigation) {
			final GipsStreamNavigation nav = (GipsStreamNavigation) expr;
			return validateStreamExprDynamic(nav.getLeft()) | validateStreamExprDynamic(nav.getRight());
		} else if (expr instanceof GipsStreamSet) { // .filter(...)
			final GipsStreamSet set = (GipsStreamSet) expr;
			// set.getOperator(); // operator is always a filter -> output is a set
			return validateBoolExprDynamic(set.getLambda().getExpr());
		} else if (expr instanceof GipsStreamArithmetic) { // .sum(...)
			final GipsStreamArithmetic arith = (GipsStreamArithmetic) expr;
			// arith.getOperator(); // operator is always an integer/a double
			return validateBoolExprDynamic(arith.getLambda().getExpr());
		} else if (expr instanceof GipsStreamBoolExpr) { // .exists(); .notExists(); .count()
			return false;
		} else if (expr instanceof GipsContains contains) {
			return validateArithExprDynamic(contains.getExpr());
		} else if (expr instanceof GipsSelect) {
			return false;
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	/**
	 * Runs all checks for a given objective.
	 * 
	 * @param objective Gips objective to check.
	 */
	@Check
	public void checkObjective(final GipsObjective objective) {
		if (objective == null) {
			return;
		}

		// Check for bad names
		checkObjectiveNameValid(objective);

		// Check uniqueness of name
		checkObjectiveNameUnique(objective);

		// Check if value is 0
		checkObjectiveIsNotUseless(objective);

		// Validate arithmetic expression regarding non-linear expressions that are not
		// constant in ILP time
		validateArithExprDynamic(objective.getExpr());

		// Check if objective contains a 'self' call -> If not, display a warning
		checkObjectiveHasSelf(objective);

		// Check expression evaluation type
		final EvalType eval = getEvalTypeFromArithExpr(objective.getExpr());
		if (eval != EvalType.INTEGER && eval != EvalType.DOUBLE) {
			error( //
					OBJECTIVE_EVAL_NOT_NUMBER_MESSAGE, //
					GipslPackage.Literals.GIPS_OBJECTIVE__EXPR //
			);
		}
	}

	/**
	 * Checks that an objective has at least one 'self' reference.
	 * 
	 * @param objective Objective to validate.
	 */
	public void checkObjectiveHasSelf(final GipsObjective objective) {
		if (objective == null || objective.getExpr() == null || objective.getContext() == null) {
			return;
		}

		final GipsArithmeticExpr expr = objective.getExpr();
		final ContextType type = getContextType(objective.getContext());

		// Generate a warning if the objective does not contain 'self'
		if (!containsSelf(expr, type)) {
			warning( //
					String.format(TYPE_DOES_NOT_CONTAIN_SELF_MESSAGE, "Objective"), //
					objective, //
					GipslPackage.Literals.GIPS_OBJECTIVE__EXPR //
			);
		}
	}

	/**
	 * Checks for validity of an objective name. The name must not be on the list of
	 * invalid names, the name should be in lowerCamelCase, and the name should
	 * start with a lower case character.
	 * 
	 * @param objective Gips objective to check.
	 */
	public void checkObjectiveNameValid(final GipsObjective objective) {
		if (objective == null || objective.getName() == null) {
			return;
		}

		if (INVALID_NAMES.contains(objective.getName())) {
			error( //
					String.format(OBJECTIVE_NAME_FORBIDDEN_MESSAGE, objective.getName()), //
					GipslPackage.Literals.GIPS_OBJECTIVE__NAME, //
					NAME_BLOCKED //
			);
		} else {
			// The objective name should be lowerCamelCase.
			if (objective.getName().contains("_")) {
				warning( //
						String.format(OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE, objective.getName()), //
						GipslPackage.Literals.GIPS_OBJECTIVE__NAME, //
						NAME_BLOCKED //
				);
			} else {
				// The objective name should start with a lower case character.
				if (!Character.isLowerCase(objective.getName().charAt(0))) {
					warning( //
							String.format(OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, objective.getName()), //
							GipslPackage.Literals.GIPS_OBJECTIVE__NAME, //
							NAME_EXPECT_LOWER_CASE //
					);
				}
			}
		}
	}

	/**
	 * Checks the uniqueness of the name of a given Gips objective.
	 * 
	 * @param objective Gips objective to check uniqueness of the name for.
	 */
	public void checkObjectiveNameUnique(final GipsObjective objective) {
		if (objective == null || objective.eContainer() == null) {
			return;
		}

		final EditorGTFile container = (EditorGTFile) objective.eContainer();
		final long count = container.getObjectives().stream()
				.filter(o -> o.getName() != null && o.getName().equals(objective.getName())).count();
		if (count != 1) {
			error( //
					String.format(OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE, objective.getName(),
							getTimes((int) count)), //
					GipslPackage.Literals.GIPS_OBJECTIVE__NAME, //
					NAME_EXPECT_UNIQUE //
			);
		}
	}

	/**
	 * Checks a given Gips objective for uselessness, i.e, if the objective is '0'.
	 * 
	 * @param objective Gips objective to check for uselessness.
	 */
	public void checkObjectiveIsNotUseless(final GipsObjective objective) {
		if (objective == null) {
			return;
		}

		if (objective.getExpr() instanceof GipsArithmeticLiteral) {
			final GipsArithmeticLiteral lit = (GipsArithmeticLiteral) objective.getExpr();
			if (lit.getValue() != null && lit.getValue().equals("0")) {
				warning( //
						String.format(OBJECTIVE_VALUE_IS_ZERO_MESSAGE, objective.getName()), //
						GipslPackage.Literals.GIPS_OBJECTIVE__EXPR //
				);
			}
		}
	}

	// TODO: Is this even necessary?
	@Check
	public void checkArithmeticLiteralParsable(final GipsArithmeticLiteral literal) {
		if (literal == null) {
			return;
		}

		try {
			Double.valueOf(literal.getValue());
		} catch (final NumberFormatException ex) {
			error( //
					LITERAL_NOT_PARSABLE_MESSAGE, //
					GipslPackage.Literals.GIPS_ARITHMETIC_LITERAL__VALUE //
			);
		}
	}

	public EvalType getEvalTypeFromBoolExpr(final GipsBoolExpr expr) {
		EvalType output = EvalType.ERROR;

		// Determine output type of this expression
		if (expr instanceof GipsImplicationBoolExpr impl) {
			output = getEvalLeftRightSideOp(impl.getLeft(), impl.getRight());
		} else if (expr instanceof GipsOrBoolExpr or) {
			output = getEvalLeftRightSideOp(or.getLeft(), or.getRight(), or.getOperator());
		} else if (expr instanceof GipsAndBoolExpr and) {
			output = getEvalLeftRightSideOp(and.getLeft(), and.getRight(), and.getOperator());
		} else if (expr instanceof GipsNotBoolExpr not) {
			output = getEvalLEftRightSideOp(not.getOperand());
		} else if (expr instanceof GipsBracketBoolExpr brack) {
			output = getEvalLEftRightSideOp(brack.getOperand());
		} else if (expr instanceof GipsBooleanLiteral) {
			output = EvalType.BOOLEAN;
		} else if (expr instanceof GipsRelExpr relExpr) {
			final EvalType leftType = getEvalTypeDelegate(relExpr.getLeft());
			final EvalType rightType = getEvalTypeDelegate(relExpr.getRight());
			output = combine(leftType, rightType, relExpr.getOperator());

			// Special case: expr is an instance of GipsRelExpr, the rhs is null, and the
			// container is not directly the constraint -> skip error, because output is not
			// necessarily a boolean
			if (relExpr.getRight() == null && !(expr.eContainer() instanceof GipsBool)) {
				return output;
			}

			// Special case: If sub types did not return an error but the combination
			// produced an error, we have to generate an error
			if (output == EvalType.ERROR && leftType != EvalType.ERROR && rightType != EvalType.ERROR) {
				error( //
						BOOL_EXPR_EVAL_ERROR_MESSAGE, //
						expr, //
						GipslPackage.Literals.GIPS_REL_EXPR__OPERATOR //
				);
				return output;
			}
		}

		// If the output is not a boolean, display an error but only if the output isn't
		// an error
		if (output != EvalType.BOOLEAN && output != EvalType.ERROR) {
			error( //
					BOOL_EXPR_EVAL_ERROR_MESSAGE, //
					expr, //
					GipslPackage.Literals.GIPS_REL_EXPR__OPERATOR //
			);
		}
		return output;
	}

	public EvalType getEvalTypeFromArithExpr(final GipsArithmeticExpr expr) {
		EvalType output = EvalType.ERROR;
		boolean leaf = true;

		if (expr instanceof GipsBracketExpr) {
			final GipsBracketExpr brack = (GipsBracketExpr) expr;
			output = getEvalTypeFromArithExpr(brack.getOperand());
			leaf = false;
		} else if (expr instanceof GipsExpArithmeticExpr) {
			final GipsExpArithmeticExpr exp = (GipsExpArithmeticExpr) expr;
			final EvalType leftType = getEvalTypeDelegate(exp.getLeft());
			final EvalType rightType = getEvalTypeDelegate(exp.getRight());
			output = combine(leftType, rightType, exp.getOperator());
		} else if (expr instanceof GipsProductArithmeticExpr) {
			final GipsProductArithmeticExpr prod = (GipsProductArithmeticExpr) expr;
			final EvalType leftType = getEvalTypeDelegate(prod.getLeft());
			final EvalType rightType = getEvalTypeDelegate(prod.getRight());
			output = combine(leftType, rightType, prod.getOperator());
		} else if (expr instanceof GipsSumArithmeticExpr) {
			final GipsSumArithmeticExpr sum = (GipsSumArithmeticExpr) expr;
			final EvalType leftType = getEvalTypeDelegate(sum.getLeft());
			final EvalType rightType = getEvalTypeDelegate(sum.getRight());
			output = combine(leftType, rightType, sum.getOperator());
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			final EvalType operand = getEvalTypeFromArithExpr(((GipsUnaryArithmeticExpr) expr).getOperand());
			output = combine(operand, ((GipsUnaryArithmeticExpr) expr).getOperator());

			// Special case: sqrt(<0) should display an error -> Implementation for
			// constants (basic)
			// This could later be extended to also check more complex expressions or it
			// could be integrated into the ILP validator
			if (((GipsUnaryArithmeticExpr) expr).getOperator() == GipsArithmeticUnaryOperator.SQRT) {
				final GipsArithmeticExpr inSqrt = ((GipsUnaryArithmeticExpr) expr).getOperand();
				if (inSqrt instanceof GipsArithmeticLiteral) {
					final GipsArithmeticLiteral lit = (GipsArithmeticLiteral) inSqrt;
					try {
						double val = Double.valueOf(lit.getValue());
						if (val < 0) {
							error( //
									SQRT_VALUE_SMALLER_THAN_ZERO, //
									expr, //
									getLiteralType(expr) //
							);
						}
					} catch (final NumberFormatException ex) {
						// This case is covered by type evaluation
					}
				}
			}
		} else if (expr instanceof GipsExpressionOperand) {
			output = getEvalTypeFromExprOp((GipsExpressionOperand) expr);
			leaf = false;
		}

		// If the output is an error and this method call was a leaf, display an error
		if (output != null && output == EvalType.ERROR && leaf && expr != null) {
			error( //
					ARITH_EXPR_EVAL_ERROR_MESSAGE, //
					expr, //
					getLiteralType(expr) //
			);
		}
		return output;
	}

	/**
	 * Determines the literal type for a given EObject.
	 * 
	 * @param expr EObject which is an expression from Gips.
	 * @return Literal from GipslPackage.Literals.
	 */
	public EStructuralFeature getLiteralType(final EObject expr) {
		EStructuralFeature type = null;

		if (expr instanceof GipsBracketExpr) {
			type = GipslPackage.Literals.GIPS_BRACKET_EXPR__OPERAND;
		} else if (expr instanceof GipsExpArithmeticExpr) {
			type = GipslPackage.Literals.GIPS_EXP_ARITHMETIC_EXPR__LEFT;
		} else if (expr instanceof GipsProductArithmeticExpr) {
			type = GipslPackage.Literals.GIPS_PRODUCT_ARITHMETIC_EXPR__OPERATOR;
		} else if (expr instanceof GipsSumArithmeticExpr) {
			type = GipslPackage.Literals.GIPS_SUM_ARITHMETIC_EXPR__OPERATOR;
		} else if (expr instanceof GipsUnaryArithmeticExpr) {
			type = GipslPackage.Literals.GIPS_UNARY_ARITHMETIC_EXPR__OPERAND;
		} else if (expr instanceof GipsExpressionOperand) {
			if (expr instanceof GipsArithmeticLiteral) {
				type = GipslPackage.Literals.GIPS_ARITHMETIC_LITERAL__VALUE;
			} else if (expr instanceof GipsAttributeExpr) {
				if (expr instanceof GipsMappingAttributeExpr) {
					type = GipslPackage.Literals.GIPS_MAPPING_ATTRIBUTE_EXPR__EXPR;
				} else if (expr instanceof GipsPatternAttributeExpr) {
					type = GipslPackage.Literals.GIPS_PATTERN_ATTRIBUTE_EXPR__EXPR;
				} else if (expr instanceof GipsTypeAttributeExpr) {
					type = GipslPackage.Literals.GIPS_TYPE_ATTRIBUTE_EXPR__EXPR;
				} else if (expr instanceof GipsContextExpr) {
					type = GipslPackage.Literals.GIPS_CONTEXT_EXPR__EXPR;
				} else if (expr instanceof GipsLambdaAttributeExpression) {
					type = GipslPackage.Literals.GIPS_LAMBDA_ATTRIBUTE_EXPRESSION__EXPR;
				} else if (expr instanceof GipsLambdaSelfExpression) {
					type = GipslPackage.Literals.GIPS_LAMBDA_SELF_EXPRESSION__VAR;
				}
			} else if (expr instanceof GipsObjectiveExpression) {
				type = GipslPackage.Literals.GIPS_OBJECTIVE_EXPRESSION__OBJECTIVE;
			}
		}

		return type;
	}

	public EvalType getEvalTypeFromExprOp(final GipsExpressionOperand op) {
		if (op instanceof GipsArithmeticLiteral) {
			return getEvalTypeFromArithLit((GipsArithmeticLiteral) op);
		} else if (op instanceof GipsAttributeExpr) {
			return getEvalTypeFromAttrExpr((GipsAttributeExpr) op);
		} else if (op instanceof GipsObjectiveExpression) {
			return EvalType.OBJECTIVE;
		} else if (op instanceof GipsConstant) {
			return getEvalTypeFromGipsConst((GipsConstant) op);
		}

		return EvalType.ERROR;
	}

	public EvalType getEvalTypeFromGipsConst(final GipsConstant con) {
		switch (con.getValue()) {
		case E, PI -> {
			return EvalType.DOUBLE;
		}
		case NULL -> {
			return EvalType.NULL;
		}
		default -> {
			return EvalType.ERROR;
		}
		}
	}

	public EvalType getEvalTypeFromAttrExpr(final GipsAttributeExpr expr) {
		if (expr instanceof GipsMappingAttributeExpr mapExpr) {
			return getEvalTypeFromStreamExpr(mapExpr.getExpr());
		} else if (expr instanceof GipsPatternAttributeExpr patternExpr) {
			return getEvalTypeFromStreamExpr(patternExpr.getExpr());
		} else if (expr instanceof GipsTypeAttributeExpr typeExpr) {
			return getEvalTypeFromStreamExpr(typeExpr.getExpr());
		} else if (expr instanceof GipsContextExpr) {
			final GipsContextExpr conExpr = (GipsContextExpr) expr;
			return getEvalTypeFromContextExpr(conExpr);
		} else if (expr instanceof GipsLambdaAttributeExpression) {
			final GipsLambdaAttributeExpression lambExpr = (GipsLambdaAttributeExpression) expr;
			return getEvalTypeFromLambdaAttrExpr(lambExpr);
		} else if (expr instanceof GipsLambdaSelfExpression lSelf) {
			return getEvalTypeFromLambdaAttrExpr(lSelf);
		}

		return EvalType.ERROR;
	}

	public EvalType getEvalTypeFromStreamExpr(final GipsStreamExpr expr) {
		if (expr instanceof GipsStreamNavigation) {
			final GipsStreamNavigation nav = (GipsStreamNavigation) expr;
			return getEvalTypeFromStreamNav(nav);
		} else if (expr instanceof GipsStreamSet) { // .filter(...)
			final GipsStreamSet set = (GipsStreamSet) expr;
			// set.getOperator(); // operator is always a filter -> output is a set
			validateLambdaExpr(set.getLambda());
			return EvalType.SET;
		} else if (expr instanceof GipsStreamArithmetic) { // .sum(...)
			final GipsStreamArithmetic arith = (GipsStreamArithmetic) expr;
			// arith.getOperator(); // operator is always an integer/a double
			validateLambdaExpr(arith.getLambda());
			return EvalType.DOUBLE;
		} else if (expr instanceof GipsStreamBoolExpr) { // .exists(); .notExists(); .count()
			final GipsStreamBoolExpr boolExpr = (GipsStreamBoolExpr) expr;
			return getEvalTypeFromStreamNoArgOp(boolExpr.getOperator());
		} else if (expr instanceof GipsSelect) {
			return EvalType.STREAM;
		} else if (expr instanceof GipsContains) {
			return EvalType.BOOLEAN;
		}

		return EvalType.ERROR;
	}

	public EvalType getEvalTypeFromStreamNav(final GipsStreamNavigation nav) {
		final GipsStreamExpr left = nav.getLeft();
		final GipsStreamExpr right = nav.getRight();

		final EvalType lhs = getEvalTypeFromStreamExpr(left);

		// Case: lhs is a stream set and rhs is a stream boolean expression (NOT
		// count()) = boolean
		if (left instanceof GipsStreamSet && right instanceof GipsStreamBoolExpr //
				&& ((GipsStreamBoolExpr) right).getOperator().getValue() != GipsStreamNoArgOperator.COUNT_VALUE) {
			return EvalType.BOOLEAN;
		}

		// Case: lhs is a stream set and rhs is a stream boolean expression (count()) =
		// integer
		if (left instanceof GipsStreamSet && lhs == EvalType.SET && right instanceof GipsStreamBoolExpr
				&& ((GipsStreamBoolExpr) right).getOperator().getValue() == GipsStreamNoArgOperator.COUNT_VALUE) {
			return EvalType.INTEGER;
		}

		// Case: else
		return getEvalTypeFromStreamExpr(right);
	}

	public EvalType getEvalTypeFromStreamNoArgOp(final GipsStreamNoArgOperator op) {
		final int val = op.getValue();
		if (val == GipsStreamNoArgOperator.COUNT_VALUE) {
			return EvalType.INTEGER;
		} else if (val == GipsStreamNoArgOperator.NOT_EMPTY_VALUE) {
			return EvalType.BOOLEAN;
		}

		return EvalType.ERROR;
	}

	public EvalType getEvalTypeFromStreamSet(final GipsStreamSet set) {
		validateLambdaExpr(set.getLambda());
		if (set.getOperator().getValue() == GipsStreamSetOperator.FILTER_VALUE) {
			return EvalType.SET;
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	public EvalType getEvalTypeFromLambdaAttrExpr(final GipsLambdaAttributeExpression expr) {
		final EObject innerExpr = expr.getExpr();
		if (innerExpr instanceof GipsNodeAttributeExpr) {
			return getEvalTypeFromNodeAttrExpr((GipsNodeAttributeExpr) innerExpr);
		} else if (innerExpr instanceof GipsVariableOperationExpression) {
			return getEvalTypeFromContextOpExpr((GipsVariableOperationExpression) innerExpr);
		} else if (innerExpr instanceof GipsFeatureExpr) {
			return getEvalTypeFromFeatureExpr((GipsFeatureExpr) innerExpr);
		}

		throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
	}

	public EvalType getEvalTypeFromLambdaAttrExpr(final GipsLambdaSelfExpression expr) {
		return EvalType.ECLASS;
	}

	public EvalType getEvalTypeFromContextExpr(final GipsContextExpr expr) {
		EvalType exprEval = EvalType.CONTEXT;
		if (expr.getExpr() != null) {
			final EObject innerExpr = expr.getExpr();
			if (innerExpr instanceof GipsNodeAttributeExpr) {
				exprEval = getEvalTypeFromNodeAttrExpr((GipsNodeAttributeExpr) innerExpr);
			} else if (innerExpr instanceof GipsVariableOperationExpression) {
				exprEval = getEvalTypeFromContextOpExpr((GipsVariableOperationExpression) innerExpr);
			} else if (innerExpr instanceof GipsFeatureExpr) {
				exprEval = getEvalTypeFromFeatureExpr((GipsFeatureExpr) innerExpr);
			}
		}

		// Expr returns a set and stream is set
		if (expr.getStream() != null && exprEval == EvalType.SET) {
			return getEvalTypeFromStreamExpr(expr.getStream());
		} else if (expr.getStream() != null && exprEval != EvalType.SET) {
			// Expr does NOT return a set and stream is set -> violation
			error( //
					STREAM_ON_NON_COLLECTION_TYPE_MESSAGE, //
					expr, //
					GipslPackage.Literals.GIPS_CONTEXT_EXPR__STREAM //
			);
			return getEvalTypeFromStreamExpr(expr.getStream());
		}

		// Stream is null -> return expr eval
		// No need to check type casts
		return exprEval;
	}

	public EvalType getEvalTypeFromContextOpExpr(final GipsVariableOperationExpression expr) {
		if (expr instanceof GipsMappingCheckValue) {
			return EvalType.BOOLEAN;
		} else if (expr instanceof GipsMappingValue) {
			return EvalType.INTEGER;
		}

		return EvalType.ERROR;
	}

	public EvalType getEvalTypeFromNodeAttrExpr(final GipsNodeAttributeExpr expr) {
		// Type cast must not be checked
		// If expr is not set, evaluate node itself
		if (expr.getExpr() == null) {
			return getEvalTypeFromEditorNode(expr.getNode());
		} else {
			return getEvalTypeFromFeatureExpr(expr.getExpr());
		}
	}

	public EvalType getEvalTypeFromEditorNode(final EditorNode node) {
		// TODO: Always an EClass?
		return EvalType.ECLASS;
	}

	public EvalType getEvalTypeFromFeatureExpr(final GipsFeatureExpr expr) {
		if (expr instanceof GipsFeatureNavigation) {
			final GipsFeatureNavigation nav = (GipsFeatureNavigation) expr;
			final EvalType leftType = getEvalTypeFromFeatureExpr(nav.getLeft());
			final EvalType rightType = getEvalTypeFromFeatureExpr(nav.getRight());

			// If left side is no ECLASS than there is a violation, but this should get
			// checked in the validation and not in the type evaluation
			if (leftType == EvalType.ECLASS) {
				return rightType;
			} else {
				throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
			}
		} else if (expr instanceof GipsFeatureLit) {
			final GipsFeatureLit lit = (GipsFeatureLit) expr;
			if (lit.getFeature() == null)
				return EvalType.ERROR;
			final EClassifier ecl = lit.getFeature().getEType();

			if (lit.getFeature().getUpperBound() == -1 || lit.getFeature().getUpperBound() > 1) {
				// Upper bound is larger than 1 or -1 (no limit)
				return EvalType.SET;
			} else if (ecl == EcorePackage.Literals.EDOUBLE || ecl == EcorePackage.Literals.ELONG) {
				return EvalType.DOUBLE;
			} else if (ecl == EcorePackage.Literals.EINT) {
				return EvalType.INTEGER;
			} else if (ecl == EcorePackage.Literals.ESTRING) {
				return EvalType.STRING;
			} else {
				return EvalType.ECLASS;
			}
			// Type cast must not be checked
		}

		return EvalType.ERROR;
	}

	/**
	 * Returns the evaluation type from a given GipsTypeCast (EClass) or null if
	 * cast isn't set (because it is optional).
	 * 
	 * @param cast GipsTypeCast to check.
	 * @return leafType EClass or null if cast not set.
	 */
	public EvalType getEvalTypeFromTypeCast(final GipsTypeCast cast) {
		return (cast != null && cast.getType() != null) ? EvalType.ECLASS : null;
	}

	public EvalType getEvalTypeFromArithLit(final GipsArithmeticLiteral lit) {
		// if (lit instanceof GipsDoubleLiteral) {
		//
		// }
		// TODO: ^There is no 'GipsDoubleLiteral' or 'GipsIntegerLiteral'

		final String val = lit.getValue();
		try {
			Integer.valueOf(val);
			return EvalType.INTEGER;
		} catch (final NumberFormatException ex) {
			// No int
		}
		try {
			Double.valueOf(val);
			return EvalType.DOUBLE;
		} catch (final NumberFormatException ex) {
			return EvalType.ERROR;
		}
	}

	public EvalType getEvalTypeDelegate(final EObject e) {
		if (e == null) {
			return null;
		}

		if (e instanceof GipsBoolExpr) {
			return getEvalTypeFromBoolExpr((GipsBoolExpr) e);
		} else if (e instanceof GipsArithmeticExpr) {
			return getEvalTypeFromArithExpr((GipsArithmeticExpr) e);
		} else if (e instanceof GipsBool) {
			return getEvalTypeFromBoolExpr(((GipsBool) e).getExpr());
		} else if (e instanceof GipsStreamSet) {
			return getEvalTypeFromStreamSet((GipsStreamSet) e);
		} else if (e instanceof GipsStreamBoolExpr) {
			return getEvalTypeFromStreamExpr((GipsStreamBoolExpr) e);
		}

		return EvalType.ERROR;
	}

	public EvalType getEvalLeftRightSideOp(final GipsBoolExpr left, final GipsBoolExpr right,
			final GipsAndOperator op) {
		if (right == null) {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		} else {
			final EvalType leftType = getEvalTypeDelegate(left);
			final EvalType rightType = getEvalTypeDelegate(right);
			return combine(leftType, rightType, op);
		}
	}

	public EvalType getEvalLeftRightSideOp(final GipsBoolExpr left, final GipsBoolExpr right, final GipsOrOperator op) {
		if (right == null) {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		} else {
			final EvalType leftType = getEvalTypeDelegate(left);
			final EvalType rightType = getEvalTypeDelegate(right);
			return combine(leftType, rightType, op);
		}
	}

	public EvalType getEvalLeftRightSideOp(final GipsBoolExpr left, final GipsBoolExpr right) {
		if (right == null) {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		} else {
			final EvalType leftType = getEvalTypeDelegate(left);
			final EvalType rightType = getEvalTypeDelegate(right);
			return combine(leftType, rightType);
		}
	}

	public EvalType getEvalLEftRightSideOp(final GipsBoolExpr operand) {
		final EvalType opType = getEvalTypeDelegate(operand);
		return combine(opType);
	}

	public EvalType combine(final EvalType left, final EvalType right, final GipsRelOperator op) {
		// Case: right side is null and operator did not change from default
		if (left != null && right == null && op == GipsRelOperator.GREATER) {
			return left;
		}

		// Case: Comparing numbers
		if ((left == EvalType.INTEGER || left == EvalType.DOUBLE)
				&& (right == EvalType.INTEGER || right == EvalType.DOUBLE)) {
			return EvalType.BOOLEAN;
		} else if ((left == EvalType.ECLASS || left == EvalType.CONTEXT)
				&& (right == EvalType.ECLASS || right == EvalType.CONTEXT)) {
			// Case: Comparing two from {EClass, Context}
			return EvalType.BOOLEAN;
		} else if ((left == EvalType.ECLASS || left == EvalType.NULL)
				&& (right == EvalType.ECLASS || right == EvalType.NULL)) {
			// Case: Comparing null with EClass
			return EvalType.BOOLEAN;
		} else if ((left == EvalType.CONTEXT || left == EvalType.NULL)
				&& (right == EvalType.CONTEXT || right == EvalType.NULL)) {
			// Case: Comparing null with Context
			return EvalType.BOOLEAN;
		} else {
			return EvalType.ERROR;
		}
	}

	public EvalType combine(final EvalType left, final EvalType right, final GipsExpOperator op) {
		if (left == EvalType.INTEGER || right == EvalType.INTEGER) {
			return EvalType.INTEGER;
		} else if ((left == EvalType.INTEGER || left == EvalType.DOUBLE)
				&& (right == EvalType.INTEGER || right == EvalType.DOUBLE)) {
			return EvalType.DOUBLE;
		} else {
			return EvalType.ERROR;
		}
	}

	public EvalType combine(final EvalType left, final EvalType right, final GipsProductOperator op) {
		// return type must be integer or double
		return intOrDouble(left, right);
	}

	public EvalType combine(final EvalType left, final EvalType right, final GipsSumOperator op) {
		// return type must be integer or double
		return intOrDouble(left, right);
	}

	public EvalType combine(final EvalType operand, final GipsArithmeticUnaryOperator op) {
		// Case: Operand is not a number
		if (operand != EvalType.INTEGER && operand != EvalType.DOUBLE) {
			return EvalType.ERROR;
		}

		// Case: ABS and NEG do not change the type
		if (op == GipsArithmeticUnaryOperator.ABS || op == GipsArithmeticUnaryOperator.NEG) {
			return operand;
		} else if (op == GipsArithmeticUnaryOperator.SQRT || op == GipsArithmeticUnaryOperator.SIN
				|| op == GipsArithmeticUnaryOperator.COS) {
			// Case: SQRT, SIN, and COS change the type to double
			return EvalType.DOUBLE;
		} else {
			throw new UnsupportedOperationException(NOT_IMPLEMENTED_EXCEPTION_MESSAGE);
		}
	}

	public EvalType combine(final EvalType left, final EvalType right, final GipsAndOperator op) {
		return combine(left, right);
	}

	public EvalType combine(final EvalType left, final EvalType right, final GipsOrOperator op) {
		return combine(left, right);
	}

	public EvalType combine(final EvalType left, final EvalType right) {
		return (left == EvalType.BOOLEAN && right == EvalType.BOOLEAN) ? EvalType.BOOLEAN : EvalType.ERROR;
	}

	public EvalType combine(final EvalType left) {
		return left == EvalType.BOOLEAN ? EvalType.BOOLEAN : EvalType.ERROR;
	}

	public EvalType intOrDouble(final EvalType left, final EvalType right) {
		if (left == EvalType.INTEGER && right == EvalType.INTEGER) {
			return EvalType.INTEGER;
		} else if ((left == EvalType.INTEGER && right == EvalType.DOUBLE) //
				|| (left == EvalType.DOUBLE && right == EvalType.INTEGER) //
				|| (left == EvalType.DOUBLE && right == EvalType.DOUBLE)) {
			return EvalType.DOUBLE;
		}

		return EvalType.ERROR;
	}

	/**
	 * Validates a given lambda expression. Therefore, this method checks the return
	 * type (must be boolean). Furthermore, it checks if the literal of the lambda
	 * expression is a constant and displays a warning.
	 * 
	 * @param expr Lambda expression to check.
	 */
	public void validateLambdaExpr(final GipsLambdaExpression expr) {
		if (expr == null || expr.getExpr() == null) {
			return;
		}

		// Check return type
		final EvalType lambdaEval = getEvalTypeFromBoolExpr(expr.getExpr());
		if (!isPrimitiveType(lambdaEval)) {
			error( //
					LAMBDA_EXPR_EVAL_NOT_PRIMITIVE_MESSAGE, //
					expr, //
					GipslPackage.Literals.GIPS_LAMBDA_EXPRESSION__EXPR //
			);
		}

		// Check if literal is constant
		if (expr.getExpr() instanceof GipsBooleanLiteral) {
			final GipsBooleanLiteral lit = (GipsBooleanLiteral) expr.getExpr();
			final String warning = String.valueOf(lit.isLiteral());
			warning( //
					String.format(LAMBDA_EXPR_EVAL_LITERAL_MESSAGE, warning), //
					expr, //
					GipslPackage.Literals.GIPS_LAMBDA_EXPRESSION__EXPR //
			);
		}
	}

	public boolean isPrimitiveType(final EvalType input) {
		return input == EvalType.BOOLEAN || input != EvalType.INTEGER || input != EvalType.DOUBLE;
	}

	/**
	 * Enumeration for the type of the leaf. This represents the output type of an
	 * evaluation.
	 */
	protected enum EvalType {
		BOOLEAN, // GipsBooleanLiteral
		INTEGER, //
		DOUBLE, //
		STRING, //
		NULL, //
		SET, // Sets like output of a filter
		OBJECTIVE, // GipsObjective
		MAPPING, // GipsMapping
		STREAM, // GipsStream
		ECLASS, // EClass for casts
		CONTEXT, // Context, e.g.: 'match::xy'
		ERROR // If leaf type can not be evaluated, e.g.: '1 + true'
	}

	/**
	 * Enumeration for the context (self) type.
	 */
	protected enum ContextType {
		MAPPING, //
		PATTERN, //
		TYPE, //
		ERROR //
	}

}
