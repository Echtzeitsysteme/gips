/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.validation;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.validation.Check;
import org.emoflon.gips.gipsl.gipsl.EditorGTFile;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanDisjunction;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanImplication;
import org.emoflon.gips.gipsl.gipsl.GipsConfig;
import org.emoflon.gips.gipsl.gipsl.GipsConstant;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsJoinAllOperation;
import org.emoflon.gips.gipsl.gipsl.GipsJoinBySelectionOperation;
import org.emoflon.gips.gipsl.gipsl.GipsJoinPairSelection;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingExpression;
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsPatternExpression;
import org.emoflon.gips.gipsl.gipsl.GipsReduceOperation;
import org.emoflon.gips.gipsl.gipsl.GipsRelationalExpression;
import org.emoflon.gips.gipsl.gipsl.GipsRuleExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSetExpression;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExpression;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExtension;
import org.emoflon.gips.gipsl.gipsl.GipsTypeExtensionVariable;
import org.emoflon.gips.gipsl.gipsl.GipslPackage;
import org.emoflon.gips.gipsl.gipsl.ImportedPattern;
import org.emoflon.gips.gipsl.gipsl.Package;
import org.emoflon.gips.gipsl.gipsl.impl.EditorGTFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstantImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstraintImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLinearFunctionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsObjectiveImpl;
import org.emoflon.gips.gipsl.scoping.GipslScopeContextUtil;
import org.emoflon.ibex.gt.editor.gT.EditorNode;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.gT.GTPackage;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class GipslValidator extends AbstractGipslValidator {

	public static String PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Pattern, Rule, Mapping or Type  '%s' must not be declared %s.";

	/**
	 * Global switch to turn off the whole validation.
	 */
	static final boolean DISABLE_VALIDATOR = false;

	/**
	 * Instance of this class
	 */
	private static GipslValidator val;

	protected GipslValidator() {
		if (val != null) {
			throw new UnsupportedOperationException("Only one instance of the GIPSL validator can be created!");
		}
		val = this;
	}

	public static GipslValidator getInstance() {
		if (val == null) {
			new GipslValidator();
		}
		return val;
	}

	/**
	 * This prevents all exceptions being "swallowed" by the default validator
	 * implementation. TODO: Remove this or make it a little nice for future stable
	 * release candidates.
	 */
	@Override
	protected void handleExceptionDuringValidation(final Throwable targetException) throws RuntimeException {
		targetException.printStackTrace();
	}

	/**
	 * Rule, Pattern, Mapping and Type names must be unique.
	 */
	@Override
	public void checkPatternNameUnique(EditorPattern pattern) {
		long count = GipslScopeContextUtil.getAllEditorPatterns(pattern).stream()
				.filter(p -> p != null && p.getName() != null).filter(p -> p.getName().equals(pattern.getName()))
				.count();

		count += GipslScopeContextUtil.getClasses(pattern).stream()
				.filter(cls -> cls.getName().equals(pattern.getName())).count();

		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(pattern, EditorGTFileImpl.class);
		count += editorFile.getMappings().stream().filter(m -> m != null && m.getName() != null)
				.filter(m -> m.getName().equals(pattern.getName())).count();

		if (count != 1) {
			error(String.format(PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE, pattern.getName(),
					super.getTimes((int) count)), GTPackage.Literals.EDITOR_PATTERN__NAME, NAME_EXPECT_UNIQUE);
		}

	}

	@Check
	public void packageValid(Package pkg) {
		if (pkg.getName() == null || pkg.getName().isBlank()) {
			error("Package name must not be empty!", GipslPackage.Literals.PACKAGE__NAME);
			return;
		}

		if (pkg.getName().contains(" ")) {
			error("Package name may not contain any white spaces.", GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().contains("\\")) {
			error("Package name may not contain any slashes.", GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().contains("/")) {
			error("Package name may not contain any slashes.", GipslPackage.Literals.PACKAGE__NAME);
		}

		StringBuilder sb = new StringBuilder();

		if (pkg.getName().chars().filter(c -> Character.isUpperCase(c)).map(c -> {
			sb.append((char) c + " ");
			return c;
		}).findAny().isPresent()) {
			error("Package name may not contain any upper case letters. The following illegal characters were found: "
					+ sb.toString(), GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().chars().filter(c -> !(Character.isLetter(c) || Character.isDigit(c) || c == '.' || c == '"'))
				.map(c -> {
					sb.append((char) c + " ");
					return c;
				}).findAny().isPresent()) {
			error("Package name may not contain any characters other than lower case letters, digits or dots. The following illegal characters were found: "
					+ sb.toString(), GipslPackage.Literals.PACKAGE__NAME);
		}

		// Check Workspace uniqueness
		IProject currentProject = GipslScopeContextUtil.getCurrentProject(pkg.eResource());
		String currentFile = pkg.eResource().getURI().toString().replace("platform:/resource/", "")
				.replaceFirst(currentProject.getName(), "");
		currentFile = currentProject.getLocation().toPortableString() + currentFile;
		currentFile = currentFile.replace("/", "\\");

		IWorkspace ws = ResourcesPlugin.getWorkspace();
		for (IProject project : ws.getRoot().getProjects()) {
			try {
				if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
					continue;
			} catch (CoreException e) {
				continue;
			}

			File projectFile = new File(project.getLocation().toPortableString());
			List<File> gtFiles = new LinkedList<>();
			GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

			for (File gtFile : gtFiles) {

				XtextResourceSet rs = new XtextResourceSet();
				URI gtModelUri;
				try {
					gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
				} catch (IOException e) {
					continue;
				}

				String fileString = gtModelUri.toFileString();
				fileString = fileString.replace("/", "\\");

				if (fileString.equals(currentFile))
					continue;

				Resource resource = rs.getResource(gtModelUri, true);
//				EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
				EObject gtModel = resource.getContents().get(0);

				if (gtModel == null)
					continue;

				if (gtModel instanceof EditorGTFile gipsEditorFile) {
					if (gipsEditorFile.getPackage().getName().equals(pkg.getName())) {
						error("Package name must be unique within the current workspace. Package name clash with: "
								+ gtModelUri, GipslPackage.Literals.PACKAGE__NAME);
					}
				}
			}
		}

	}

	/**
	 * Pattern names must be unique.
	 */
	@Check
	public void checkImportNameUnique(ImportedPattern pattern) {
		if (pattern.getPattern() == null)
			return;

		long count = GipslScopeContextUtil.getAllEditorPatterns(pattern).stream()
				.filter(p -> p != null && p.getName() != null)
				.filter(p -> p.getName().equals(pattern.getPattern().getName())).count();

		count += GipslScopeContextUtil.getClasses(pattern).stream()
				.filter(cls -> cls.getName().equals(pattern.getPattern().getName())).count();

		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(pattern, EditorGTFileImpl.class);
		count += editorFile.getMappings().stream().filter(m -> m != null && m.getName() != null)
				.filter(m -> m.getName().equals(pattern.getPattern().getName())).count();

		if (count != 1) {
			error(String.format(PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE, pattern.getPattern().getName(),
					super.getTimes((int) count)), GipslPackage.Literals.IMPORTED_PATTERN__PATTERN, NAME_EXPECT_UNIQUE);
		}
	}

	/**
	 * URI valid
	 */
	@Check
	public void checkImportUriExists(ImportedPattern pattern) {
		if (pattern.getFile() == null || pattern.getFile().isBlank())
			return;

		XtextResourceSet rs = new XtextResourceSet();
		Resource resource = null;
		URI gtModelUri = null;
		String currentImport = pattern.getFile().replace("\"", "");
		File importFile = new File(currentImport);

		if (importFile.exists() && importFile.isFile() && importFile.isAbsolute()) {
			gtModelUri = URI.createFileURI(currentImport);
			try {
				resource = rs.getResource(gtModelUri, true);
			} catch (Exception e) {
				error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
						GipslPackage.Literals.IMPORTED_PATTERN__FILE);
				return;
			}
		} else {
			// 1. Case: package name
			if (!(currentImport.contains("/") || currentImport.contains("\\"))) {
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(pattern.eResource());

				String currentFile = pattern.eResource().getURI().toString().replace("platform:/resource/", "")
						.replace(currentProject.getName(), "");
				currentFile = currentProject.getLocation().toPortableString() + currentFile;
				currentFile = currentFile.replace("/", "\\");

				IWorkspace ws = ResourcesPlugin.getWorkspace();
				for (IProject project : ws.getRoot().getProjects()) {
					try {
						if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
							continue;
					} catch (CoreException e) {
						continue;
					}

					File projectFile = new File(project.getLocation().toPortableString());
					List<File> gtFiles = new LinkedList<>();
					GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

					for (File gtFile : gtFiles) {

						rs = new XtextResourceSet();
						try {
							gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
						} catch (IOException e) {
							continue;
						}

						String fileString = gtModelUri.toFileString();

						if (fileString.equals(currentFile))
							continue;

						resource = rs.getResource(gtModelUri, true);
						EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
						EObject gtModel = resource.getContents().get(0);

						if (gtModel == null)
							continue;

						if (gtModel instanceof EditorGTFile gipsEditorFile) {
							if (gipsEditorFile.getPackage().getName().equals(pattern.getFile())) {
								break;
							}
						}

						rs = null;
						resource = null;
					}

					if (resource != null)
						break;
				}
			} else { // 2. Case: relative path
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(pattern.eResource());

				String absolutePath = null;
				try {
					absolutePath = Paths.get(currentProject.getLocation().toPortableString())
							.resolve(Paths.get(currentImport)).toFile().getCanonicalPath();
				} catch (IOException e1) {
					error("Relative import URI <" + currentImport + "> is not resolvable.",
							GipslPackage.Literals.IMPORTED_PATTERN__FILE);
					return;
				}

				gtModelUri = URI.createFileURI(absolutePath);
				try {
					resource = rs.getResource(gtModelUri, true);
				} catch (Exception e) {
					error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
							GipslPackage.Literals.IMPORTED_PATTERN__FILE);
					return;
				}
			}
		}

		if (resource == null)
			error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
					GipslPackage.Literals.IMPORTED_PATTERN__FILE);
	}

	/*
	 * Entry points for all checks
	 */

	@Check
	public void validateConfig(final GipsConfig config) {
		GipslConfigValidator.validateConfig(config);
	}

	@Check
	public void checkMapping(final GipsMapping mapping) {
		GipslMappingValidator.checkMapping(mapping);
	}

	@Check
	public void checkMappingVariable(final GipsMappingVariable variable) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}
		if (variable == null) {
			return;
		}
		GipslMappingValidator.checkMappingVariableNameUnique(variable);
		GipslMappingValidator.checkMappingVariableInUse(variable);
	}

	@Check
	public void checkTypeExtension(final GipsTypeExtension typeExtension) {
		GipslTypeExtensionValidator.checkTypeExtension(typeExtension);
	}

	@Check
	public void checkTypeExtensionVariable(final GipsTypeExtensionVariable variable) {
		GipslTypeExtensionValidator.checkTypeExtensionVariable(variable);
	}

	@Check
	public void checkConstant(final GipsConstant constant) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}

		if (constant == null) {
			return;
		}

		if (constant.getName() == null) {
			return;
		}

		EObject container = (EObject) GipslScopeContextUtil.getContainer(constant, Set.of(EditorGTFileImpl.class,
				GipsConstraintImpl.class, GipsLinearFunctionImpl.class, GipsObjectiveImpl.class));
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(constant, EditorGTFileImpl.class);
		long count = editorFile.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
				.filter(n -> n.equals(constant.getName())).count();
		if (container instanceof GipsConstraint constraint) {
			count += constraint.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		} else if (container instanceof GipsLinearFunction function) {
			count += function.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		} else if (container instanceof GipsObjective objective) {
			count += objective.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		}

		if (count > 1) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.CONSTANT_NAME_UNIQUE), //
					constant, //
					GipslPackage.Literals.GIPS_CONSTANT__NAME //
			);
		}

		if (constant.getExpression() == null) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.CONSTANT_NOT_ASSIGNED), //
					constant, //
					GipslPackage.Literals.GIPS_CONSTANT__EXPRESSION //
			);
			return;
		}

		// Check boolean expression and spool errors
		GipslExpressionValidator.checkBooleanExpression(constant.getExpression()).forEach(err -> err.run());
	}

	@Check
	public void checkSetExpression(final GipsSetExpression expression) {
		// Check if sets are properly reduced to a scalar value, when not assigned to a
		// constant

		// Case 1: Set is reduced -> nothing to do
		if (expression.getRight() == null && expression.getOperation() instanceof GipsReduceOperation) {
			return;
		}
		// Case 2: Set operation is followed by another set operation -> nothing to do
		if (expression.getRight() != null) {
			return;
		}
		// Case 3: Set is not reduced -> This is only allowed, when assigned to a
		// constant
		GipsConstant container = (GipsConstant) GipslScopeContextUtil.getContainer(expression,
				Set.of(GipsConstantImpl.class));
		if (container == null)
			GipslValidator.err( //
					String.format(GipslValidatorUtil.SET_OPERATION_MISSING), //
					expression, //
					GipslPackage.Literals.GIPS_SET_EXPRESSION__RIGHT //
			);
	}

	@Check
	public void checkJoinOperation(final GipsJoinBySelectionOperation operation) {
		if (operation.getPairJoin().isEmpty() && operation.getSingleJoin() == null) {
			GipslValidator.err( //
					GipslValidatorUtil.SET_JOIN_EMPTY, //
					operation, //
					GipslPackage.Literals.GIPS_JOIN_BY_SELECTION_OPERATION__PAIR_JOIN //
			);
			return;
		}

		EObject setContext = GipslScopeContextUtil.getSetContext(operation);
		EditorPattern setEditorPattern = GipslScopeContextUtil.getPatternOrRuleOf(setContext);
		Collection<EditorNode> setNodes = GipslScopeContextUtil.getNonCreatedEditorNodes(setEditorPattern);

		EObject localContext = GipslScopeContextUtil.getLocalContext(operation);
		EditorPattern localEditorPattern = GipslScopeContextUtil.getPatternOrRuleOf(localContext);
		Collection<EditorNode> localNodes = GipslScopeContextUtil.getNonCreatedEditorNodes(localEditorPattern);

		if (operation.getSingleJoin() != null) {
			EditorNode node = operation.getSingleJoin().getNode();
			EClass comparedNodeClass = null;

			if (setContext instanceof GipsTypeExpression eType) {
				comparedNodeClass = eType.getType();
				if (!localNodes.contains(node)) {
					GipslValidator.err( //
							String.format(GipslValidatorUtil.SET_JOIN_RIGHT_NODE_REF_ERROR), //
							operation, //
							GipslPackage.Literals.GIPS_JOIN_BY_SELECTION_OPERATION__SINGLE_JOIN //
					);
				}
			} else if (localContext instanceof EClass eClass) {
				comparedNodeClass = eClass;
				if (!setNodes.contains(node)) {
					GipslValidator.err( //
							String.format(GipslValidatorUtil.SET_JOIN_LEFT_NODE_REF_ERROR), //
							operation, //
							GipslPackage.Literals.GIPS_JOIN_BY_SELECTION_OPERATION__SINGLE_JOIN //
					);
				}
			} else {
				GipslValidator.err( //
						String.format(
								"Single node comparison is only applicable for context or set type EClass. Use \"(set node,context node)\" to specify nodes."), //
						operation, //
						GipslPackage.Literals.GIPS_JOIN_BY_SELECTION_OPERATION__SINGLE_JOIN //
				);

				return;
			}

			if (node != null) {
				// check if nodes are compatible
				EClass nodeClass = node.getType();
				if (nodeClass == null || comparedNodeClass == null) {
					// Unable to test compatibility
				} else {
					if (!(nodeClass.isSuperTypeOf(comparedNodeClass) || comparedNodeClass.isSuperTypeOf(nodeClass))) {
						GipslValidator.warn( //
								String.format(GipslValidatorUtil.SET_JOIN_MISSMATCHING_TYPE_ERROR, //
										nodeClass.getName(), //
										comparedNodeClass.getName()), //
								operation, //
								GipslPackage.Literals.GIPS_JOIN_BY_SELECTION_OPERATION__SINGLE_JOIN //
						);
					}
				}
			}
		} else {
			for (GipsJoinPairSelection selection : operation.getPairJoin()) {
				EditorNode leftNode = selection.getLeftNode();
				EditorNode rightNode = selection.getRightNode();

				if (!setNodes.contains(leftNode)) {
					GipslValidator.err( //
							String.format(GipslValidatorUtil.SET_JOIN_LEFT_NODE_REF_ERROR), //
							selection, //
							GipslPackage.Literals.GIPS_JOIN_PAIR_SELECTION__LEFT_NODE //
					);

				}

				if (!localNodes.contains(rightNode)) {
					GipslValidator.err( //
							String.format(GipslValidatorUtil.SET_JOIN_RIGHT_NODE_REF_ERROR), //
							selection, //
							GipslPackage.Literals.GIPS_JOIN_PAIR_SELECTION__RIGHT_NODE //
					);
				}

				if (leftNode != null && rightNode != null) {
					// check if nodes are compatible
					EClass leftNodeClass = leftNode.getType();
					EClass rightNodeClass = rightNode.getType();
					if (leftNodeClass == null || rightNodeClass == null) {
						// Unable to test compatibility
					} else {
						if (!(leftNodeClass.isSuperTypeOf(rightNodeClass)
								|| rightNodeClass.isSuperTypeOf(leftNodeClass))) {
							GipslValidator.warn( //
									String.format(GipslValidatorUtil.SET_JOIN_MISSMATCHING_TYPE_ERROR, //
											leftNode.getType().getName(), //
											rightNode.getType().getName()), //
									selection, //
									null //
							);
						}
					}
				}
			}
		}
	}

	@Check
	public void checkJoinOperation(final GipsJoinAllOperation operation) {
		EObject localContext = GipslScopeContextUtil.getLocalContext(operation);
		EObject setContext = GipslScopeContextUtil.getSetContext(operation);

		if (setContext instanceof GipsMappingExpression mappingExpression
				&& localContext instanceof GipsMapping mapping) {
			if (mappingExpression.getMapping().equals(mapping)) {
				return; // okay!
			} else {
				GipslValidator.warn( //
						String.format(GipslValidatorUtil.SET_JOIN_ALL_INVALID_TYPES), //
						operation, //
						null //
				);
				return;
			}
		} else if (setContext instanceof GipsRuleExpression ruleExpression
				&& localContext instanceof EditorPattern pattern) {
			if (ruleExpression.getRule().equals(pattern)) {
				return; // okay!
			} else {
				GipslValidator.warn( //
						String.format(GipslValidatorUtil.SET_JOIN_ALL_INVALID_TYPES), //
						operation, //
						null //
				);
				return;
			}
		} else if (setContext instanceof GipsPatternExpression patternExpression
				&& localContext instanceof EditorPattern pattern) {
			if (patternExpression.getPattern().equals(pattern)) {
				return; // okay!
			} else {
				GipslValidator.warn( //
						String.format(GipslValidatorUtil.SET_JOIN_ALL_INVALID_TYPES), //
						operation, //
						null //
				);
				return;
			}
		} else if (setContext instanceof GipsTypeExpression typeExpression && localContext instanceof EClass type) {
			if (typeExpression.getType().equals(type)) {
				return; // okay!
			} else {
				GipslValidator.warn( //
						String.format(GipslValidatorUtil.SET_JOIN_ALL_INVALID_TYPES), //
						operation, //
						null //
				);
				return;
			}
		}

		EObject localPattern = GipslScopeContextUtil.getPatternOrRuleOf(localContext);
		EObject setPattern = GipslScopeContextUtil.getPatternOrRuleOf(setContext);

		if (localPattern == null) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.SET_JOIN_ALL_MISSING_PATTERN, "Context"), //
					operation, //
					null //
			);
		} else if (setPattern == null) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.SET_JOIN_ALL_MISSING_PATTERN, "Set"), //
					operation, //
					null //
			);
		} else if (!localPattern.equals(setPattern)) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.SET_JOIN_ALL_MISMATCH_PATTERN), //
					operation, //
					null //
			);
		}
	}

	@Check
	public void checkConstraint(final GipsConstraint constraint) {
		GipslConstraintValidator.checkConstraint(constraint);
	}

	@Check
	public void checkObjective(final GipsLinearFunction function) {
		GipslObjectiveValidator.checkLinearFunction(function);
	}

	@Check
	public void checkGlobalObjective(final GipsObjective objective) {
		GipslObjectiveValidator.checkObjective(objective);
	}

	/**
	 * For all implication-based expressions, we have to check if the configured
	 * solver can properly solve the generated problem.
	 * 
	 * @param expr Implication boolean expression to check the solver type for.
	 */
	@Check
	public void checkBooleanImplicationSolverSupport(final GipsBooleanImplication expr) {
		GipslOperatorValidator.checkBooleanImplication(expr);
	}

	/**
	 * For all or-based expressions, we have to check if the configured solver can
	 * properly solve the generated problem.
	 * 
	 * @param expr Or boolean expression to check the solver type for.
	 */
	@Check
	public void checkBooleanDisjunctionSolverSupport(final GipsBooleanDisjunction expr) {
		GipslOperatorValidator.checkBooleanDisjunction(expr);
	}

	/**
	 * For some operators of the relational expressions, we have to check if the
	 * configured solver can properly solve the generated problem. The affected
	 * operators are: `!=`, `<`, `>`
	 * 
	 * @param expr Relational boolean expression to check the solver type for.
	 */
	@Check
	public void checkRelationalExpressionSolverSupport(final GipsRelationalExpression expr) {
		GipslOperatorValidator.checkRelationalExpression(expr);
	}

	/*
	 * Static methods to generate errors/warnings
	 */

	public static void err(final String message, final EObject source, final EStructuralFeature feature) {
		getInstance().error(message, source, feature);
	}

	public static void err(final String message, final EStructuralFeature feature, final String code,
			final String... issueData) {
		getInstance().error(message, feature, code, issueData);
	}

	public static void err(final String message, final EStructuralFeature feature) {
		getInstance().error(message, feature);
	}

	public static void warn(final String message, final EStructuralFeature feature, final String code,
			final String... issueData) {
		getInstance().warning(message, feature, code, issueData);
	}

	public static void warn(final String message, final EStructuralFeature feature) {
		getInstance().warning(message, feature);
	}

	public static void warn(final String message, final EObject source, final EStructuralFeature feature) {
		getInstance().warning(message, source, feature);
	}

}
