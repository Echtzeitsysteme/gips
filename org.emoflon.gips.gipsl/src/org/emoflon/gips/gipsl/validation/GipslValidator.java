/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.validation;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.validation.Check;
import org.emoflon.gips.gipsl.gipsl.EditorGTFile;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanDisjunction;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanImplication;
import org.emoflon.gips.gipsl.gipsl.GipsConfig;
import org.emoflon.gips.gipsl.gipsl.GipsConstant;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsReduceOperation;
import org.emoflon.gips.gipsl.gipsl.GipsRelationalExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSetExpression;
import org.emoflon.gips.gipsl.gipsl.GipslPackage;
import org.emoflon.gips.gipsl.gipsl.ImportedPattern;
import org.emoflon.gips.gipsl.gipsl.Package;
import org.emoflon.gips.gipsl.gipsl.PresolveType;
import org.emoflon.gips.gipsl.gipsl.SolverType;
import org.emoflon.gips.gipsl.gipsl.impl.EditorGTFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstantImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstraintImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLinearFunctionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsObjectiveImpl;
import org.emoflon.gips.gipsl.scoping.GipslScopeContextUtil;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.gT.GTPackage;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class GipslValidator extends AbstractGipslValidator {

	public static String PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Pattern, Rule, Mapping or Type  '%s' must not be declared %s.";

	/**
	 * Global switch to turn off the whole validation.
	 */
	static final boolean DISABLE_VALIDATOR = false;

	/**
	 * Instance of this class
	 */
	private static GipslValidator val;

	protected GipslValidator() {
		if (val != null) {
			throw new UnsupportedOperationException("Only one instance of the GIPSL validator can be created!");
		}
		val = this;
	}

	public static GipslValidator getInstance() {
		if (val == null) {
			new GipslValidator();
		}
		return val;
	}

	/**
	 * This prevents all exceptions being "swallowed" by the default validator
	 * implementation. TODO: Remove this or make it a little nice for future stable
	 * release candidates.
	 */
	@Override
	protected void handleExceptionDuringValidation(final Throwable targetException) throws RuntimeException {
		targetException.printStackTrace();
	}

	/**
	 * Rule, Pattern, Mapping and Type names must be unique.
	 */
	@Override
	public void checkPatternNameUnique(EditorPattern pattern) {
		long count = GipslScopeContextUtil.getAllEditorPatterns(pattern).stream()
				.filter(p -> p != null && p.getName() != null).filter(p -> p.getName().equals(pattern.getName()))
				.count();

		count += GipslScopeContextUtil.getClasses(pattern).stream()
				.filter(cls -> cls.getName().equals(pattern.getName())).count();

		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(pattern, EditorGTFileImpl.class);
		count += editorFile.getMappings().stream().filter(m -> m != null && m.getName() != null)
				.filter(m -> m.getName().equals(pattern.getName())).count();

		if (count != 1) {
			error(String.format(PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE, pattern.getName(),
					super.getTimes((int) count)), GTPackage.Literals.EDITOR_PATTERN__NAME, NAME_EXPECT_UNIQUE);
		}

	}

	@Check
	public void packageValid(Package pkg) {
		if (pkg.getName() == null || pkg.getName().isBlank()) {
			error("Package name must not be empty!", GipslPackage.Literals.PACKAGE__NAME);
			return;
		}

		if (pkg.getName().contains(" ")) {
			error("Package name may not contain any white spaces.", GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().contains("\\")) {
			error("Package name may not contain any slashes.", GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().contains("/")) {
			error("Package name may not contain any slashes.", GipslPackage.Literals.PACKAGE__NAME);
		}

		StringBuilder sb = new StringBuilder();

		if (pkg.getName().chars().filter(c -> Character.isUpperCase(c)).map(c -> {
			sb.append((char) c + " ");
			return c;
		}).findAny().isPresent()) {
			error("Package name may not contain any upper case letters. The following illegal characters were found: "
					+ sb.toString(), GipslPackage.Literals.PACKAGE__NAME);
		}

		if (pkg.getName().chars().filter(c -> !(Character.isLetter(c) || Character.isDigit(c) || c == '.' || c == '"'))
				.map(c -> {
					sb.append((char) c + " ");
					return c;
				}).findAny().isPresent()) {
			error("Package name may not contain any characters other than lower case letters, digits or dots. The following illegal characters were found: "
					+ sb.toString(), GipslPackage.Literals.PACKAGE__NAME);
		}

		// Check Workspace uniqueness
		IProject currentProject = GipslScopeContextUtil.getCurrentProject(pkg.eResource());
		String currentFile = pkg.eResource().getURI().toString().replace("platform:/resource/", "")
				.replaceFirst(currentProject.getName(), "");
		currentFile = currentProject.getLocation().toPortableString() + currentFile;
		currentFile = currentFile.replace("/", "\\");

		IWorkspace ws = ResourcesPlugin.getWorkspace();
		for (IProject project : ws.getRoot().getProjects()) {
			try {
				if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
					continue;
			} catch (CoreException e) {
				continue;
			}

			File projectFile = new File(project.getLocation().toPortableString());
			List<File> gtFiles = new LinkedList<>();
			GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

			for (File gtFile : gtFiles) {

				XtextResourceSet rs = new XtextResourceSet();
				URI gtModelUri;
				try {
					gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
				} catch (IOException e) {
					continue;
				}

				String fileString = gtModelUri.toFileString();
				fileString = fileString.replace("/", "\\");

				if (fileString.equals(currentFile))
					continue;

				Resource resource = rs.getResource(gtModelUri, true);
//				EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
				EObject gtModel = resource.getContents().get(0);

				if (gtModel == null)
					continue;

				if (gtModel instanceof EditorGTFile gipsEditorFile) {
					if (gipsEditorFile.getPackage().getName().equals(pkg.getName())) {
						error("Package name must be unique within the current workspace. Package name clash with: "
								+ gtModelUri, GipslPackage.Literals.PACKAGE__NAME);
					}
				}
			}
		}

	}

	/**
	 * Pattern names must be unique.
	 */
	@Check
	public void checkImportNameUnique(ImportedPattern pattern) {
		if (pattern.getPattern() == null)
			return;

		long count = GipslScopeContextUtil.getAllEditorPatterns(pattern).stream()
				.filter(p -> p != null && p.getName() != null)
				.filter(p -> p.getName().equals(pattern.getPattern().getName())).count();

		count += GipslScopeContextUtil.getClasses(pattern).stream()
				.filter(cls -> cls.getName().equals(pattern.getPattern().getName())).count();

		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(pattern, EditorGTFileImpl.class);
		count += editorFile.getMappings().stream().filter(m -> m != null && m.getName() != null)
				.filter(m -> m.getName().equals(pattern.getPattern().getName())).count();

		if (count != 1) {
			error(String.format(PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE, pattern.getPattern().getName(),
					super.getTimes((int) count)), GipslPackage.Literals.IMPORTED_PATTERN__PATTERN, NAME_EXPECT_UNIQUE);
		}
	}

	/**
	 * URI valid
	 */
	@Check
	public void checkImportUriExists(ImportedPattern pattern) {
		if (pattern.getFile() == null || pattern.getFile().isBlank())
			return;

		XtextResourceSet rs = new XtextResourceSet();
		Resource resource = null;
		URI gtModelUri = null;
		String currentImport = pattern.getFile().replace("\"", "");
		File importFile = new File(currentImport);

		if (importFile.exists() && importFile.isFile() && importFile.isAbsolute()) {
			gtModelUri = URI.createFileURI(currentImport);
			try {
				resource = rs.getResource(gtModelUri, true);
			} catch (Exception e) {
				error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
						GipslPackage.Literals.IMPORTED_PATTERN__FILE);
				return;
			}
		} else {
			// 1. Case: package name
			if (!(currentImport.contains("/") || currentImport.contains("\\"))) {
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(pattern.eResource());

				String currentFile = pattern.eResource().getURI().toString().replace("platform:/resource/", "")
						.replace(currentProject.getName(), "");
				currentFile = currentProject.getLocation().toPortableString() + currentFile;
				currentFile = currentFile.replace("/", "\\");

				IWorkspace ws = ResourcesPlugin.getWorkspace();
				for (IProject project : ws.getRoot().getProjects()) {
					try {
						if (!project.hasNature("org.emoflon.gips.gipsl.ui.gipsNature"))
							continue;
					} catch (CoreException e) {
						continue;
					}

					File projectFile = new File(project.getLocation().toPortableString());
					List<File> gtFiles = new LinkedList<>();
					GipslScopeContextUtil.gatherFilesWithEnding(gtFiles, projectFile, ".gipsl", true);

					for (File gtFile : gtFiles) {

						rs = new XtextResourceSet();
						try {
							gtModelUri = URI.createFileURI(gtFile.getCanonicalPath());
						} catch (IOException e) {
							continue;
						}

						String fileString = gtModelUri.toFileString();

						if (fileString.equals(currentFile))
							continue;

						resource = rs.getResource(gtModelUri, true);
						EcoreUtil2.resolveLazyCrossReferences(resource, () -> false);
						EObject gtModel = resource.getContents().get(0);

						if (gtModel == null)
							continue;

						if (gtModel instanceof EditorGTFile gipsEditorFile) {
							if (gipsEditorFile.getPackage().getName().equals(pattern.getFile())) {
								break;
							}
						}

						rs = null;
						resource = null;
					}

					if (resource != null)
						break;
				}
			} else { // 2. Case: relative path
				IProject currentProject = GipslScopeContextUtil.getCurrentProject(pattern.eResource());

				String absolutePath = null;
				try {
					absolutePath = Paths.get(currentProject.getLocation().toPortableString())
							.resolve(Paths.get(currentImport)).toFile().getCanonicalPath();
				} catch (IOException e1) {
					error("Relative import URI <" + currentImport + "> is not resolvable.",
							GipslPackage.Literals.IMPORTED_PATTERN__FILE);
					return;
				}

				gtModelUri = URI.createFileURI(absolutePath);
				try {
					resource = rs.getResource(gtModelUri, true);
				} catch (Exception e) {
					error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
							GipslPackage.Literals.IMPORTED_PATTERN__FILE);
					return;
				}
			}
		}

		if (resource == null)
			error("Import URI <" + gtModelUri.toFileString() + "> is not valid.",
					GipslPackage.Literals.IMPORTED_PATTERN__FILE);
	}

	/*
	 * Entry points for all checks
	 */

	@Check
	public void validateConfig(final GipsConfig config) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}

		if (config == null) {
			return;
		}

		// Check all contents for presence
		if (config.getSolver() == null) {
			error("You have to specify an ILP solver.", GipslPackage.Literals.GIPS_CONFIG__SOLVER);
		}
		// ^this might be obsolete

		// If solver is Gurobi and main is set, a home path and a license path must be
		// specified
		if (config.getSolver() == SolverType.GUROBI && config.isEnableLaunchConfig()
				&& (config.getHome() == null || config.getLicense() == null)) {
			error("You have to specify a home folder and a license file to generate a launch config for Gurobi.",
					GipslPackage.Literals.GIPS_CONFIG__SOLVER);
		}

		// ILP solver's home folder must not be empty (if set)
		if (config.getHome() != null && (config.getHome().isBlank() || config.getHome().equals("\"\""))) {
			error("Home folder path must not be blank if set.", GipslPackage.Literals.GIPS_CONFIG__HOME);
		}

		// ILP solver's license path must not be empty (if set)
		if (config.getLicense() != null && (config.getLicense().isBlank() || config.getLicense().equals("\"\""))) {
			error("License file path must not be blank if set.", GipslPackage.Literals.GIPS_CONFIG__LICENSE);
		}

		// Main path must not be empty (if enabled)
		if (config.isEnableLaunchConfig() && config.getMainLoc() != null
				&& (config.getMainLoc().isBlank() || config.getMainLoc().equals("\"\""))) {
			error("Launch config path must not be blank if enabled.", GipslPackage.Literals.GIPS_CONFIG__MAIN_LOC);
		}

		// Time limit
		if (config.getTimeLimit() < 0) {
			error("Time limit must be >= 0.0", GipslPackage.Literals.GIPS_CONFIG__TIME_LIMIT);
		}

		// Random seed
		if (config.getRndSeed() < 0) {
			error("Random seed must be >= 0.", GipslPackage.Literals.GIPS_CONFIG__RND_SEED);
		} else if (config.getRndSeed() > Integer.MAX_VALUE) {
			error("Random seed must be <= Integer.MAX_VALUE.", GipslPackage.Literals.GIPS_CONFIG__RND_SEED);
		}

		// Tolerance
		if (config.isEnableTolerance() && config.getTolerance() < 1e-9) {
			error("Tolerance value must be >= 1e-9", GipslPackage.Literals.GIPS_CONFIG__TOLERANCE);
		} else if (config.isEnableTolerance() && config.getTolerance() > 1e-2) {
			error("Tolerance value must be <= 1e-2", GipslPackage.Literals.GIPS_CONFIG__TOLERANCE);
		}

		// Special case: If solver is GLPK and pre-solving is disabled, generate a
		// warning
		if (config.getSolver() == SolverType.GLPK && !config.getPresolve().equals(PresolveType.NONE)) {
			warn("GLPK needs enabled pre-solving for some problems. "
					+ "It is highly reccommend to enable pre-solving if using the GLPK solver in GIPS.",
					GipslPackage.Literals.GIPS_CONFIG__PRESOLVE);
		}
	}

	@Check
	public void checkMapping(final GipsMapping mapping) {
		GipslMappingValidator.checkMapping(mapping);
	}

	@Check
	public void checkMappingVariable(final GipsMappingVariable variable) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}
		if (variable == null) {
			return;
		}
		GipslMappingValidator.checkMappingVariableNameUnique(variable);

	}

	@Check
	public void checkConstant(final GipsConstant constant) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}

		if (constant == null) {
			return;
		}

		if (constant.getName() == null) {
			return;
		}

		EObject container = (EObject) GipslScopeContextUtil.getContainer(constant, Set.of(EditorGTFileImpl.class,
				GipsConstraintImpl.class, GipsLinearFunctionImpl.class, GipsObjectiveImpl.class));
		EditorGTFile editorFile = GTEditorPatternUtils.getContainer(constant, EditorGTFileImpl.class);
		long count = editorFile.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
				.filter(n -> n.equals(constant.getName())).count();
		if (container instanceof GipsConstraint constraint) {
			count += constraint.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		} else if (container instanceof GipsLinearFunction function) {
			count += function.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		} else if (container instanceof GipsObjective objective) {
			count += objective.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		}

		if (count > 1) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.CONSTANT_NAME_UNIQUE), //
					constant, //
					GipslPackage.Literals.GIPS_CONSTANT__NAME //
			);
		}

		if (constant.getExpression() == null) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.CONSTANT_NOT_ASSIGNED), //
					constant, //
					GipslPackage.Literals.GIPS_CONSTANT__EXPRESSION //
			);
			return;
		}

		// Check boolean expression and spool errors
		GipslExpressionValidator.checkBooleanExpression(constant.getExpression()).forEach(err -> err.run());
	}

	@Check
	public void checkSetExpression(final GipsSetExpression expression) {
		// Check if sets are properly reduced to a scalar value, when not assigned to a
		// constant

		// Case 1: Set is reduced -> nothing to do
		if (expression.getRight() == null && expression.getOperation() instanceof GipsReduceOperation) {
			return;
		}
		// Case 2: Set operation is followed by another set operation -> nothing to do
		if (expression.getRight() != null) {
			return;
		}
		// Case 3: Set is not reduced -> This is only allowed, when assigned to a
		// constant
		GipsConstant container = (GipsConstant) GipslScopeContextUtil.getContainer(expression,
				Set.of(GipsConstantImpl.class));
		if (container == null)
			GipslValidator.err( //
					String.format(GipslValidatorUtil.SET_OPERATION_MISSING), //
					expression, //
					GipslPackage.Literals.GIPS_SET_EXPRESSION__RIGHT //
			);
	}

	@Check
	public void checkConstraint(final GipsConstraint constraint) {
		GipslConstraintValidator.checkConstraint(constraint);
	}

	@Check
	public void checkObjective(final GipsLinearFunction function) {
		GipslObjectiveValidator.checkLinearFunction(function);
	}

	@Check
	public void checkGlobalObjective(final GipsObjective objective) {
		GipslObjectiveValidator.checkObjective(objective);
	}

	/**
	 * For all implication-based expressions, we have to check if the configured
	 * solver can properly solve the generated problem.
	 * 
	 * @param expr Implication boolean expression to check the solver type for.
	 */
	@Check
	public void checkBooleanImplicationSolverSupport(final GipsBooleanImplication expr) {
		GipslOperatorValidator.checkBooleanImplication(expr);
	}

	/**
	 * For all or-based expressions, we have to check if the configured solver can
	 * properly solve the generated problem.
	 * 
	 * @param expr Or boolean expression to check the solver type for.
	 */
	@Check
	public void checkBooleanDisjunctionSolverSupport(final GipsBooleanDisjunction expr) {
		GipslOperatorValidator.checkBooleanDisjunction(expr);
	}

	/**
	 * For some operators of the relational expressions, we have to check if the
	 * configured solver can properly solve the generated problem. The affected
	 * operators are: `!=`, `<`, `>`
	 * 
	 * @param expr Relational boolean expression to check the solver type for.
	 */
	@Check
	public void checkRelationalExpressionSolverSupport(final GipsRelationalExpression expr) {
		GipslOperatorValidator.checkRelationalExpression(expr);
	}

	/*
	 * Static methods to generate errors/warnings
	 */

	public static void err(final String message, final EObject source, final EStructuralFeature feature) {
		getInstance().error(message, source, feature);
	}

	public static void err(final String message, final EStructuralFeature feature, final String code,
			final String... issueData) {
		getInstance().error(message, feature, code, issueData);
	}

	public static void err(final String message, final EStructuralFeature feature) {
		getInstance().error(message, feature);
	}

	public static void warn(final String message, final EStructuralFeature feature, final String code,
			final String... issueData) {
		getInstance().warning(message, feature, code, issueData);
	}

	public static void warn(final String message, final EStructuralFeature feature) {
		getInstance().warning(message, feature);
	}

	public static void warn(final String message, final EObject source, final EStructuralFeature feature) {
		getInstance().warning(message, source, feature);
	}

}
