/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.gips.gipsl.validation;

import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.emoflon.gips.gipsl.gipsl.EditorFile;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanDisjunction;
import org.emoflon.gips.gipsl.gipsl.GipsBooleanImplication;
import org.emoflon.gips.gipsl.gipsl.GipsConfig;
import org.emoflon.gips.gipsl.gipsl.GipsConstant;
import org.emoflon.gips.gipsl.gipsl.GipsConstraint;
import org.emoflon.gips.gipsl.gipsl.GipsLinearFunction;
import org.emoflon.gips.gipsl.gipsl.GipsMapping;
import org.emoflon.gips.gipsl.gipsl.GipsMappingVariable;
import org.emoflon.gips.gipsl.gipsl.GipsObjective;
import org.emoflon.gips.gipsl.gipsl.GipsReduceOperation;
import org.emoflon.gips.gipsl.gipsl.GipsRelationalExpression;
import org.emoflon.gips.gipsl.gipsl.GipsSetExpression;
import org.emoflon.gips.gipsl.gipsl.GipslPackage;
import org.emoflon.gips.gipsl.gipsl.SolverType;
import org.emoflon.gips.gipsl.gipsl.impl.EditorFileImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstantImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsConstraintImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsLinearFunctionImpl;
import org.emoflon.gips.gipsl.gipsl.impl.GipsObjectiveImpl;
import org.emoflon.gips.gipsl.scoping.GipslScopeContextUtil;
import org.emoflon.gips.gipsl.util.GipslResourceManager;
import org.emoflon.ibex.common.slimgt.util.SlimGTModelUtil;
import org.emoflon.ibex.gt.gtl.gTL.GTLPackage;
import org.emoflon.ibex.gt.gtl.gTL.PatternImport;
import org.emoflon.ibex.gt.gtl.gTL.SlimRule;
import org.emoflon.ibex.gt.gtl.validation.GTLValidator;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class GipslValidator extends GTLValidator {

	public static String PATTERN_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Pattern, Rule, Mapping or Type  '%s' must not be declared %s.";

	/**
	 * Instance of this class
	 */
	private static GipslValidator val;

	final protected GipslResourceManager gipslManager;

	/**
	 * Global switch to turn off the whole validation.
	 */
	static final boolean DISABLE_VALIDATOR = false;

	protected GipslValidator() {
		super(new GipslResourceManager());
		if (val != null) {
			throw new UnsupportedOperationException("Only one instance of the GIPSL validator can be created!");
		}

		gipslManager = (GipslResourceManager) gtlManager;
		val = this;
	}

	protected GipslValidator(GipslResourceManager gipslManager) {
		super(gipslManager);
		if (val != null) {
			throw new UnsupportedOperationException("Only one instance of the GIPSL validator can be created!");
		}

		this.gipslManager = gipslManager;
		val = this;
	}

	public static GipslValidator getInstance() {
		if (val == null) {
			new GipslValidator();
		}
		return val;
	}

	/**
	 * Rule, Pattern, Mapping and Type names must be unique.
	 */
	@Override
	protected void checkRuleNameUnique(SlimRule rule) {
		super.checkRuleNameUnique(rule);

		EditorFile file = (EditorFile) SlimGTModelUtil.getContainer(rule, EditorFileImpl.class);
		long count = SlimGTModelUtil.getClasses(file).stream().filter(cls -> cls.getName().equals(rule.getName()))
				.count();

		count += gipslManager.getAllMappingsInScope(file).stream().filter(m -> m != null && m.getName() != null)
				.filter(m -> m.getName().equals(rule.getName())).count();

		if (count != 1) {
			error(String.format("Pattern/rule '%s' must not be declared more than once.", rule.getName(),
					GipslValidatorUtil.getTimes((int) count)), GTLPackage.Literals.SLIM_RULE__NAME);
		}
	}

	/**
	 * Imported Pattern/Rule names must be unique among all Rule, Pattern, Mapping
	 * and Type names.
	 */
	@Override
	public void checkImportNameUnique(PatternImport pImport) {
		super.checkImportNameUnique(pImport);

		EditorFile file = (EditorFile) SlimGTModelUtil.getContainer(pImport, EditorFileImpl.class);
		long count = SlimGTModelUtil.getClasses(file).stream()
				.filter(cls -> cls.getName().equals(pImport.getPattern().getName())).count();

		count += gipslManager.getAllMappingsInScope(file).stream().filter(m -> m != null && m.getName() != null)
				.filter(m -> m.getName().equals(pImport.getPattern().getName())).count();

		if (count != 1) {
			error(String.format("Pattern/rule '%s' must not be declared more than once.",
					pImport.getPattern().getName(), GipslValidatorUtil.getTimes((int) count)),
					GTLPackage.Literals.EDITOR_FILE__IMPORTED_PATTERNS);
		}
	}

	/*
	 * Entry points for all checks
	 */

	@Check
	public void validateConfig(final GipsConfig config) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}

		if (config == null) {
			return;
		}

		// Check all contents for presence
		if (config.getSolver() == null) {
			error("You have to specify an ILP solver.", GipslPackage.Literals.GIPS_CONFIG__SOLVER);
		}
		// ^this might be obsolete

		// If solver is Gurobi and main is set, a home path and a license path must be
		// specified
		if (config.getSolver() == SolverType.GUROBI && config.isEnableLaunchConfig()
				&& (config.getHome() == null || config.getLicense() == null)) {
			error("You have to specify a home folder and a license file to generate a launch config for Gurobi.",
					GipslPackage.Literals.GIPS_CONFIG__SOLVER);
		}

		// ILP solver's home folder must not be empty (if set)
		if (config.getHome() != null && (config.getHome().isBlank() || config.getHome().equals("\"\""))) {
			error("Home folder path must not be blank if set.", GipslPackage.Literals.GIPS_CONFIG__HOME);
		}

		// ILP solver's license path must not be empty (if set)
		if (config.getLicense() != null && (config.getLicense().isBlank() || config.getLicense().equals("\"\""))) {
			error("License file path must not be blank if set.", GipslPackage.Literals.GIPS_CONFIG__LICENSE);
		}

		// Main path must not be empty (if enabled)
		if (config.isEnableLaunchConfig() && config.getMainLoc() != null
				&& (config.getMainLoc().isBlank() || config.getMainLoc().equals("\"\""))) {
			error("Launch config path must not be blank if enabled.", GipslPackage.Literals.GIPS_CONFIG__MAIN_LOC);
		}

		// Time limit
		if (config.getTimeLimit() < 0) {
			error("Time limit must be >= 0.0", GipslPackage.Literals.GIPS_CONFIG__TIME_LIMIT);
		}

		// Random seed
		if (config.getRndSeed() < 0) {
			error("Random seed must be >= 0.", GipslPackage.Literals.GIPS_CONFIG__RND_SEED);
		} else if (config.getRndSeed() > Integer.MAX_VALUE) {
			error("Random seed must be <= Integer.MAX_VALUE.", GipslPackage.Literals.GIPS_CONFIG__RND_SEED);
		}

		// Tolerance
		if (config.isEnableTolerance() && config.getTolerance() < 1e-9) {
			error("Tolerance value must be >= 1e-9", GipslPackage.Literals.GIPS_CONFIG__TOLERANCE);
		} else if (config.isEnableTolerance() && config.getTolerance() > 1e-2) {
			error("Tolerance value must be <= 1e-2", GipslPackage.Literals.GIPS_CONFIG__TOLERANCE);
		}

		// Special case: If solver is GLPK and pre-solving is disabled, generate a
		// warning
		if (config.getSolver() == SolverType.GLPK && !config.isEnablePresolve()) {
			warn("GLPK needs enabled pre-solving for some problems. "
					+ "It is highly reccommend to enable pre-solving if using the GLPK solver in GIPS.",
					GipslPackage.Literals.GIPS_CONFIG__ENABLE_PRESOLVE);
		}
	}

	@Check
	public void checkMapping(final GipsMapping mapping) {
		GipslMappingValidator mappingValidator = new GipslMappingValidator(gipslManager);
		mappingValidator.checkMapping(mapping);
	}

	@Check
	public void checkMappingVariable(final GipsMappingVariable variable) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}
		if (variable == null) {
			return;
		}
		GipslMappingValidator.checkMappingVariableNameUnique(variable);

	}

	@Check
	public void checkConstant(final GipsConstant constant) {
		if (GipslValidator.DISABLE_VALIDATOR) {
			return;
		}

		if (constant == null) {
			return;
		}

		if (constant.getName() == null) {
			return;
		}

		EObject container = (EObject) GipslScopeContextUtil.getContainer(constant, Set.of(EditorFileImpl.class,
				GipsConstraintImpl.class, GipsLinearFunctionImpl.class, GipsObjectiveImpl.class));

		EditorFile editorFile = (EditorFile) SlimGTModelUtil.getContainer(constant, EditorFileImpl.class);

		long count = gipslManager.getAllConstantsInScope(editorFile).stream().filter(c -> c.getName() != null)
				.map(c -> c.getName()).filter(n -> n.equals(constant.getName())).count();
		if (container instanceof GipsConstraint constraint) {
			count += constraint.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		} else if (container instanceof GipsLinearFunction function) {
			count += function.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		} else if (container instanceof GipsObjective objective) {
			count += objective.getConstants().stream().filter(c -> c.getName() != null).map(c -> c.getName())
					.filter(n -> n.equals(constant.getName())).count();
		}

		if (count > 1) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.CONSTANT_NAME_UNIQUE), //
					constant, //
					GipslPackage.Literals.GIPS_CONSTANT__NAME //
			);
		}

		if (constant.getExpression() == null) {
			GipslValidator.err( //
					String.format(GipslValidatorUtil.CONSTANT_NOT_ASSIGNED), //
					constant, //
					GipslPackage.Literals.GIPS_CONSTANT__EXPRESSION //
			);
			return;
		}

		// Check boolean expression and spool errors
		GipslExpressionValidator.checkBooleanExpression(constant.getExpression()).forEach(err -> err.run());
	}

	@Check
	public void checkSetExpression(final GipsSetExpression expression) {
		// Check if sets are properly reduced to a scalar value, when not assigned to a
		// constant

		// Case 1: Set is reduced -> nothing to do
		if (expression.getRight() == null && expression.getOperation() instanceof GipsReduceOperation) {
			return;
		}
		// Case 2: Set operation is followed by another set operation -> nothing to do
		if (expression.getRight() != null) {
			return;
		}
		// Case 3: Set is not reduced -> This is only allowed, when assigned to a
		// constant
		GipsConstant container = (GipsConstant) SlimGTModelUtil.getContainer(expression, GipsConstantImpl.class);
		if (container == null)
			GipslValidator.err( //
					String.format(GipslValidatorUtil.SET_OPERATION_MISSING), //
					expression, //
					GipslPackage.Literals.GIPS_SET_EXPRESSION__RIGHT //
			);
	}

	@Check
	public void checkConstraint(final GipsConstraint constraint) {
		GipslConstraintValidator.checkConstraint(constraint);
	}

	@Check
	public void checkObjective(final GipsLinearFunction function) {
		GipslObjectiveValidator objectiveValidator = new GipslObjectiveValidator(gipslManager);
		objectiveValidator.checkLinearFunction(function);
	}

	@Check
	public void checkGlobalObjective(final GipsObjective objective) {
		GipslObjectiveValidator.checkObjective(objective);
	}

	/**
	 * For all implication-based expressions, we have to check if the configured
	 * solver can properly solve the generated problem.
	 * 
	 * @param expr Implication boolean expression to check the solver type for.
	 */
	@Check
	public void checkBooleanImplicationSolverSupport(final GipsBooleanImplication expr) {
		GipslOperatorValidator.checkBooleanImplication(expr);
	}

	/**
	 * For all or-based expressions, we have to check if the configured solver can
	 * properly solve the generated problem.
	 * 
	 * @param expr Or boolean expression to check the solver type for.
	 */
	@Check
	public void checkBooleanDisjunctionSolverSupport(final GipsBooleanDisjunction expr) {
		GipslOperatorValidator.checkBooleanDisjunction(expr);
	}

	/**
	 * For some operators of the relational expressions, we have to check if the
	 * configured solver can properly solve the generated problem. The affected
	 * operators are: `!=`, `<`, `>`
	 * 
	 * @param expr Relational boolean expression to check the solver type for.
	 */
	@Check
	public void checkRelationalExpressionSolverSupport(final GipsRelationalExpression expr) {
		GipslOperatorValidator.checkRelationalExpression(expr);
	}

	/*
	 * Static methods to generate errors/warnings
	 */

	public static void err(final String message, final EObject source, final EStructuralFeature feature) {
		getInstance().error(message, source, feature);
	}

	public static void err(final String message, final EStructuralFeature feature, final String code,
			final String... issueData) {
		getInstance().error(message, feature, code, issueData);
	}

	public static void err(final String message, final EStructuralFeature feature) {
		getInstance().error(message, feature);
	}

	public static void warn(final String message, final EStructuralFeature feature, final String code,
			final String... issueData) {
		getInstance().warning(message, feature, code, issueData);
	}

	public static void warn(final String message, final EStructuralFeature feature) {
		getInstance().warning(message, feature);
	}

	public static void warn(final String message, final EObject source, final EStructuralFeature feature) {
		getInstance().warning(message, source, feature);
	}

}
