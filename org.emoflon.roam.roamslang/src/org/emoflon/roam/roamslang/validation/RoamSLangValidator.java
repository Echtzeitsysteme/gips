/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.roam.roamslang.validation;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.xtext.validation.Check;
import org.emoflon.roam.roamslang.roamSLang.EditorGTFile;
import org.emoflon.roam.roamslang.roamSLang.RoamArithmeticLiteral;
import org.emoflon.roam.roamslang.roamSLang.RoamConstraint;
import org.emoflon.roam.roamslang.roamSLang.RoamMapping;
import org.emoflon.roam.roamslang.roamSLang.RoamObjective;
import org.emoflon.roam.roamslang.roamSLang.RoamSLangPackage;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RoamSLangValidator extends AbstractRoamSLangValidator {
	
	/**
	 * The list of invalid mapping/objective names. Will be filled in the static block.
	 */
	public static Set<String> INVALID_NAMES = new HashSet<String>();
	
	static {
		final String[] invalidNames = new String[] {
				"clone",
				"equals",
				"finalize",
				"getClass",
				"hashCode",
				"notify",
				"notifyAll",
				"toString",
				"wait",
				"abstract",
				"assert",
				"boolean",
				"break",
				"byte",
				"case",
				"catch",
				"char",
				"class",
				"const",
				"continue",
				"default",
				"do",
				"double",
				"EAttribute",
				"EBoolean",
				"EDataType",
				"EClass",
				"EClassifier",
				"EDouble",
				"EFloat",
				"EInt",
				"else",
				"enum",
				"EPackage",
				"EReference",
				"EString",
				"extends",
				"final",
				"finally",
				"float",
				"for",
				"goto",
				"if",
				"implements",
				"import",
				"instanceof",
				"int",
				"interface",
				"long",
				"native",
				"new",
				"package",
				"private",
				"protected",
				"public",
				"return",
				"short",
				"static",
				"strictfp",
				"super",
				"switch",
				"synchronized",
				"this",
				"throw",
				"throws",
				"transient",
				"try",
				"void",
				"volatile",
				"while",
				
				// New values
				"mapping",
				"objective",
				"global objective",
				"global",
				"min",
				"max",
				"constraint"
		};
		INVALID_NAMES.addAll(Arrays.asList(invalidNames));
	}
	
	static String CODE_PREFIX = "org.emoflon.roam.roamslang.";

	// General errors for named elements.
	public static String NAME_BLOCKED = CODE_PREFIX + "name.blocked";
	public static String NAME_EXPECT_CAMEL_CASE = CODE_PREFIX + "name.expectCamelCase";
	public static String NAME_EXPECT_LOWER_CASE = CODE_PREFIX + "name.expectLowerCase";
	public static String NAME_EXPECT_UNIQUE = CODE_PREFIX + "name.expectUnique";
	
	public static String GLOBA_OBJJECTIVE_DOES_NOT_EXIST = CODE_PREFIX + "objective.global.doesNotExist";
	
	public static String GLOBAL_OBJECTIVE_IS_NULL = "You need to specify a global objective.";
	
	public static String MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Mapping '%s' must not be declared '%s'.";
	public static String MAPPING_NAME_FORBIDDEN_MESSAGE = "Mappings cannot be be named '%s'. Use a different name.";
	public static String MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Mapping name '%s' contains underscores. Use camelCase instead.";
	public static String MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Mapping '%s' should start with a lower case character.";

	public static String OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Objective '%s' must not be declared '%s'";
	public static String OBJECTIVE_NAME_FORBIDDEN_MESSAGE = "Objectives cannot be be named '%s'. Use a different name.";
	public static String OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Objective name '%s' contains underscores. Use camelCase instead.";
	public static String OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Objective '%s' should start with a lower case character.";
	
	public static String OBJECTIVE_VALUE_IS_ZERO_MESSAGE = "Objective '%s' can be removed because its value is 0.";
	
	// TODO: Is this really necessary? Isn't the global objective optional?
	@Check
	public void checkGlobalObjectiveNotNull(final EditorGTFile file) {
		if (file.getGlobalObjective() == null) {
			error(
					GLOBAL_OBJECTIVE_IS_NULL,
					RoamSLangPackage.Literals.ROAM_GLOBAL_OBJECTIVE.eContainingFeature(),
					// TODO: ^I'm not quite sure about the second parameter
					GLOBA_OBJJECTIVE_DOES_NOT_EXIST
			);
		}
	}

	@Check
	public void checkMapping(final RoamMapping mapping) {
		checkMappingNameValid(mapping);
		checkMappingNameUnique(mapping);
	}
	
	public void checkMappingNameValid(final RoamMapping mapping) {
		if (mapping.getName() == null) {
			return;
		}
		
		if (INVALID_NAMES.contains(mapping.getName())) {
			error(
					String.format(MAPPING_NAME_FORBIDDEN_MESSAGE, mapping.getName()),
					RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
					NAME_EXPECT_UNIQUE
			);
		} else {
			// The mapping name should be lowerCamelCase.
			if (mapping.getName().contains("_")) {
				warning(
						String.format(MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE, mapping.getName()),
						RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
						NAME_BLOCKED
				);
			} else {
				// The mapping name should start with a lower case character.
				if (!Character.isLowerCase(mapping.getName().charAt(0))) {
					warning(
							String.format(MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, mapping.getName()),
							RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
							NAME_EXPECT_LOWER_CASE
					);
				}
			}
		}
	}
	
	public void checkMappingNameUnique(final RoamMapping mapping) {
		final EditorGTFile container = (EditorGTFile) mapping.eContainer();
		final int count = (int) container.getMappings().stream().filter(
				m -> m.getName() != null && m.getName().equals(mapping.getName())
				).count();
		if (count != 1) {
			error(
					String.format(MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE, mapping.getName(), getTimes(count)),
					RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
					NAME_EXPECT_UNIQUE
			);
		}
	}
	
	@Check
	public void checkConstraint(final RoamConstraint constraint) {
		// TODO
	}
	
	@Check
	public void checkObjective(final RoamObjective objective) {
		checkObjectiveNameValid(objective);
		checkObjectiveNameUnique(objective);
		checkObjectiveIsNotUseless(objective);
	}
	
	public void checkObjectiveNameValid(final RoamObjective objective) {
		if (objective.getName() == null) {
			return;
		}
		
		if (INVALID_NAMES.contains(objective.getName())) {
			error(
					String.format(OBJECTIVE_NAME_FORBIDDEN_MESSAGE, objective.getName()),
					RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
					NAME_BLOCKED
			);
		} else {
			// The objective name should be lowerCamelCase.
			if (objective.getName().contains("_")) {
				warning(
						String.format(OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE, objective.getName()),
						RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
						NAME_BLOCKED
				);
			} else {
				// The objective name should start with a lower case character.
				if (!Character.isLowerCase(objective.getName().charAt(0))) {
					warning(
							String.format(OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, objective.getName()),
							RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
							NAME_EXPECT_LOWER_CASE
					);
				}
			}
		}
	}
	
	public void checkObjectiveNameUnique(final RoamObjective objective) {
		final EditorGTFile container = (EditorGTFile) objective.eContainer();
		final int count = (int) container.getObjectives().stream().filter(
				o -> o.getName() != null && o.getName().equals(objective.getName())
				).count();
		if (count != 1) {
			error(
					String.format(OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE, objective.getName(), getTimes(count)),
					RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
					NAME_EXPECT_UNIQUE
			);
		}
	}
	
	public void checkObjectiveIsNotUseless(final RoamObjective objective) {
		if (objective.getExpr() instanceof RoamArithmeticLiteral) {
			final RoamArithmeticLiteral lit = (RoamArithmeticLiteral) objective.getExpr();
			if (lit.getValue() != null && lit.getValue().equals("0")) {
				warning(
						String.format(OBJECTIVE_VALUE_IS_ZERO_MESSAGE, objective.getName()),
						RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
				);
			}
		}
	}
	
}
