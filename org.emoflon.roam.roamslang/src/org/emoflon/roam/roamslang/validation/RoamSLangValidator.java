/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.roam.roamslang.validation;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.xtext.validation.Check;
import org.emoflon.roam.roamslang.roamSLang.EditorGTFile;
import org.emoflon.roam.roamslang.roamSLang.RoamArithmeticExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamArithmeticLiteral;
import org.emoflon.roam.roamslang.roamSLang.RoamBinaryArithmeticExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamBinaryBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamConstraint;
import org.emoflon.roam.roamslang.roamSLang.RoamContextExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamExpressionOperand;
import org.emoflon.roam.roamslang.roamSLang.RoamMapping;
import org.emoflon.roam.roamslang.roamSLang.RoamMappingAttributeExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamObjective;
import org.emoflon.roam.roamslang.roamSLang.RoamSLangPackage;
import org.emoflon.roam.roamslang.roamSLang.RoamStreamBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamStreamNoArgOperator;
import org.emoflon.roam.roamslang.roamSLang.RoamUnaryArithmeticExpr;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RoamSLangValidator extends AbstractRoamSLangValidator {
	
	/**
	 * The list of invalid mapping/objective names. Will be filled in the static block.
	 */
	public static Set<String> INVALID_NAMES = new HashSet<String>();
	
	static {
		final String[] invalidNames = new String[] {
				"clone",
				"equals",
				"finalize",
				"getClass",
				"hashCode",
				"notify",
				"notifyAll",
				"toString",
				"wait",
				"abstract",
				"assert",
				"boolean",
				"break",
				"byte",
				"case",
				"catch",
				"char",
				"class",
				"const",
				"continue",
				"default",
				"do",
				"double",
				"EAttribute",
				"EBoolean",
				"EDataType",
				"EClass",
				"EClassifier",
				"EDouble",
				"EFloat",
				"EInt",
				"else",
				"enum",
				"EPackage",
				"EReference",
				"EString",
				"extends",
				"final",
				"finally",
				"float",
				"for",
				"goto",
				"if",
				"implements",
				"import",
				"instanceof",
				"int",
				"interface",
				"long",
				"native",
				"new",
				"package",
				"private",
				"protected",
				"public",
				"return",
				"short",
				"static",
				"strictfp",
				"super",
				"switch",
				"synchronized",
				"this",
				"throw",
				"throws",
				"transient",
				"try",
				"void",
				"volatile",
				"while",
				
				// New values
				"mapping",
				"objective",
				"global objective",
				"global",
				"min",
				"max",
				"constraint"
		};
		INVALID_NAMES.addAll(Arrays.asList(invalidNames));
	}
	
	static String CODE_PREFIX = "org.emoflon.roam.roamslang.";

	// General errors for named elements.
	public static String NAME_BLOCKED = CODE_PREFIX + "name.blocked";
	public static String NAME_EXPECT_CAMEL_CASE = CODE_PREFIX + "name.expectCamelCase";
	public static String NAME_EXPECT_LOWER_CASE = CODE_PREFIX + "name.expectLowerCase";
	public static String NAME_EXPECT_UNIQUE = CODE_PREFIX + "name.expectUnique";
	
	public static String GLOBA_OBJJECTIVE_DOES_NOT_EXIST = CODE_PREFIX + "objective.global.doesNotExist";
	
	public static String GLOBAL_OBJECTIVE_IS_NULL = "You need to specify a global objective.";
	
	public static String MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Mapping '%s' must not be declared '%s'.";
	public static String MAPPING_NAME_FORBIDDEN_MESSAGE = "Mappings cannot be be named '%s'. Use a different name.";
	public static String MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Mapping name '%s' contains underscores. Use camelCase instead.";
	public static String MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Mapping '%s' should start with a lower case character.";

	public static String OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Objective '%s' must not be declared '%s'";
	public static String OBJECTIVE_NAME_FORBIDDEN_MESSAGE = "Objectives cannot be be named '%s'. Use a different name.";
	public static String OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Objective name '%s' contains underscores. Use camelCase instead.";
	public static String OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Objective '%s' should start with a lower case character.";
	
	public static String OBJECTIVE_VALUE_IS_ZERO_MESSAGE = "Objective '%s' can be removed because its value is 0.";
	
	// TODO: Is this really necessary? Isn't the global objective optional?
	/**
	 * Checks if a global objective is specified in a given file.
	 * 
	 * @param file File to check existence of a global objective for.
	 */
	@Check
	public void checkGlobalObjectiveNotNull(final EditorGTFile file) {
		if (file.getGlobalObjective() == null) {
			error(
					GLOBAL_OBJECTIVE_IS_NULL,
					RoamSLangPackage.Literals.ROAM_GLOBAL_OBJECTIVE.eContainingFeature(),
					// TODO: ^I'm not quite sure about the second parameter
					GLOBA_OBJJECTIVE_DOES_NOT_EXIST
			);
		}
	}

	/**
	 * Runs checks for all Roam mappings.
	 * 
	 * @param mapping Input Roam mapping to check.
	 */
	@Check
	public void checkMapping(final RoamMapping mapping) {
		checkMappingNameValid(mapping);
		checkMappingNameUnique(mapping);
	}
	
	/**
	 * Checks for validity of a mapping name. The name must not be on the list of invalid names,
	 * the name should be in lowerCamelCase, and the name should start with a lower case character.
	 * 
	 * @param mapping Roam mapping to check.
	 */
	public void checkMappingNameValid(final RoamMapping mapping) {
		if (mapping.getName() == null) {
			return;
		}
		
		if (INVALID_NAMES.contains(mapping.getName())) {
			error(
					String.format(MAPPING_NAME_FORBIDDEN_MESSAGE, mapping.getName()),
					RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
					NAME_EXPECT_UNIQUE
			);
		} else {
			// The mapping name should be lowerCamelCase.
			if (mapping.getName().contains("_")) {
				warning(
						String.format(MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE, mapping.getName()),
						RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
						NAME_BLOCKED
				);
			} else {
				// The mapping name should start with a lower case character.
				if (!Character.isLowerCase(mapping.getName().charAt(0))) {
					warning(
							String.format(MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, mapping.getName()),
							RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
							NAME_EXPECT_LOWER_CASE
					);
				}
			}
		}
	}
	
	/**
	 * Checks the uniqueness of the name of a given Roam mapping.
	 * 
	 * @param mapping Roam mapping to check uniqueness of the name for.
	 */
	public void checkMappingNameUnique(final RoamMapping mapping) {
		final EditorGTFile container = (EditorGTFile) mapping.eContainer();
		final int count = (int) container.getMappings().stream().filter(
				m -> m.getName() != null && m.getName().equals(mapping.getName())
				).count();
		if (count != 1) {
			error(
					String.format(MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE, mapping.getName(), getTimes(count)),
					RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
					NAME_EXPECT_UNIQUE
			);
		}
	}
	
	/**
	 * Runs all checks for a given constraints.
	 * 
	 * @param constraint Roam constraint to check.
	 */
	@Check
	public void checkConstraint(final RoamConstraint constraint) {
		// TODO
	}
	
	/**
	 * Runs all checks for a given objective.
	 * 
	 * @param objective Roam objective to check.
	 */
	@Check
	public void checkObjective(final RoamObjective objective) {
		checkObjectiveNameValid(objective);
		checkObjectiveNameUnique(objective);
		checkObjectiveIsNotUseless(objective);
		checkObjectiveExpressionType(objective);
	}
	
	/**
	 * Checks for validity of an objective name. The name must not be on the list of invalid names,
	 * the name should be in lowerCamelCase, and the name should start with a lower case character.
	 * 
	 * @param objective Roam objective to check.
	 */
	public void checkObjectiveNameValid(final RoamObjective objective) {
		if (objective.getName() == null) {
			return;
		}
		
		if (INVALID_NAMES.contains(objective.getName())) {
			error(
					String.format(OBJECTIVE_NAME_FORBIDDEN_MESSAGE, objective.getName()),
					RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
					NAME_BLOCKED
			);
		} else {
			// The objective name should be lowerCamelCase.
			if (objective.getName().contains("_")) {
				warning(
						String.format(OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE, objective.getName()),
						RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
						NAME_BLOCKED
				);
			} else {
				// The objective name should start with a lower case character.
				if (!Character.isLowerCase(objective.getName().charAt(0))) {
					warning(
							String.format(OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, objective.getName()),
							RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
							NAME_EXPECT_LOWER_CASE
					);
				}
			}
		}
	}
	
	/**
	 * Checks the uniqueness of the name of a given Roam objective.
	 * 
	 * @param objective Roam objective to check uniqueness of the name for.
	 */
	public void checkObjectiveNameUnique(final RoamObjective objective) {
		final EditorGTFile container = (EditorGTFile) objective.eContainer();
		final int count = (int) container.getObjectives().stream().filter(
				o -> o.getName() != null && o.getName().equals(objective.getName())
				).count();
		if (count != 1) {
			error(
					String.format(OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE, objective.getName(), getTimes(count)),
					RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
					NAME_EXPECT_UNIQUE
			);
		}
	}
	
	/**
	 * Checks a given Roam objective for uselessness, i.e, if the objective is '0'.
	 * 
	 * @param objective Roam objective to check for uselessness.
	 */
	public void checkObjectiveIsNotUseless(final RoamObjective objective) {
		if (objective.getExpr() instanceof RoamArithmeticLiteral) {
			final RoamArithmeticLiteral lit = (RoamArithmeticLiteral) objective.getExpr();
			if (lit.getValue() != null && lit.getValue().equals("0")) {
				warning(
						String.format(OBJECTIVE_VALUE_IS_ZERO_MESSAGE, objective.getName()),
						RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
				);
			}
		}
	}
	
	public void checkObjectiveExpressionType(final RoamObjective objective) {		
		// TODO: Check if expression of the objective is a bool
//		if(objective.getExpr() instanceof RoamBoolExpr) {
//			error(
//					"The expression of the objective is of type bool which is not supported",
//					RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
//			);
//		}
		
		if(objective.getExpr() instanceof RoamMappingAttributeExpr) {
			final RoamMappingAttributeExpr mappingExpr = (RoamMappingAttributeExpr) objective.getExpr();
			if (mappingExpr.getExpr() instanceof RoamStreamBoolExpr) {
				final RoamStreamBoolExpr boolExpr = (RoamStreamBoolExpr) mappingExpr.getExpr();
				if (boolExpr.getOperator().getValue() == RoamStreamNoArgOperator.EXISTS_VALUE) {
					error(
							"Bool error.",
							RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
					);
				}
			}
		}
	}
	
	@Check
	public void checkArithmeticExpression(final RoamArithmeticExpr expression) {
		if (expression instanceof RoamUnaryArithmeticExpr) {
			final RoamUnaryArithmeticExpr unary = (RoamUnaryArithmeticExpr) expression;
			// TODO
		} else if (expression instanceof RoamBinaryArithmeticExpr) {
			final RoamBinaryArithmeticExpr binary = (RoamBinaryArithmeticExpr) expression;
			if(binary.getLeft() instanceof RoamStreamBoolExpr && !(binary.getRight() instanceof RoamStreamBoolExpr)) {
				error("test1", RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__LEFT);
			} else if(!(binary.getLeft() instanceof RoamStreamBoolExpr) && binary.getRight() instanceof RoamStreamBoolExpr) {
				error("test2", RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__RIGHT);
			} 
			
//			if (binary.getLeft() instanceof RoamBinaryBoolExpr || binary.getLeft() instanceof RoamStreamBoolExpr) {
//				error(
//						"Left side is a bool.",
//						RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__LEFT
//				);
//			}
//			if (binary.getRight() instanceof RoamBinaryBoolExpr || binary.getRight() instanceof RoamStreamBoolExpr) {
//				error(
//						"Right side is a bool.",
//						RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__LEFT
//				);
//			}
//			
		} else if (expression instanceof RoamExpressionOperand) {
			final RoamExpressionOperand op = (RoamExpressionOperand) expression;
			if (op instanceof RoamContextExpr) {
				final RoamContextExpr cexpr = (RoamContextExpr) op;
				// TODO
			}
		}
		// TODO: Finish this method.
	}
	
}
