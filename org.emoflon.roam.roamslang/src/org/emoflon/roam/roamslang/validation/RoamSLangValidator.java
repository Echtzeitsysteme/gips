/*
 * generated by Xtext 2.25.0
 */
package org.emoflon.roam.roamslang.validation;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.codegen.ecore.genmodel.GenModelPackage.Literals;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.validation.Check;
import org.emoflon.roam.roamslang.roamSLang.EditorGTFile;
import org.emoflon.roam.roamslang.roamSLang.RoamArithmeticExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamArithmeticLiteral;
import org.emoflon.roam.roamslang.roamSLang.RoamAttributeExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamBinaryArithmeticExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamBinaryBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamBool;
import org.emoflon.roam.roamslang.roamSLang.RoamBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamBooleanLiteral;
import org.emoflon.roam.roamslang.roamSLang.RoamConstraint;
import org.emoflon.roam.roamslang.roamSLang.RoamContextExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamExpressionOperand;
import org.emoflon.roam.roamslang.roamSLang.RoamMapping;
import org.emoflon.roam.roamslang.roamSLang.RoamMappingAttributeExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamObjective;
import org.emoflon.roam.roamslang.roamSLang.RoamObjectiveExpression;
import org.emoflon.roam.roamslang.roamSLang.RoamRelExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamSLangPackage;
import org.emoflon.roam.roamslang.roamSLang.RoamStreamBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamStreamNoArgOperator;
import org.emoflon.roam.roamslang.roamSLang.RoamUnaryArithmeticExpr;
import org.emoflon.roam.roamslang.roamSLang.RoamUnaryBoolExpr;
import org.emoflon.roam.roamslang.roamSLang.impl.RoamRelExprImpl;
import org.emoflon.roam.roamslang.services.RoamSLangGrammarAccess.RoamDoubleLiteralElements;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RoamSLangValidator extends AbstractRoamSLangValidator {
	
	/**
	 * The list of invalid mapping/objective names. Will be filled in the static block.
	 */
	public static Set<String> INVALID_NAMES = new HashSet<String>();
	
	static {
		final String[] invalidNames = new String[] {
				"clone",
				"equals",
				"finalize",
				"getClass",
				"hashCode",
				"notify",
				"notifyAll",
				"toString",
				"wait",
				"abstract",
				"assert",
				"boolean",
				"break",
				"byte",
				"case",
				"catch",
				"char",
				"class",
				"const",
				"continue",
				"default",
				"do",
				"double",
				"EAttribute",
				"EBoolean",
				"EDataType",
				"EClass",
				"EClassifier",
				"EDouble",
				"EFloat",
				"EInt",
				"else",
				"enum",
				"EPackage",
				"EReference",
				"EString",
				"extends",
				"final",
				"finally",
				"float",
				"for",
				"goto",
				"if",
				"implements",
				"import",
				"instanceof",
				"int",
				"interface",
				"long",
				"native",
				"new",
				"package",
				"private",
				"protected",
				"public",
				"return",
				"short",
				"static",
				"strictfp",
				"super",
				"switch",
				"synchronized",
				"this",
				"throw",
				"throws",
				"transient",
				"try",
				"void",
				"volatile",
				"while",
				
				// New values
				"mapping",
				"objective",
				"global objective",
				"global",
				"min",
				"max",
				"constraint"
		};
		INVALID_NAMES.addAll(Arrays.asList(invalidNames));
	}
	
	static String CODE_PREFIX = "org.emoflon.roam.roamslang.";

	// General errors for named elements.
	public static String NAME_BLOCKED = CODE_PREFIX + "name.blocked";
	public static String NAME_EXPECT_CAMEL_CASE = CODE_PREFIX + "name.expectCamelCase";
	public static String NAME_EXPECT_LOWER_CASE = CODE_PREFIX + "name.expectLowerCase";
	public static String NAME_EXPECT_UNIQUE = CODE_PREFIX + "name.expectUnique";
	
	public static String GLOBA_OBJJECTIVE_DOES_NOT_EXIST = CODE_PREFIX + "objective.global.doesNotExist";
	
	public static String GLOBAL_OBJECTIVE_IS_NULL = "You need to specify a global objective.";
	
	public static String MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Mapping '%s' must not be declared '%s'.";
	public static String MAPPING_NAME_FORBIDDEN_MESSAGE = "Mappings cannot be be named '%s'. Use a different name.";
	public static String MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Mapping name '%s' contains underscores. Use camelCase instead.";
	public static String MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Mapping '%s' should start with a lower case character.";

	public static String OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE = "Objective '%s' must not be declared '%s'";
	public static String OBJECTIVE_NAME_FORBIDDEN_MESSAGE = "Objectives cannot be be named '%s'. Use a different name.";
	public static String OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE = "Objective name '%s' contains underscores. Use camelCase instead.";
	public static String OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE = "Objective '%s' should start with a lower case character.";
	
	public static String OBJECTIVE_VALUE_IS_ZERO_MESSAGE = "Objective '%s' can be removed because its value is 0.";
	
	// TODO: Is this really necessary? Isn't the global objective optional?
	/**
	 * Checks if a global objective is specified in a given file.
	 * 
	 * @param file File to check existence of a global objective for.
	 */
	@Check
	public void checkGlobalObjectiveNotNull(final EditorGTFile file) {
		if (file.getGlobalObjective() == null) {
			error(
					GLOBAL_OBJECTIVE_IS_NULL,
					RoamSLangPackage.Literals.ROAM_GLOBAL_OBJECTIVE.eContainingFeature(),
					// TODO: ^I'm not quite sure about the second parameter
					GLOBA_OBJJECTIVE_DOES_NOT_EXIST
			);
		}
	}

	/**
	 * Runs checks for all Roam mappings.
	 * 
	 * @param mapping Input Roam mapping to check.
	 */
	@Check
	public void checkMapping(final RoamMapping mapping) {
		checkMappingNameValid(mapping);
		checkMappingNameUnique(mapping);
	}
	
	/**
	 * Checks for validity of a mapping name. The name must not be on the list of invalid names,
	 * the name should be in lowerCamelCase, and the name should start with a lower case character.
	 * 
	 * @param mapping Roam mapping to check.
	 */
	public void checkMappingNameValid(final RoamMapping mapping) {
		if (mapping.getName() == null) {
			return;
		}
		
		if (INVALID_NAMES.contains(mapping.getName())) {
			error(
					String.format(MAPPING_NAME_FORBIDDEN_MESSAGE, mapping.getName()),
					RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
					NAME_EXPECT_UNIQUE
			);
		} else {
			// The mapping name should be lowerCamelCase.
			if (mapping.getName().contains("_")) {
				warning(
						String.format(MAPPING_NAME_CONTAINS_UNDERSCORES_MESSAGE, mapping.getName()),
						RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
						NAME_BLOCKED
				);
			} else {
				// The mapping name should start with a lower case character.
				if (!Character.isLowerCase(mapping.getName().charAt(0))) {
					warning(
							String.format(MAPPING_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, mapping.getName()),
							RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
							NAME_EXPECT_LOWER_CASE
					);
				}
			}
		}
	}
	
	/**
	 * Checks the uniqueness of the name of a given Roam mapping.
	 * 
	 * @param mapping Roam mapping to check uniqueness of the name for.
	 */
	public void checkMappingNameUnique(final RoamMapping mapping) {
		final EditorGTFile container = (EditorGTFile) mapping.eContainer();
		final int count = (int) container.getMappings().stream().filter(
				m -> m.getName() != null && m.getName().equals(mapping.getName())
				).count();
		if (count != 1) {
			error(
					String.format(MAPPING_NAME_MULTIPLE_DECLARATIONS_MESSAGE, mapping.getName(), getTimes(count)),
					RoamSLangPackage.Literals.ROAM_MAPPING__NAME,
					NAME_EXPECT_UNIQUE
			);
		}
	}
	
	/**
	 * Runs all checks for a given constraints.
	 * 
	 * @param constraint Roam constraint to check.
	 */
	@Check
	public void checkConstraint(final RoamConstraint constraint) {
		// TODO
	}
	
	/**
	 * Runs all checks for a given objective.
	 * 
	 * @param objective Roam objective to check.
	 */
	@Check
	public void checkObjective(final RoamObjective objective) {
		checkObjectiveNameValid(objective);
		checkObjectiveNameUnique(objective);
		checkObjectiveIsNotUseless(objective);
		checkObjectiveExpressionType(objective);
	}
	
	/**
	 * Checks for validity of an objective name. The name must not be on the list of invalid names,
	 * the name should be in lowerCamelCase, and the name should start with a lower case character.
	 * 
	 * @param objective Roam objective to check.
	 */
	public void checkObjectiveNameValid(final RoamObjective objective) {
		if (objective.getName() == null) {
			return;
		}
		
		if (INVALID_NAMES.contains(objective.getName())) {
			error(
					String.format(OBJECTIVE_NAME_FORBIDDEN_MESSAGE, objective.getName()),
					RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
					NAME_BLOCKED
			);
		} else {
			// The objective name should be lowerCamelCase.
			if (objective.getName().contains("_")) {
				warning(
						String.format(OBJECTIVE_NAME_CONTAINS_UNDERSCORES_MESSAGE, objective.getName()),
						RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
						NAME_BLOCKED
				);
			} else {
				// The objective name should start with a lower case character.
				if (!Character.isLowerCase(objective.getName().charAt(0))) {
					warning(
							String.format(OBJECTIVE_NAME_STARTS_WITH_LOWER_CASE_MESSAGE, objective.getName()),
							RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
							NAME_EXPECT_LOWER_CASE
					);
				}
			}
		}
	}
	
	/**
	 * Checks the uniqueness of the name of a given Roam objective.
	 * 
	 * @param objective Roam objective to check uniqueness of the name for.
	 */
	public void checkObjectiveNameUnique(final RoamObjective objective) {
		final EditorGTFile container = (EditorGTFile) objective.eContainer();
		final int count = (int) container.getObjectives().stream().filter(
				o -> o.getName() != null && o.getName().equals(objective.getName())
				).count();
		if (count != 1) {
			error(
					String.format(OBJECTIVE_NAME_MULTIPLE_DECLARATIONS_MESSAGE, objective.getName(), getTimes(count)),
					RoamSLangPackage.Literals.ROAM_OBJECTIVE__NAME,
					NAME_EXPECT_UNIQUE
			);
		}
	}
	
	/**
	 * Checks a given Roam objective for uselessness, i.e, if the objective is '0'.
	 * 
	 * @param objective Roam objective to check for uselessness.
	 */
	public void checkObjectiveIsNotUseless(final RoamObjective objective) {
		if (objective.getExpr() instanceof RoamArithmeticLiteral) {
			final RoamArithmeticLiteral lit = (RoamArithmeticLiteral) objective.getExpr();
			if (lit.getValue() != null && lit.getValue().equals("0")) {
				warning(
						String.format(OBJECTIVE_VALUE_IS_ZERO_MESSAGE, objective.getName()),
						RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
				);
			}
		}
	}
	
	public void checkObjectiveExpressionType(final RoamObjective objective) {		
		// TODO: Check if expression of the objective is a bool
//		if(objective.getExpr() instanceof RoamBoolExpr) {
//			error(
//					"The expression of the objective is of type bool which is not supported",
//					RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
//			);
//		}
		
		if(objective.getExpr() instanceof RoamMappingAttributeExpr) {
			final RoamMappingAttributeExpr mappingExpr = (RoamMappingAttributeExpr) objective.getExpr();
			if (mappingExpr.getExpr() instanceof RoamStreamBoolExpr) {
				final RoamStreamBoolExpr boolExpr = (RoamStreamBoolExpr) mappingExpr.getExpr();
				if (boolExpr.getOperator().getValue() == RoamStreamNoArgOperator.EXISTS_VALUE) {
					error(
							"Bool error.",
							RoamSLangPackage.Literals.ROAM_OBJECTIVE__EXPR
					);
				}
			}
		}
	}
	
//	@Check
//	public void checkArithmeticExpression(final RoamArithmeticExpr expression) {
//		if (expression instanceof RoamUnaryArithmeticExpr) {
//			final RoamUnaryArithmeticExpr unary = (RoamUnaryArithmeticExpr) expression;
//			// TODO
//		} else if (expression instanceof RoamBinaryArithmeticExpr) {
//			final RoamBinaryArithmeticExpr binary = (RoamBinaryArithmeticExpr) expression;
//			if(binary.getLeft() instanceof RoamStreamBoolExpr && !(binary.getRight() instanceof RoamStreamBoolExpr)) {
//				error("test1", RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__LEFT);
//			} else if(!(binary.getLeft() instanceof RoamStreamBoolExpr) && binary.getRight() instanceof RoamStreamBoolExpr) {
//				error("test2", RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__RIGHT);
//			} 
//			
////			if (binary.getLeft() instanceof RoamBinaryBoolExpr || binary.getLeft() instanceof RoamStreamBoolExpr) {
////				error(
////						"Left side is a bool.",
////						RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__LEFT
////				);
////			}
////			if (binary.getRight() instanceof RoamBinaryBoolExpr || binary.getRight() instanceof RoamStreamBoolExpr) {
////				error(
////						"Right side is a bool.",
////						RoamSLangPackage.Literals.ROAM_BINARY_ARITHMETIC_EXPR__LEFT
////				);
////			}
////			
//		} else if (expression instanceof RoamExpressionOperand) {
//			final RoamExpressionOperand op = (RoamExpressionOperand) expression;
//			if (op instanceof RoamContextExpr) {
//				final RoamContextExpr cexpr = (RoamContextExpr) op;
//				// TODO
//			}
//		}
//		// TODO: Finish this method.
//	}
	
//	@Check
//	public void checkUnaryExpression(final RoamUnaryArithmeticExpr expression) {
//		// TODO
//		System.out.println("Checking unary expr: " + expression);
//		
//		if (expression.getOperand() instanceof RoamArithmeticLiteral) {
//			final RoamArithmeticLiteral lit = (RoamArithmeticLiteral) expression.getOperand();
////			lit.get
//		} else if (expression.getOperand() instanceof RoamAttributeExpr) {
//			final RoamAttributeExpr att = (RoamAttributeExpr) expression.getOperand();
//		} else if (expression.getOperand() instanceof RoamObjectiveExpression) {
//			final RoamObjectiveExpression obj = (RoamObjectiveExpression) expression.getOperand();
//		}
//		
//	}
	
	// TODO: Is this even necessary?
	@Check
	public void checkArithmeticLiteralParsable(final RoamArithmeticLiteral literal) {
		try {
			Double.valueOf(literal.getValue());
		} catch (final NumberFormatException ex) {
			error(
					"Literal not parsable.",
					RoamSLangPackage.Literals.ROAM_ARITHMETIC_LITERAL__VALUE
			);
		}
	}
	
//	@Check
//	public void checkRoamRelExpr(final RoamRelExpr expr) {
//		// TODO
//		// RHS == null and the container is contained in a constraint -> error
//		if (expr.getRight() == null && expr.eContainer() instanceof RoamBool) {
//			final RoamBool container = (RoamBool) expr.eContainer();
//			if (container.eContainer() instanceof RoamConstraint) {
//				error(
//						"RHS is null.",
//						RoamSLangPackage.Literals.ROAM_REL_EXPR__RIGHT
//				);
//			}
//
//		}
//		
//		// One of the two sides must be a constant
//		if (expr.getLeft() instanceof RoamMappingAttributeExpr && expr.getRight() instanceof RoamMappingAttributeExpr) {
//			error(
//					"One of the two sides of this expression must be a constant.",
//					RoamSLangPackage.Literals.ROAM_REL_EXPR__RIGHT
//			);
//		}
//	}
	
//	@Check
//	public void checkRoamBoolExpr(final RoamBoolExpr expr) {
//		// TODO
//	}
	
	public Class<? extends EObject> getEvalTypeFromBoolExpr (final RoamBoolExpr expr) {
		if (expr instanceof RoamBooleanLiteral) {
			// TODO: What to return here?
		} else if (expr instanceof RoamBinaryBoolExpr) {
			final RoamBinaryBoolExpr boolExpr = (RoamBinaryBoolExpr) expr;
			return getEvalLeftRightSide(boolExpr.getLeft(), boolExpr.getRight());			
		} else if (expr instanceof RoamUnaryBoolExpr) {
			final RoamUnaryBoolExpr boolExpr = (RoamUnaryBoolExpr) expr;
			return getEvalTypeDelegate(boolExpr);
		} else if (expr instanceof RoamRelExpr) {
			final RoamRelExpr relExpr = (RoamRelExpr) expr;
			if (relExpr.getRight() == null) {
				return getEvalTypeDelegate(relExpr.getLeft());
			} else {
				// If lhs and rhs are set, the expression must evaluate to a boolean.
				return getEvalLeftRightSide(relExpr.getLeft(), relExpr.getRight());
			}
		}

		throw new IllegalStateException("Instance type not found.");
		
//		return null;
//		return expr.getClass();
	}
	
	public Class<? extends EObject> getEvalTypeFromArithExpr(final RoamArithmeticExpr expr) {
		if (expr instanceof RoamBinaryArithmeticExpr) {
			final RoamBinaryArithmeticExpr arithExpr = (RoamBinaryArithmeticExpr) expr;
			return getEvalLeftRightSide(arithExpr.getLeft(), arithExpr.getRight());
		} else if (expr instanceof RoamUnaryArithmeticExpr) {
			return getEvalTypeFromArithExpr(((RoamUnaryArithmeticExpr) expr).getOperand());
		} else if (expr instanceof RoamExpressionOperand) {
			
		}
		
		// TODO
		
		throw new IllegalStateException("Instance type not found.");
	}
	
	public Class<? extends EObject> getEvalTypeFromExprOp(final RoamExpressionOperand op) {
		if (op instanceof RoamArithmeticLiteral) {
			
		} else if (op instanceof RoamAttributeExpr) {
			
		} else if (op instanceof RoamObjectiveExpression) {
			
		}
		
		// TODO
		
		throw new IllegalStateException("Instance type not found.");
	}
	
//	public Class<? extends EObject> getEvalTypeFromArithLit(final RoamArithmeticLiteral lit) {
	public EDataType getEvalTypeFromArithLit(final RoamArithmeticLiteral lit) {
//		if (lit instanceof RoamDoubleLiteral) {
//			
//		}
		// TODO: ^There is no 'RoamDoubleLiteral' or 'RoamIntegerLiteral'
		
		final String val = lit.getValue();
		try {
			Integer.valueOf(val);
//			return Integer.class;
			return EcorePackage.Literals.EINT;
		} catch(final NumberFormatException ex) {
			// No int
		}
		try {
			Double.valueOf(val);
//			return Double.class;
			return EcorePackage.Literals.EDOUBLE;
		} catch(final NumberFormatException ex) {
			throw new IllegalStateException("Instance type not found.");
		}
	}
	
	public Class<? extends EObject> getEvalTypeDelegate(final EObject e) {
		if (e instanceof RoamBoolExpr) {
			return getEvalTypeFromBoolExpr((RoamBoolExpr) e);
		} else if (e instanceof RoamArithmeticExpr) {
			return getEvalTypeFromArithExpr((RoamArithmeticExpr) e);
		} else if (e instanceof RoamBool) {
			return getEvalTypeFromBoolExpr(((RoamBool) e).getExpr());
		}
		
		// TODO:
		return null;
	}
	
	public Class<? extends EObject> getEvalLeftRightSide(final EObject left, final EObject right) {
		final Class<? extends EObject> lhs = getEvalTypeDelegate(left);
		final Class<? extends EObject> rhs = getEvalTypeDelegate(right);
		if (lhs.equals(rhs)) {
			return lhs;
		} else {
			throw new IllegalStateException("Expression does not evaluate correctly.");
		}
	}
	
}
